[
  {
    "name": "_right",
    "text": "const _right = <E, A>(): Prism<Either<E, A>, A> => r",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Prism<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 14,
        "to": 14
      }
    }
  },
  {
    "name": "_left",
    "text": "const _left = <E, A>(): Prism<Either<E, A>, E> => l",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Prism<any, E>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 25,
        "to": 25
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\n\n/**\n * Create a `Traversal` from a `Traversable`\n *\n * @example\n * import { Lens, fromTraversable } from 'monocle-ts'\n * import { array } from 'fp-ts/lib/Array'\n *\n * interface Tweet {\n *   text: string\n * }\n *\n * interface Tweets {\n *   tweets: Tweet[]\n * }\n *\n * const tweetsLens = Lens.fromProp<Tweets>()('tweets')\n * const tweetTextLens = Lens.fromProp<Tweet>()('text')\n * const tweetTraversal = fromTraversable(array)<Tweet>()\n * const composedTraversal = tweetsLens.composeTraversal(tweetTraversal).composeLens(tweetTextLens)\n *\n * const tweet1: Tweet = { text: 'hello world' }\n * const tweet2: Tweet = { text: 'foobar' }\n * const model: Tweets = { tweets: [tweet1, tweet2] }\n *\n * const actual = composedTraversal.modify(text =>\n *   text\n *     .split('')\n *     .reverse()\n *     .join('')\n * )(model)\n *\n * assert.deepStrictEqual(actual, { tweets: [ { text: 'dlrow olleh' }, { text: 'raboof' } ] })\n *\n * @category constructor\n * @since 1.0.0\n */\nexport function fromTraversable<T extends URIS3>(T: Traversable3<T>): <U, L, A>() => Traversal<Kind3<T, U, L, A>, A>",
    "docs": "/**\n * Create a `Traversal` from a `Traversable`\n *\n * @example\n * import { Lens, fromTraversable } from 'monocle-ts'\n * import { array } from 'fp-ts/lib/Array'\n *\n * interface Tweet {\n *   text: string\n * }\n *\n * interface Tweets {\n *   tweets: Tweet[]\n * }\n *\n * const tweetsLens = Lens.fromProp<Tweets>()('tweets')\n * const tweetTextLens = Lens.fromProp<Tweet>()('text')\n * const tweetTraversal = fromTraversable(array)<Tweet>()\n * const composedTraversal = tweetsLens.composeTraversal(tweetTraversal).composeLens(tweetTextLens)\n *\n * const tweet1: Tweet = { text: 'hello world' }\n * const tweet2: Tweet = { text: 'foobar' }\n * const model: Tweets = { tweets: [tweet1, tweet2] }\n *\n * const actual = composedTraversal.modify(text =>\n *   text\n *     .split('')\n *     .reverse()\n *     .join('')\n * )(model)\n *\n * assert.deepStrictEqual(actual, { tweets: [ { text: 'dlrow olleh' }, { text: 'raboof' } ] })\n *\n * @category constructor\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1601,
        "to": 1601
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T extends URIS2>(T: Traversable2<T>): <L, A>() => Traversal<Kind2<T, L, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1602,
        "to": 1602
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T extends URIS>(T: Traversable1<T>): <A>() => Traversal<Kind<T, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1603,
        "to": 1603
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T>(T: Traversable<T>): <A>() => Traversal<HKT<T, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1604,
        "to": 1604
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T>(T: Traversable<T>): <A>() => Traversal<HKT<T, A>, A> {\n  return <A>() =>\n    new Traversal(<F>(F: Applicative<F>) => {\n      const traverseF = T.traverse(F)\n      return (f: (a: A) => HKT<F, A>) => (s: HKT<T, A>) => traverseF(s, f)\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1605,
        "to": 1611
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a `Fold` from a `Foldable`\n *\n * @category constructor\n * @since 1.0.0\n */\nexport function fromFoldable<F extends URIS3>(F: Foldable3<F>): <U, L, A>() => Fold<Kind3<F, U, L, A>, A>",
    "docs": "/**\n * Create a `Fold` from a `Foldable`\n *\n * @category constructor\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1619,
        "to": 1619
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2>(F: Foldable2<F>): <L, A>() => Fold<Kind2<F, L, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1620,
        "to": 1620
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS>(F: Foldable1<F>): <A>() => Fold<Kind<F, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1621,
        "to": 1621
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F>(F: Foldable<F>): <A>() => Fold<HKT<F, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1622,
        "to": 1622
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F>(F: Foldable<F>): <A>() => Fold<HKT<F, A>, A> {\n  return <A>() =>\n    new Fold<HKT<F, A>, A>(<M>(M: Monoid<M>) => {\n      const foldMapFM = F.foldMap(M)\n      return (f: (a: A) => M) => (s) => foldMapFM(s, f)\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1623,
        "to": 1629
      }
    }
  },
  {
    "name": "atRecord",
    "text": "\n\n/**\n * @category constructor\n * @since 1.7.0\n */\nexport function atRecord<A = never>(): At<Record<string, A>, string, Option<A>> {\n  return new At(\n    (k) =>\n      new Lens(\n        (r) => R.lookup(k, r),\n        (oa) => (r) => {\n          if (isNone(oa)) {\n            return R.deleteAt(k)(r)\n          } else {\n            return R.insertAt(k, oa.value)(r)\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.7.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").At<Record<string, A>, string, any>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/At/Record.ts",
      "lines": {
        "from": 12,
        "to": 26
      }
    }
  },
  {
    "name": "atSet",
    "text": "\n\n/**\n * @category constructor\n * @since 1.2.0\n */\nexport function atSet<A = never>(E: Eq<A>): At<Set<A>, A, boolean> {\n  const elemE = S.elem(E)\n  const insertE = S.insert(E)\n  const removeE = S.remove(E)\n  return new At((at) => {\n    const insertEAt = insertE(at)\n    const removeEAt = removeE(at)\n    return new Lens(\n      (s) => elemE(at, s),\n      (a) => (s) => (a ? insertEAt(s) : removeEAt(s))\n    )\n  })\n}",
    "docs": "/**\n * @category constructor\n * @since 1.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").At<Set<A>, A, boolean>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/At/Set.ts",
      "lines": {
        "from": 12,
        "to": 24
      }
    }
  },
  {
    "name": "indexArray",
    "text": "\n\n/**\n * @category constructor\n * @since 1.2.0\n */\nexport function indexArray<A = never>(): Index<Array<A>, number, A> {\n  return new Index(\n    (i) =>\n      new Optional(\n        (as) => lookup(i, as),\n        (a) => (as) => {\n          const oas = updateAt(i, a)(as)\n          if (isNone(oas)) {\n            return as\n          } else {\n            return oas.value\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.2.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<A[], number, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/Array.ts",
      "lines": {
        "from": 12,
        "to": 27
      }
    }
  },
  {
    "name": "indexNonEmptyArray",
    "text": "\n\n/**\n * @category constructor\n * @since 1.5.0\n */\nexport function indexNonEmptyArray<A = never>(): Index<NonEmptyArray<A>, number, A> {\n  return new Index(\n    (i) =>\n      new Optional(\n        (s) => lookup(i, s),\n        (a) => (nea) => {\n          const onea = updateAt(i, a)(nea)\n          if (isNone(onea)) {\n            return nea\n          } else {\n            return onea.value\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<any, number, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/NonEmptyArray.ts",
      "lines": {
        "from": 13,
        "to": 28
      }
    }
  },
  {
    "name": "indexRecord",
    "text": "\n\n/**\n * @category constructor\n * @since 1.7.0\n */\nexport function indexRecord<A = never>(): Index<Record<string, A>, string, A> {\n  return Index.fromAt(atRecord<A>())\n}",
    "docs": "/**\n * @category constructor\n * @since 1.7.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<Record<string, A>, string, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/Record.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * @internal\n */\nexport function cons<A>(head: A, tail: LinkedList<A>): LinkedList<A> {\n  return {\n    type: 'Cons',\n    head,\n    tail,\n    length: tail.length + 1\n  }\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 35,
        "to": 42
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * @internal\n */\nexport function toArray<A>(list: LinkedList<A>): Array<A> {\n  const len = list.length\n  const r: Array<A> = new Array(len)\n  let l: LinkedList<A> = list\n  let i = 1\n  while (l.type !== 'Nil') {\n    r[len - i] = l.head\n    i++\n    l = l.tail\n  }\n  return r\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "list",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 47,
        "to": 58
      }
    }
  },
  {
    "name": "toRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function toRequestHandler<I, O, E>(middleware: Middleware<I, O, E, void>): RequestHandler {\n  return (req, res, next) => exec(middleware, req, res, next)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "middleware",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 219,
        "to": 221
      }
    }
  },
  {
    "name": "toErrorRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function toErrorRequestHandler<I, O, E>(f: (err: unknown) => Middleware<I, O, E, void>): ErrorRequestHandler {\n  return (err, req, res, next) => exec(f(err), req, res, next)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(err: unknown) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 226,
        "to": 228
      }
    }
  },
  {
    "name": "fromRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromRequestHandler<I = StatusOpen, E = never, A = never>(\n  requestHandler: RequestHandler,\n  f: (req: Request) => A\n): Middleware<I, I, E, A> {\n  return c =>\n    rightTask(\n      () =>\n        new Promise(resolve => {\n          const { req, res } = c as ExpressConnection<I>\n          requestHandler(req, res, () => resolve([f(req), c]))\n        })\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "requestHandler",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(req: any) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 233,
        "to": 245
      }
    }
  },
  {
    "name": "gets",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function gets<I = StatusOpen, E = never, A = never>(f: (c: Connection<I>) => A): Middleware<I, I, E, A> {\n  return c => TE.right([f(c), c])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 202,
        "to": 204
      }
    }
  },
  {
    "name": "fromConnection",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromConnection<I = StatusOpen, E = never, A = never>(\n  f: (c: Connection<I>) => Either<E, A>\n): Middleware<I, I, E, A> {\n  return c =>\n    TE.fromEither(\n      pipe(\n        f(c),\n        mapEither(a => [a, c])\n      )\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 209,
        "to": 219
      }
    }
  },
  {
    "name": "modifyConnection",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function modifyConnection<I, O, E>(f: (c: Connection<I>) => Connection<O>): Middleware<I, O, E, void> {\n  return c => TE.right([undefined, f(c)])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<O>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 224,
        "to": 226
      }
    }
  },
  {
    "name": "ichain",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function ichain<A, O, Z, E, B>(\n  f: (a: A) => Middleware<O, Z, E, B>\n): <I>(ma: Middleware<I, O, E, A>) => Middleware<I, Z, E, B> {\n  return ma => ci =>\n    pipe(\n      ma(ci),\n      TE.chain(([a, co]) => f(a)(co))\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<O, Z, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, Z, E, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 258,
        "to": 266
      }
    }
  },
  {
    "name": "evalMiddleware",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function evalMiddleware<I, O, E, A>(ma: Middleware<I, O, E, A>, c: Connection<I>): TE.TaskEither<E, A> {\n  return pipe(\n    ma(c),\n    TE.map(([a]) => a)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
          }
        },
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 271,
        "to": 276
      }
    }
  },
  {
    "name": "execMiddleware",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function execMiddleware<I, O, E, A>(\n  ma: Middleware<I, O, E, A>,\n  c: Connection<I>\n): TE.TaskEither<E, Connection<O>> {\n  return pipe(\n    ma(c),\n    TE.map(([, c]) => c)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
          }
        },
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 281,
        "to": 289
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function orElse<E, I, O, M, A>(\n  f: (e: E) => Middleware<I, O, M, A>\n): (ma: Middleware<I, O, E, A>) => Middleware<I, O, M, A> {\n  return ma => c =>\n    pipe(\n      ma(c),\n      TE.orElse(e => f(e)(c))\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, M, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 294,
        "to": 302
      }
    }
  },
  {
    "name": "iof",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function iof<I = StatusOpen, O = StatusOpen, E = never, A = never>(a: A): Middleware<I, O, E, A> {\n  return c => TE.right([a, c as any])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 307,
        "to": 309
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function tryCatch<I = StatusOpen, E = never, A = never>(\n  f: () => Promise<A>,\n  onRejected: (reason: unknown) => E\n): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.tryCatch(f, onRejected))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => Promise<A>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 314,
        "to": 319
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromTaskEither<I = StatusOpen, E = never, A = never>(fa: TE.TaskEither<E, A>): Middleware<I, I, E, A> {\n  return c =>\n    pipe(\n      fa,\n      TE.map(a => [a, c])\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 324,
        "to": 330
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function right<I = StatusOpen, E = never, A = never>(a: A): Middleware<I, I, E, A> {\n  return iof(a)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 335,
        "to": 337
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function left<I = StatusOpen, E = never, A = never>(e: E): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.left(e))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 342,
        "to": 344
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function rightTask<I = StatusOpen, E = never, A = never>(fa: Task<A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.rightTask(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 349,
        "to": 351
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function leftTask<I = StatusOpen, E = never, A = never>(te: Task<E>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.leftTask(te))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "te",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 356,
        "to": 358
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function rightIO<I = StatusOpen, E = never, A = never>(fa: IO<A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.rightIO(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 363,
        "to": 365
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function leftIO<I = StatusOpen, E = never, A = never>(fe: IO<E>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.leftIO(fe))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fe",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 370,
        "to": 372
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromIOEither<I = StatusOpen, E = never, A = never>(fa: IOEither<E, A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.fromIOEither(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 377,
        "to": 379
      }
    }
  },
  {
    "name": "status",
    "text": "\n\n/**\n * Returns a middleware that writes the response status\n *\n * @since 0.5.0\n */\nexport function status<E = never>(status: Status): Middleware<StatusOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setStatus(status))\n}",
    "docs": "/**\n * Returns a middleware that writes the response status\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "status",
          "type": {
            "__tag": "Other",
            "values": "100 | 101 | 102 | 103 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 421 | 422 | 423 | 424 | 425 | 426 | 428 | 429 | 431 | 451 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 386,
        "to": 388
      }
    }
  },
  {
    "name": "header",
    "text": "\n\n/**\n * Returns a middleware that writes the given header\n *\n * @since 0.5.0\n */\nexport function header<E = never>(name: string, value: string): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setHeader(name, value))\n}",
    "docs": "/**\n * Returns a middleware that writes the given header\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 395,
        "to": 397
      }
    }
  },
  {
    "name": "contentType",
    "text": "\n\n/**\n * Returns a middleware that sets the given `mediaType`\n *\n * @since 0.5.0\n */\nexport function contentType<E = never>(mediaType: MediaType): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return header('Content-Type', mediaType)\n}",
    "docs": "/**\n * Returns a middleware that sets the given `mediaType`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "mediaType",
          "type": {
            "__tag": "Other",
            "values": "\"application/x-www-form-urlencoded\" | \"application/json\" | \"application/javascript\" | \"application/octet-stream\" | \"application/xml\" | \"image/gif\" | \"image/jpeg\" | \"image/png\" | \"multipart/form-data\" | \"text/csv\" | \"text/html\" | \"text/plain\" | \"text/xml\""
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 404,
        "to": 406
      }
    }
  },
  {
    "name": "cookie",
    "text": "\n\n/**\n * Returns a middleware that sets the cookie `name` to `value`, with the given `options`\n *\n * @since 0.5.0\n */\nexport function cookie<E = never>(\n  name: string,\n  value: string,\n  options: CookieOptions\n): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setCookie(name, value, options))\n}",
    "docs": "/**\n * Returns a middleware that sets the cookie `name` to `value`, with the given `options`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 413,
        "to": 419
      }
    }
  },
  {
    "name": "clearCookie",
    "text": "\n\n/**\n * Returns a middleware that clears the cookie `name`\n *\n * @since 0.5.0\n */\nexport function clearCookie<E = never>(\n  name: string,\n  options: CookieOptions\n): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.clearCookie(name, options))\n}",
    "docs": "/**\n * Returns a middleware that clears the cookie `name`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 426,
        "to": 431
      }
    }
  },
  {
    "name": "closeHeaders",
    "text": "\n\n/**\n * Returns a middleware that changes the connection status to `BodyOpen`\n *\n * @since 0.5.0\n */\nexport function closeHeaders<E = never>(): Middleware<HeadersOpen, BodyOpen, E, void> {\n  return closedHeaders\n}",
    "docs": "/**\n * Returns a middleware that changes the connection status to `BodyOpen`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 440,
        "to": 442
      }
    }
  },
  {
    "name": "send",
    "text": "\n\n/**\n * Returns a middleware that sends `body` as response body\n *\n * @since 0.5.0\n */\nexport function send<E = never>(body: string): Middleware<BodyOpen, ResponseEnded, E, void> {\n  return modifyConnection(c => c.setBody(body))\n}",
    "docs": "/**\n * Returns a middleware that sends `body` as response body\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 449,
        "to": 451
      }
    }
  },
  {
    "name": "end",
    "text": "\n\n/**\n * Returns a middleware that ends the response without sending any response body\n *\n * @since 0.5.0\n */\nexport function end<E = never>(): Middleware<BodyOpen, ResponseEnded, E, void> {\n  return ended\n}",
    "docs": "/**\n * Returns a middleware that ends the response without sending any response body\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 460,
        "to": 462
      }
    }
  },
  {
    "name": "json",
    "text": "\n\n/**\n * Returns a middleware that sends `body` as JSON\n *\n * @since 0.5.0\n */\nexport function json<E>(\n  body: unknown,\n  onError: (reason: unknown) => E\n): Middleware<HeadersOpen, ResponseEnded, E, void> {\n  return pipe(\n    fromEither<HeadersOpen, E, string>(stringifyJSON(body, onError)),\n    ichain(json =>\n      pipe(\n        contentType<E>(MediaType.applicationJSON),\n        ichain(() => closeHeaders()),\n        ichain(() => send(json))\n      )\n    )\n  )\n}",
    "docs": "/**\n * Returns a middleware that sends `body` as JSON\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 469,
        "to": 483
      }
    }
  },
  {
    "name": "redirect",
    "text": "\n\n/**\n * Returns a middleware that sends a redirect to `uri`\n *\n * @since 0.5.0\n */\nexport function redirect<E = never>(uri: string): Middleware<StatusOpen, HeadersOpen, E, void> {\n  return pipe(\n    status(Status.Found),\n    ichain(() => header('Location', uri))\n  )\n}",
    "docs": "/**\n * Returns a middleware that sends a redirect to `uri`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "uri",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 490,
        "to": 495
      }
    }
  },
  {
    "name": "decodeParam",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getParams()[name]`\n *\n * @since 0.5.0\n */\nexport function decodeParam<E, A>(\n  name: string,\n  f: (input: unknown) => Either<E, A>\n): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => {\n    const params = c.getParams()\n    return f(isUnknownRecord(params) ? params[name] : undefined)\n  })\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getParams()[name]`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 504,
        "to": 512
      }
    }
  },
  {
    "name": "decodeParams",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getParams()`\n *\n * @since 0.5.0\n */\nexport function decodeParams<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getParams()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getParams()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 519,
        "to": 521
      }
    }
  },
  {
    "name": "decodeQuery",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getQuery()`\n *\n * @since 0.5.0\n */\nexport function decodeQuery<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getQuery()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getQuery()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 528,
        "to": 530
      }
    }
  },
  {
    "name": "decodeBody",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getBody()`\n *\n * @since 0.5.0\n */\nexport function decodeBody<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getBody()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getBody()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 537,
        "to": 539
      }
    }
  },
  {
    "name": "decodeMethod",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getMethod()`\n *\n * @since 0.5.0\n */\nexport function decodeMethod<E, A>(f: (method: string) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getMethod()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getMethod()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(method: string) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 546,
        "to": 548
      }
    }
  },
  {
    "name": "decodeHeader",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getHeader(name)`\n *\n * @since 0.5.0\n */\nexport function decodeHeader<E, A>(\n  name: string,\n  f: (input: unknown) => Either<E, A>\n): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getHeader(name)))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getHeader(name)`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 555,
        "to": 560
      }
    }
  },
  {
    "name": "clone",
    "text": "\n\n/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */\nexport function clone<C extends t.Any>(t: C): C {\n  const r = Object.create(Object.getPrototypeOf(t))\n  Object.assign(r, t)\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "t",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/clone.ts",
      "lines": {
        "from": 17,
        "to": 21
      }
    }
  },
  {
    "name": "either",
    "text": "\n\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either<L extends t.Mixed, R extends t.Mixed>(\n  leftCodec: L,\n  rightCodec: R,\n  name: string = `Either<${leftCodec.name}, ${rightCodec.name}>`\n): EitherC<L, R> {\n  return t.union(\n    [\n      t.strict(\n        {\n          _tag: leftLiteral,\n          left: leftCodec\n        },\n        `Left<${leftCodec.name}>`\n      ),\n      t.strict(\n        {\n          _tag: rightLiteral,\n          right: rightCodec\n        },\n        `Right<${leftCodec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "leftCodec",
          "type": {
            "__tag": "Other",
            "values": "L"
          }
        },
        {
          "name": "rightCodec",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/either\").EitherC<L, R>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/either.ts",
      "lines": {
        "from": 35,
        "to": 59
      }
    }
  },
  {
    "name": "fromNewtype",
    "text": "\n\n/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */\nexport function fromNewtype<N extends AnyNewtype = never>(\n  codec: t.Type<CarrierOf<N>, t.OutputOf<CarrierOf<N>>>,\n  name = `fromNewtype(${codec.name})`\n): t.Type<N, CarrierOf<N>, unknown> {\n  const i = iso<N>()\n  return new t.Type(\n    name,\n    (u): u is N => codec.is(u),\n    (u, c) => either.map(codec.validate(u, c), i.wrap),\n    a => codec.encode(i.unwrap(a))\n  )\n}",
    "docs": "/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromNewtype.ts",
      "lines": {
        "from": 27,
        "to": 38
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */\nexport function fromNullable<C extends t.Mixed>(codec: C, a: t.TypeOf<C>, name = `fromNullable(${codec.name})`): C {\n  return withValidate(codec, (u, c) => (u == null ? t.success(a) : codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromNullable.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "\n\n/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */\nexport function fromRefinement<A>(name: string, is: (u: unknown) => u is A): t.Type<A, A, unknown> {\n  return new t.Type(name, is, (u, c) => (is(u) ? t.success(u) : t.failure(u, c)), t.identity)\n}",
    "docs": "/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "is",
          "type": {
            "__tag": "Other",
            "values": "(u: unknown) => u is A"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromRefinement.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "getLenses",
    "text": "\n\n/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */\nexport function getLenses<C extends HasLenses>(\n  codec: C\n): { [K in keyof t.TypeOf<C>]: Lens<t.TypeOf<C>, t.TypeOf<C>[K]> } {\n  const r: any = {}\n  for (const k in getProps(codec)) {\n    r[k] = fromProp(k)\n  }\n  return r\n}",
    "docs": "/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ [x: string]: any; }"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/getLenses.ts",
      "lines": {
        "from": 45,
        "to": 53
      }
    }
  },
  {
    "name": "mapOutput",
    "text": "\n\n/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */\nexport function mapOutput<A, O, I, P>(\n  codec: t.Type<A, O, I>,\n  f: (p: O) => P,\n  name: string = codec.name\n): t.Type<A, P, I> {\n  return new t.Type(name, codec.is, codec.validate, a => f(codec.encode(a)))\n}",
    "docs": "/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: O) => P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/mapOutput.ts",
      "lines": {
        "from": 28,
        "to": 34
      }
    }
  },
  {
    "name": "nonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function nonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `NonEmptyArray<${codec.name}>`\n): NonEmptyArrayC<C> {\n  const arr = t.array(codec)\n  return new t.Type(\n    name,\n    (u): u is NonEmptyArray<t.TypeOf<C>> => arr.is(u) && isNonEmpty(u),\n    (u, c) =>\n      either.chain(arr.validate(u, c), as => {\n        const onea = fromArray(as)\n        return isNone(onea) ? t.failure(u, c) : t.success(onea.value)\n      }),\n    nea => arr.encode(nea)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/nonEmptyArray\").NonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/nonEmptyArray.ts",
      "lines": {
        "from": 19,
        "to": 34
      }
    }
  },
  {
    "name": "option",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function option<C extends t.Mixed>(codec: C, name: string = `Option<${codec.name}>`): OptionC<C> {\n  return t.union(\n    [\n      None,\n      t.strict(\n        {\n          _tag: someLiteral,\n          value: codec\n        },\n        `Some<${codec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/option\").OptionC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/option.ts",
      "lines": {
        "from": 37,
        "to": 51
      }
    }
  },
  {
    "name": "optionFromNullable",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function optionFromNullable<C extends t.Mixed>(\n  codec: C,\n  name: string = `Option<${codec.name}>`\n): OptionFromNullableC<C> {\n  return new t.Type(\n    name,\n    o(codec).is,\n    (u, c) => (u == null ? t.success(none) : either.map(codec.validate(u, c), some)),\n    a => toNullable(option.map(a, codec.encode))\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/optionFromNullable\").OptionFromNullableC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/optionFromNullable.ts",
      "lines": {
        "from": 18,
        "to": 28
      }
    }
  },
  {
    "name": "readonlyNonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlyNonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `ReadonlyNonEmptyArray<${codec.name}>`\n): ReadonlyNonEmptyArrayC<C> {\n  return nonEmptyArray(codec, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlyNonEmptyArray\").ReadonlyNonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/readonlyNonEmptyArray.ts",
      "lines": {
        "from": 23,
        "to": 28
      }
    }
  },
  {
    "name": "readonlySetFromArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlySetFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `ReadonlySet<${codec.name}>`\n): ReadonlySetFromArrayC<C> {\n  return setFromArray(codec, O, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlySetFromArray\").ReadonlySetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/readonlySetFromArray.ts",
      "lines": {
        "from": 17,
        "to": 23
      }
    }
  },
  {
    "name": "setFromArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function setFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `Set<${codec.name}>`\n): SetFromArrayC<C> {\n  const arr = t.array(codec)\n  const toArrayO = toArray(O)\n  const fromArrayO = fromArray(O)\n  return new t.Type(\n    name,\n    (u): u is Set<t.TypeOf<C>> => u instanceof Set && every(codec.is)(u),\n    (u, c) =>\n      either.chain(arr.validate(u, c), as => {\n        const set = fromArrayO(as)\n        return set.size !== as.length ? t.failure(u, c) : t.success(set)\n      }),\n    set => arr.encode(toArrayO(set))\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/setFromArray\").SetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/setFromArray.ts",
      "lines": {
        "from": 17,
        "to": 35
      }
    }
  },
  {
    "name": "withFallback",
    "text": "\n\n/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */\nexport function withFallback<C extends t.Any>(codec: C, a: t.TypeOf<C>, name = `withFallback(${codec.name})`): C {\n  return withValidate(codec, (u, c) => orElse(() => t.success(a))(codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withFallback.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "withMessage",
    "text": "\n\n/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */\nexport function withMessage<C extends t.Any>(codec: C, message: (i: t.InputOf<C>) => string): C {\n  return withValidate(codec, (i, c) =>\n    mapLeft(() => [\n      {\n        value: i,\n        context: c,\n        message: message(i),\n        actual: i\n      }\n    ])(codec.validate(i, c))\n  )\n}",
    "docs": "/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "Other",
            "values": "(i: any) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withMessage.ts",
      "lines": {
        "from": 24,
        "to": 35
      }
    }
  },
  {
    "name": "withValidate",
    "text": "\n\n/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */\nexport function withValidate<C extends t.Any>(codec: C, validate: C['validate'], name: string = codec.name): C {\n  const r: any = clone(codec)\n  r.validate = validate\n  // tslint:disable-next-line: deprecation\n  r.decode = (i: any) => validate(i, t.getDefaultContext(r))\n  r.name = name\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "validate",
          "type": {
            "__tag": "Other",
            "values": "C[\"validate\"]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withValidate.ts",
      "lines": {
        "from": 23,
        "to": 30
      }
    }
  },
  {
    "name": "assertStrictEqual",
    "text": "\n\nexport function assertStrictEqual<T>(result: t.Validation<T>, expected: any): void {\n  if (isRight(result)) {\n    assert.deepStrictEqual(result.right, expected)\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 6,
        "to": 12
      }
    }
  },
  {
    "name": "assertSuccess",
    "text": "\n\nexport function assertSuccess<T>(result: t.Validation<T>, expected?: T): void {\n  if (isRight(result)) {\n    if (expected !== undefined) {\n      assert.deepStrictEqual(result.right, expected)\n    }\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 14,
        "to": 22
      }
    }
  },
  {
    "name": "assertStrictSuccess",
    "text": "\n\nexport function assertStrictSuccess<T>(result: t.Validation<T>, expected: T): void {\n  if (isRight(result)) {\n    if (expected !== undefined) {\n      assert.strictEqual(result.right, expected)\n    }\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 24,
        "to": 32
      }
    }
  },
  {
    "name": "assertFailure",
    "text": "\n\nexport function assertFailure(codec: t.Any, value: unknown, errors: Array<string>): void {\n  const result = codec.decode(value)\n  if (isLeft(result)) {\n    assert.deepStrictEqual(PathReporter.report(result), errors)\n  } else {\n    throw new Error(`${result} is not a left`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "string[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 34,
        "to": 41
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function fold<A, B>(onNone: () => Array<B>, onSome: (a: A) => Array<B>): (as: ArrayOption<A>) => Array<B> {\n  return as => T.fold(as, onNone, onSome)\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => B[]"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => B[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 57,
        "to": 59
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function getOrElse<A>(onNone: () => Array<A>): (as: ArrayOption<A>) => Array<A> {\n  return as => T.getOrElse(as, onNone)\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 64,
        "to": 66
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromOptionK<A extends Array<unknown>, B>(f: (...a: A) => Option<B>): (...a: A) => ArrayOption<B> {\n  return (...a) => fromOption(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainOptionK<A, B>(f: (a: A) => Option<B>): (ma: ArrayOption<A>) => ArrayOption<B> {\n  return chain(fromOptionK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\n\n/**\n * Like `array.traverse` but actions are batched in chunks.\n * You can use `Array.chunksOf` to provide the `as` argument.\n *\n * @since 0.1.0\n */\nexport function batchTraverse<M extends URIS3>(\n  M: Monad3<M>\n): <U, L, A, B>(as: Array<Array<A>>, f: (a: A) => Kind3<M, U, L, B>) => Kind3<M, U, L, Array<B>>",
    "docs": "/**\n * Like `array.traverse` but actions are batched in chunks.\n * You can use `Array.chunksOf` to provide the `as` argument.\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 14,
        "to": 16
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS2>(\n  M: Monad2<M>\n): <L, A, B>(as: Array<Array<A>>, f: (a: A) => Kind2<M, L, B>) => Kind2<M, L, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 17,
        "to": 19
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS2, L>(\n  M: Monad2C<M, L>\n): <A, B>(as: Array<Array<A>>, f: (a: A) => Kind2<M, L, B>) => Kind2<M, L, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 20,
        "to": 22
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(as: Array<Array<A>>, f: (a: A) => Kind<M, B>) => Kind<M, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M>(M: Monad<M>): <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) => HKT<M, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 26,
        "to": 26
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M>(M: Monad<M>): <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) => HKT<M, Array<B>> {\n  const traverseM = array.traverse(M)\n  return <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) =>\n    as.reduce(\n      (mbs: HKT<M, Array<B>>, chunk: Array<A>) =>\n        M.chain(mbs, bs =>\n          M.map(traverseM(chunk, f), chunk => {\n            bs.push(...chunk)\n            return bs\n          })\n        ),\n      M.of([])\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 27,
        "to": 40
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\n\n/**\n * Execute an action repeatedly until the `Option` condition returns a `Some`. Collects results into an arbitrary `Alt`\n * value, such as a `Array` or `NonEmptyArray`.\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import * as E from 'fp-ts/lib/Either'\n * import { flow } from 'fp-ts/lib/function'\n * import * as O from 'fp-ts/lib/Option'\n * import * as TE from 'fp-ts/lib/TaskEither'\n * import { collectUntil } from 'fp-ts-contrib/lib/collectUntil'\n *\n * interface Page {\n *   rows: Array<string>\n *   current_page: number\n *   last_page: number\n * }\n *\n * // fake API\n * function fetchPage(current_page: number): TE.TaskEither<string, Page> {\n *   if (current_page <= 3) {\n *     return TE.right({\n *       rows: [`row1-Page${current_page}`, `row2-Page${current_page}`],\n *       current_page: current_page,\n *       last_page: 3\n *     })\n *   } else {\n *     return TE.left('invalid page')\n *   }\n * }\n *\n * const getNextInput = (page: Page): O.Option<number> =>\n *   page.current_page < page.last_page ? O.some(page.current_page + 1) : O.none\n *\n * const collectRows = collectUntil(\n *   TE.taskEither,\n *   array\n * )(\n *   flow(\n *     fetchPage,\n *     TE.map(page => [page.rows, getNextInput(page)])\n *   )\n * )\n *\n * collectRows(1)().then(rows => {\n *   assert.deepStrictEqual(\n *     rows,\n *     E.right(['row1-Page1', 'row2-Page1', 'row1-Page2', 'row2-Page2', 'row1-Page3', 'row2-Page3'])\n *   )\n * })\n *\n * @since 0.1.8\n */\nexport function collectUntil<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Alt1<F>\n): <I, E, A>(f: (i: I) => Kind2<M, E, [Kind<F, A>, Option<I>]>) => (i: I) => Kind2<M, E, Kind<F, A>>",
    "docs": "/**\n * Execute an action repeatedly until the `Option` condition returns a `Some`. Collects results into an arbitrary `Alt`\n * value, such as a `Array` or `NonEmptyArray`.\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import * as E from 'fp-ts/lib/Either'\n * import { flow } from 'fp-ts/lib/function'\n * import * as O from 'fp-ts/lib/Option'\n * import * as TE from 'fp-ts/lib/TaskEither'\n * import { collectUntil } from 'fp-ts-contrib/lib/collectUntil'\n *\n * interface Page {\n *   rows: Array<string>\n *   current_page: number\n *   last_page: number\n * }\n *\n * // fake API\n * function fetchPage(current_page: number): TE.TaskEither<string, Page> {\n *   if (current_page <= 3) {\n *     return TE.right({\n *       rows: [`row1-Page${current_page}`, `row2-Page${current_page}`],\n *       current_page: current_page,\n *       last_page: 3\n *     })\n *   } else {\n *     return TE.left('invalid page')\n *   }\n * }\n *\n * const getNextInput = (page: Page): O.Option<number> =>\n *   page.current_page < page.last_page ? O.some(page.current_page + 1) : O.none\n *\n * const collectRows = collectUntil(\n *   TE.taskEither,\n *   array\n * )(\n *   flow(\n *     fetchPage,\n *     TE.map(page => [page.rows, getNextInput(page)])\n *   )\n * )\n *\n * collectRows(1)().then(rows => {\n *   assert.deepStrictEqual(\n *     rows,\n *     E.right(['row1-Page1', 'row2-Page1', 'row1-Page2', 'row2-Page2', 'row1-Page3', 'row2-Page3'])\n *   )\n * })\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 64,
        "to": 67
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M extends URIS, F extends URIS2>(\n  M: Monad1<M>,\n  F: Alt2<F>\n): <I, E, A>(f: (i: I) => Kind<M, [Kind2<F, E, A>, Option<I>]>) => (i: I) => Kind<M, Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 68,
        "to": 71
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Alt1<F>\n): <I, A>(f: (i: I) => Kind<M, [Kind<F, A>, Option<I>]>) => (i: I) => Kind<M, Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 72,
        "to": 75
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M, F>(\n  M: Monad<M>,\n  F: Alt<F>\n): <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>) => (i: I) => HKT<M, HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 76,
        "to": 79
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M, F>(\n  M: Monad<M>,\n  F: Alt<F>\n): <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>) => (i: I) => HKT<M, HKT<F, A>> {\n  return <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>): ((i: I) => HKT<M, HKT<F, A>>) => {\n    const go = (mfa: HKT<M, [HKT<F, A>, Option<I>]>): HKT<M, HKT<F, A>> => {\n      return M.chain(mfa, ([fx, oi]) => {\n        return pipe(\n          oi,\n          fold(\n            () => M.of(fx),\n            i => go(M.map(f(i), ([fy, oi]) => [F.alt(fx, () => fy), oi]))\n          )\n        )\n      })\n    }\n    return flow(f, go)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 80,
        "to": 98
      }
    }
  },
  {
    "name": "Do",
    "text": "\n\n/**\n * This function provides a simulation of Haskell do notation. The `bind` / `bindL` functions contributes to a threaded\n * scope that is available to each subsequent step. The `do` / `doL` functions can be used to perform computations that\n * add nothing to the scope. The `return` function lifts the given callback to the monad context. Finally the `done`\n * function returns the scope.\n *\n * @example\n * import { option, some } from 'fp-ts/lib/Option'\n * import { Do } from 'fp-ts-contrib/lib/Do'\n *\n * // x: Option<number>\n * const x = Do(option) // <- a monad instance\n *   .bindL('foo', () => some('bar'))\n *   .bindL('baz', () => some(4))\n *   .return(({ foo, baz }) => foo.length + baz)\n *\n * assert.deepStrictEqual(x, some(7))\n *\n * @since 0.0.2\n */\nexport function Do<M extends URIS3>(M: Monad3<M>): Do3<M, {}>",
    "docs": "/**\n * This function provides a simulation of Haskell do notation. The `bind` / `bindL` functions contributes to a threaded\n * scope that is available to each subsequent step. The `do` / `doL` functions can be used to perform computations that\n * add nothing to the scope. The `return` function lifts the given callback to the monad context. Finally the `done`\n * function returns the scope.\n *\n * @example\n * import { option, some } from 'fp-ts/lib/Option'\n * import { Do } from 'fp-ts-contrib/lib/Do'\n *\n * // x: Option<number>\n * const x = Do(option) // <- a monad instance\n *   .bindL('foo', () => some('bar'))\n *   .bindL('baz', () => some(4))\n *   .return(({ foo, baz }) => foo.length + baz)\n *\n * assert.deepStrictEqual(x, some(7))\n *\n * @since 0.0.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do3<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 227,
        "to": 227
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS2>(M: Monad2<M>): Do2<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do2<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 228,
        "to": 228
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS2, L>(M: Monad2C<M, L>): Do2C<M, {}, L>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do2C<M, {}, L>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 229,
        "to": 229
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS>(M: Monad1<M>): Do1<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do1<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 230,
        "to": 230
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M>(M: Monad<M>): Do0<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do0<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 231,
        "to": 231
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M>(M: Monad<M>): any {\n  return new DoClass(M, M.of(init))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 232,
        "to": 234
      }
    }
  },
  {
    "name": "filterA",
    "text": "\n\n/**\n * This generalizes the array-based `filter` function.\n *\n * @example\n * import { io, IO } from 'fp-ts/lib/IO'\n * import { filterA } from 'fp-ts-contrib/lib/filterA'\n *\n * const filterAIO = filterA(io)\n *\n * const p = (n: number): IO<boolean> => io.of(n % 2 === 0)\n *\n * assert.deepStrictEqual(filterAIO(p)([1, 2, 3, 4, 5])(), [2, 4])\n *\n * @since 0.1.15\n */\nexport function filterA<F extends URIS4>(\n  F: Applicative4<F>\n): <S, R, E, A>(p: (a: A) => Kind4<F, S, R, E, boolean>) => (as: Array<A>) => Kind4<F, S, R, E, Array<A>>",
    "docs": "/**\n * This generalizes the array-based `filter` function.\n *\n * @example\n * import { io, IO } from 'fp-ts/lib/IO'\n * import { filterA } from 'fp-ts-contrib/lib/filterA'\n *\n * const filterAIO = filterA(io)\n *\n * const p = (n: number): IO<boolean> => io.of(n % 2 === 0)\n *\n * assert.deepStrictEqual(filterAIO(p)([1, 2, 3, 4, 5])(), [2, 4])\n *\n * @since 0.1.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 31,
        "to": 33
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A>(p: (a: A) => Kind3<F, R, E, boolean>) => (as: Array<A>) => Kind3<F, R, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 34,
        "to": 36
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A>(p: (a: A) => Kind2<F, E, boolean>) => (as: Array<A>) => Kind2<F, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 37,
        "to": 39
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A>(p: (a: A) => Kind2<F, E, boolean>) => (as: Array<A>) => Kind2<F, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 40,
        "to": 42
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS>(\n  F: Applicative1<F>\n): <A>(p: (a: A) => Kind<F, boolean>) => (as: Array<A>) => Kind<F, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 43,
        "to": 45
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F>(F: Applicative<F>): <A>(p: (a: A) => HKT<F, boolean>) => (as: Array<A>) => HKT<F, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 46,
        "to": 46
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F>(F: Applicative<F>): <A>(p: (a: A) => HKT<F, boolean>) => (as: Array<A>) => HKT<F, Array<A>> {\n  const wither = A.array.wither(F)\n  return p => as => wither(as, a => F.map(p(a), b => (b ? O.some(a) : O.none)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 47,
        "to": 50
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\n\n/**\n * Use a natural transformation to change the generating type constructor of a free monad\n *\n * @since 0.1.3\n */\nexport function hoistFree<F extends URIS3 = never, G extends URIS3 = never>(\n  nt: <U, L, A>(fa: Kind3<F, U, L, A>) => Kind3<G, U, L, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "/**\n * Use a natural transformation to change the generating type constructor of a free monad\n *\n * @since 0.1.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<U, L, A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 83,
        "to": 85
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F extends URIS2 = never, G extends URIS2 = never>(\n  nt: <L, A>(fa: Kind2<F, L, A>) => Kind2<G, L, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<L, A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F extends URIS = never, G extends URIS = never>(\n  nt: <A>(fa: Kind<F, A>) => Kind<G, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F, G>(nt: <A>(fa: HKT<F, A>) => HKT<G, A>): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F, G>(nt: <A>(fa: HKT<F, A>) => HKT<G, A>): <A>(fa: Free<F, A>) => Free<G, A> {\n  return substFree(fa => liftF(nt(fa)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\n\n/**\n * Perform folding of a free monad using given natural transformation as an interpreter\n *\n * @since 0.1.3\n */\nexport function foldFree<M extends URIS3>(M: Monad3<M>): FoldFree3<M>",
    "docs": "/**\n * Perform folding of a free monad using given natural transformation as an interpreter\n *\n * @since 0.1.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree3<M>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 127,
        "to": 127
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS2>(M: Monad2<M>): FoldFree2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree2<M>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 128,
        "to": 128
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS2, L>(M: Monad2C<M, L>): FoldFree2C<M, L>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree2C<M, L>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 129,
        "to": 129
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS>(\n  M: Monad1<M>\n): <F extends URIS, A>(nt: <X>(fa: Kind<F, X>) => Kind<M, X>, fa: Free<F, A>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F extends any, A>(nt: <X>(fa: any) => any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 130,
        "to": 132
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M>(M: Monad<M>): <F, A>(nt: <X>(fa: HKT<F, X>) => HKT<M, X>, fa: Free<F, A>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F, A>(nt: <X>(fa: any) => any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 133,
        "to": 133
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M>(M: Monad<M>): <F, A>(nt: any, fa: Free<F, A>) => HKT<M, A> {\n  return (nt, fa) => {\n    if (isPure(fa)) {\n      return M.of(fa.value)\n    } else {\n      return M.chain(nt(fa.fx), x => foldFree(M)(nt, fa.f(x)))\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F, A>(nt: any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 134,
        "to": 142
      }
    }
  },
  {
    "name": "isPure",
    "text": "const isPure = <F, A>(fa: Free<F, A>): fa is Pure<F, A> => fa._tag === 'Pure'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "isImpure",
    "text": "const isImpure = <F, A>(fa: Free<F, A>): fa is Impure<F, A, any> => fa._tag === 'Impure'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 57,
        "to": 57
      }
    }
  },
  {
    "name": "liftF",
    "text": "const liftF = <F, A>(fa: HKT<F, A>): Free<F, A> => impure(fa, a => free.of(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 64,
        "to": 64
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function fold<A, B>(onNone: () => IO<B>, onSome: (a: A) => IO<B>): (ma: IOOption<A>) => IO<B> {\n  return ma => T.fold(ma, onNone, onSome)\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 64,
        "to": 66
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function fromNullable<A>(a: A): IOOption<NonNullable<A>> {\n  return fromOption(O.fromNullable(a))\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<NonNullable<A>>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function getOrElse<A>(onNone: () => IO<A>): (ma: IOOption<A>) => IO<A> {\n  return ma => T.getOrElse(ma, onNone)\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function fromIOEither<A>(ma: IOEither<any, A>): IOOption<A> {\n  return io.map(ma, O.fromEither)\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "toUndefined",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function toUndefined<A>(ma: IOOption<A>): IO<A | undefined> {\n  return io.map(ma, O.toUndefined)\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "toNullable",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function toNullable<A>(ma: IOOption<A>): IO<A | null> {\n  return io.map(ma, O.toNullable)\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "mapNullable",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function mapNullable<A, B>(f: (a: A) => B | null | undefined): (ma: IOOption<A>) => IOOption<B> {\n  return ioMap(O.mapNullable(f))\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function getApplySemigroup<A>(S: Semigroup<A>): Semigroup<IOOption<A>> {\n  return getIOSemigroup(O.getApplySemigroup<A>(S))\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 113,
        "to": 115
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function getApplyMonoid<A>(M: Monoid<A>): Monoid<IOOption<A>> {\n  return {\n    concat: getApplySemigroup<A>(M).concat,\n    empty: some(M.empty)\n  }\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 120,
        "to": 125
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function fromOptionK<A extends Array<unknown>, B>(f: (...a: A) => Option<B>): (...a: A) => IOOption<B> {\n  return (...a) => fromOption(f(...a))\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 130,
        "to": 132
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\n\n/**\n * @since 0.1.14\n */\nexport function chainOptionK<A, B>(f: (a: A) => Option<B>): (ma: IOOption<A>) => IOOption<B> {\n  return chain(fromOptionK(f))\n}",
    "docs": "/**\n * @since 0.1.14\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 137,
        "to": 139
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * Attaches an element to the front of a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })\n *\n * @since 0.1.8\n */\nexport function cons<A>(head: A, tail: List<A>): List<A> {\n  return { type: 'Cons', head, tail, length: 1 + tail.length }\n}",
    "docs": "/**\n * Attaches an element to the front of a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.cons('a', L.nil), { type: 'Cons', head: 'a', tail: L.nil, length: 1 })\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "of",
    "text": "\n\n/**\n * Creates a list with a single element.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))\n *\n * @since 0.1.8\n */\nexport function of<A>(head: A): List<A> {\n  return cons(head, nil)\n}",
    "docs": "/**\n * Creates a list with a single element.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.of('a'), L.cons('a', L.nil))\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "isNil",
    "text": "\n\n/**\n * Tests whether a list is an empty list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.strictEqual(L.isNil(L.nil), true)\n * assert.strictEqual(L.isNil(L.of(6)), false)\n *\n * @since 0.1.8\n */\nexport function isNil<A>(a: List<A>): a is Nil {\n  return a.type === 'Nil'\n}",
    "docs": "/**\n * Tests whether a list is an empty list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.strictEqual(L.isNil(L.nil), true)\n * assert.strictEqual(L.isNil(L.of(6)), false)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 100,
        "to": 102
      }
    }
  },
  {
    "name": "isCons",
    "text": "\n\n/**\n * Tests whether a list is a non empty list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.strictEqual(L.isCons(L.nil), false)\n * assert.strictEqual(L.isCons(L.of(1)), true)\n *\n * @since 0.1.8\n */\nexport function isCons<A>(a: List<A>): a is Cons<A> {\n  return a.type === 'Cons'\n}",
    "docs": "/**\n * Tests whether a list is a non empty list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.strictEqual(L.isCons(L.nil), false)\n * assert.strictEqual(L.isCons(L.of(1)), true)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 115,
        "to": 117
      }
    }
  },
  {
    "name": "head",
    "text": "\n\n/**\n * Gets the first element in a list, or `None` if the list is empty.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.head(L.nil), O.none)\n * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))\n *\n * @since 0.1.8\n */\nexport function head<A>(fa: List<A>): O.Option<A> {\n  return isCons(fa) ? O.some(fa.head) : O.none\n}",
    "docs": "/**\n * Gets the first element in a list, or `None` if the list is empty.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.head(L.nil), O.none)\n * assert.deepStrictEqual(L.head(L.cons('x', L.of('a'))), O.some('x'))\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 131,
        "to": 133
      }
    }
  },
  {
    "name": "tail",
    "text": "\n\n/**\n * Gets all but the first element of a list, or `None` if the list is empty.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.tail(L.nil), O.none)\n * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))\n * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))\n *\n * @since 0.1.8\n */\nexport function tail<A>(fa: List<A>): O.Option<List<A>> {\n  return isCons(fa) ? O.some(fa.tail) : O.none\n}",
    "docs": "/**\n * Gets all but the first element of a list, or `None` if the list is empty.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.tail(L.nil), O.none)\n * assert.deepStrictEqual(L.tail(L.of('a')), O.some(L.nil))\n * assert.deepStrictEqual(L.tail(L.cons('x', L.of('a'))), O.some(L.of('a')))\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 148,
        "to": 150
      }
    }
  },
  {
    "name": "foldLeft",
    "text": "\n\n/**\n * Breaks a list into its first element and the remaining elements.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const len: <A>(as: L.List<A>) => number = L.foldLeft(\n *   () => 0,\n *   (_, tail) => 1 + len(tail)\n * )\n * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)\n * @since 0.1.8\n */\nexport function foldLeft<A, B>(onNil: () => B, onCons: (head: A, tail: List<A>) => B): (fa: List<A>) => B {\n  return fa => (isNil(fa) ? onNil() : onCons(fa.head, fa.tail))\n}",
    "docs": "/**\n * Breaks a list into its first element and the remaining elements.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const len: <A>(as: L.List<A>) => number = L.foldLeft(\n *   () => 0,\n *   (_, tail) => 1 + len(tail)\n * )\n * assert.deepStrictEqual(len(L.cons('a', L.of('b'))), 2)\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNil",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        },
        {
          "name": "onCons",
          "type": {
            "__tag": "Other",
            "values": "(head: A, tail: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => B"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 165,
        "to": 167
      }
    }
  },
  {
    "name": "findIndex",
    "text": "\n\n/**\n * Finds the first index for which a predicate holds.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const f = (a: number): boolean => a % 2 === 0\n * const findIndexEven = L.findIndex(f)\n * assert.deepStrictEqual(findIndexEven(L.nil), O.none)\n * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))\n * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)\n *\n * @since 0.1.8\n */\nexport function findIndex<A>(predicate: Predicate<A>): (fa: List<A>) => O.Option<number> {\n  return fa => {\n    let l: List<A> = fa\n    let i = 0\n    while (isCons(l)) {\n      if (predicate(l.head)) return O.some(i)\n      l = l.tail\n      i++\n    }\n    return O.none\n  }\n}",
    "docs": "/**\n * Finds the first index for which a predicate holds.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const f = (a: number): boolean => a % 2 === 0\n * const findIndexEven = L.findIndex(f)\n * assert.deepStrictEqual(findIndexEven(L.nil), O.none)\n * assert.deepStrictEqual(findIndexEven(L.cons(1, L.of(2))), O.some(1))\n * assert.deepStrictEqual(findIndexEven(L.of(1)), O.none)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 184,
        "to": 195
      }
    }
  },
  {
    "name": "reverse",
    "text": "\n\n/**\n * Reverse a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))\n *\n * @since 0.1.8\n */\nexport function reverse<A>(fa: List<A>): List<A> {\n  let out: List<A> = nil\n  let l = fa\n  while (isCons(l)) {\n    out = cons(l.head, out)\n    l = l.tail\n  }\n  return out\n}",
    "docs": "/**\n * Reverse a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.reverse(L.cons(1, L.cons(2, L.of(3)))), L.cons(3, L.cons(2, L.of(1))))\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 207,
        "to": 215
      }
    }
  },
  {
    "name": "dropLeft",
    "text": "\n\n/**\n * Drops the specified number of elements from the front of a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))\n * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */\nexport function dropLeft(n: number): <A>(fa: List<A>) => List<A> {\n  return <A>(fa: List<A>) => {\n    if (isNil(fa)) return nil\n\n    let i = 0\n    let l: List<A> = fa\n    while (isCons(l) && i < n) {\n      i++\n      l = l.tail\n    }\n    return l\n  }\n}",
    "docs": "/**\n * Drops the specified number of elements from the front of a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.dropLeft(1)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeft(1)(L.cons(1, L.of(2))), L.of(2))\n * assert.deepStrictEqual(L.dropLeft(3)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 229,
        "to": 241
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\n\n/**\n * Drops those elements from the front of a list which match a predicate.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const isLTThree = (n: number) => n < 3\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.cons(2, L.of(3)))), L.of(3))\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */\nexport function dropLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (fa: List<A>) => List<B>",
    "docs": "/**\n * Drops those elements from the front of a list which match a predicate.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const isLTThree = (n: number) => n < 3\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.cons(2, L.of(3)))), L.of(3))\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 256,
        "to": 256
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\nexport function dropLeftWhile<A>(predicate: Predicate<A>): (fa: List<A>) => List<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 257,
        "to": 257
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\nexport function dropLeftWhile<A>(predicate: Predicate<A>): (fa: List<A>) => List<A> {\n  return fa => {\n    if (isNil(fa)) return nil\n\n    let l: List<A> = fa\n    while (isCons(l) && predicate(l.head)) {\n      l = l.tail\n    }\n    return l\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 258,
        "to": 268
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * Gets an array from a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])\n *\n * @since 0.1.8\n */\nexport function toArray<A>(fa: List<A>): Array<A> {\n  const length = fa.length\n  const out: Array<A> = new Array(length)\n  let l: List<A> = fa\n  for (let i = 0; i < length; i++) {\n    out[i] = (l as Cons<A>).head\n    l = (l as Cons<A>).tail\n  }\n  return out\n}",
    "docs": "/**\n * Gets an array from a list.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.toArray(L.cons('a', L.of('b'))), ['a', 'b'])\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 280,
        "to": 289
      }
    }
  },
  {
    "name": "toReversedArray",
    "text": "\n\n/**\n * Gets an array from a list in a reversed order.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])\n *\n * @since 0.1.8\n */\nexport function toReversedArray<A>(fa: List<A>): Array<A> {\n  const length = fa.length\n  const out: Array<A> = new Array(length)\n  let l: List<A> = fa\n  for (let i = 0; i < length; i++) {\n    out[length - i - 1] = (l as Cons<A>).head\n    l = (l as Cons<A>).tail\n  }\n  return out\n}",
    "docs": "/**\n * Gets an array from a list in a reversed order.\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.toReversedArray(L.cons('a', L.of('b'))), ['b', 'a'])\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 301,
        "to": 310
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * Creates a list from an array\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.fromArray([]), L.nil)\n * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))\n *\n * @since 0.1.8\n */\nexport function fromArray<A>(as: Array<A>): List<A> {\n  return A.array.reduceRight<A, List<A>>(as, nil, cons)\n}",
    "docs": "/**\n * Creates a list from an array\n *\n * @example\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * assert.deepStrictEqual(L.fromArray([]), L.nil)\n * assert.deepStrictEqual(L.fromArray(['a', 'b']), L.cons('a', L.of('b')))\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 323,
        "to": 325
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.\n * The derived `Eq` defines two lists as equal if all elements of both lists\n * are compared equal pairwise with the given `E`. In case of lists of different\n * lengths, the result is non equality.\n *\n * @example\n * import { eqString } from 'fp-ts/lib/Eq'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const E = L.getEq(eqString)\n * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)\n * assert.strictEqual(E.equals(L.of('x'), L.nil), false)\n *\n * @since 0.1.8\n */\nexport function getEq<A>(E: Eq.Eq<A>): Eq.Eq<List<A>> {\n  return {\n    equals: (x, y) => {\n      if (x.length !== y.length) return false\n      let lx = x\n      let ly = y\n      while (isCons(lx) && isCons(ly)) {\n        if (!E.equals(lx.head, ly.head)) return false\n        lx = lx.tail\n        ly = ly.tail\n      }\n      return true\n    }\n  }\n}",
    "docs": "/**\n * Derives an `Eq` over the `List` of a given element type from the `Eq` of that type.\n * The derived `Eq` defines two lists as equal if all elements of both lists\n * are compared equal pairwise with the given `E`. In case of lists of different\n * lengths, the result is non equality.\n *\n * @example\n * import { eqString } from 'fp-ts/lib/Eq'\n * import * as L from 'fp-ts-contrib/lib/List'\n *\n * const E = L.getEq(eqString)\n * assert.strictEqual(E.equals(L.cons('a', L.of('b')), L.cons('a', L.of('b'))), true)\n * assert.strictEqual(E.equals(L.of('x'), L.nil), false)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 343,
        "to": 357
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function run<R, A>(ma: ReaderIO<R, A>, r: R): A {\n  return ma(r)()\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 40,
        "to": 42
      }
    }
  },
  {
    "name": "local",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function local<Q, R>(f: (f: Q) => R): <A>(ma: ReaderIO<R, A>) => ReaderIO<Q, A> {\n  return ma => T.local(ma, f)\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(f: Q) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<Q, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromIOK<A extends Array<unknown>, B>(f: (...a: A) => IO<B>): <R>(...a: A) => ReaderIO<R, B> {\n  return (...a) => fromIO(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 74,
        "to": 76
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainIOK<A, B>(f: (a: A) => IO<B>): <R>(ma: ReaderIO<R, A>) => ReaderIO<R, B> {\n  return chain<any, A, B>(fromIOK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 81,
        "to": 83
      }
    }
  },
  {
    "name": "match",
    "text": "\n\n/**\n * Returns the list of subexpression matches, or `None` if the match fails.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import { match } from 'fp-ts-contrib/lib/RegExp'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const myMatch = match(/^(\\d)(\\w)$/)\n * assert.deepStrictEqual(pipe('2e', myMatch, O.map(Array.from)), O.some(['2e', '2', 'e']))\n * assert.deepStrictEqual(myMatch('foo'), O.none)\n *\n * @since 0.1.8\n */\nexport function match(r: RegExp): (s: string) => O.Option<RegExpMatchArray> {\n  return s => O.fromNullable(s.match(r))\n}",
    "docs": "/**\n * Returns the list of subexpression matches, or `None` if the match fails.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import { match } from 'fp-ts-contrib/lib/RegExp'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const myMatch = match(/^(\\d)(\\w)$/)\n * assert.deepStrictEqual(pipe('2e', myMatch, O.map(Array.from)), O.some(['2e', '2', 'e']))\n * assert.deepStrictEqual(myMatch('foo'), O.none)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 27,
        "to": 29
      }
    }
  },
  {
    "name": "test",
    "text": "\n\n/**\n * Returns `true` if the string matches the regular expression,\n * otherwise `false`.\n *\n * @example\n * import { test } from 'fp-ts-contrib/lib/RegExp'\n *\n * const myTest = test(/^(\\d)(\\w)$/)\n * assert.strictEqual(myTest('6s'), true)\n * assert.strictEqual(myTest('bar'), false)\n *\n * @since 0.1.8\n */\nexport function test(r: RegExp): Predicate<string> {\n  return s => r.test(s)\n}",
    "docs": "/**\n * Returns `true` if the string matches the regular expression,\n * otherwise `false`.\n *\n * @example\n * import { test } from 'fp-ts-contrib/lib/RegExp'\n *\n * const myTest = test(/^(\\d)(\\w)$/)\n * assert.strictEqual(myTest('6s'), true)\n * assert.strictEqual(myTest('bar'), false)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 44,
        "to": 46
      }
    }
  },
  {
    "name": "sub",
    "text": "\n\n/**\n * Replaces every occurance of the given regular expression\n * with the replacement string.\n *\n * @example\n * import { sub } from 'fp-ts-contrib/lib/RegExp'\n *\n * const sanitiseSpaces = sub(/\\s/g, '_')\n * assert.strictEqual(sanitiseSpaces('foo bar owl'), 'foo_bar_owl')\n *\n * @since 0.1.8\n */\nexport function sub(r: RegExp, replacement: string): (s: string) => string {\n  return s => s.replace(r, replacement)\n}",
    "docs": "/**\n * Replaces every occurance of the given regular expression\n * with the replacement string.\n *\n * @example\n * import { sub } from 'fp-ts-contrib/lib/RegExp'\n *\n * const sanitiseSpaces = sub(/\\s/g, '_')\n * assert.strictEqual(sanitiseSpaces('foo bar owl'), 'foo_bar_owl')\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        },
        {
          "name": "replacement",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => string"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "split",
    "text": "\n\n/**\n * Splits a string based on a regular expression. The regular expression\n * should identify one delimiter.\n *\n * @example\n * import { split } from 'fp-ts-contrib/lib/RegExp'\n *\n * const splitByHash = split(/#/)\n * assert.deepStrictEqual(splitByHash('foo#bar#beer'), ['foo', 'bar', 'beer'])\n * assert.deepStrictEqual(splitByHash('noHashes'), ['noHashes'])\n *\n * @since 0.1.8\n */\nexport function split(r: RegExp): (s: string) => NonEmptyArray<string> {\n  return s => s.split(r) as any\n}",
    "docs": "/**\n * Splits a string based on a regular expression. The regular expression\n * should identify one delimiter.\n *\n * @example\n * import { split } from 'fp-ts-contrib/lib/RegExp'\n *\n * const splitByHash = split(/#/)\n * assert.deepStrictEqual(splitByHash('foo#bar#beer'), ['foo', 'bar', 'beer'])\n * assert.deepStrictEqual(splitByHash('noHashes'), ['noHashes'])\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 77,
        "to": 79
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 0.1.12\n */\nexport function left<S, E, A = never>(e: E): StateEither<S, E, A> {\n  return fromEither(E.left(e))\n}",
    "docs": "/**\n * @since 0.1.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 49,
        "to": 51
      }
    }
  },
  {
    "name": "leftState",
    "text": "\n\n/**\n * @since 0.1.12\n */\nexport function leftState<S, E = never, A = never>(me: State<S, E>): StateEither<S, E, A> {\n  return s => E.left(me(s)[0])\n}",
    "docs": "/**\n * @since 0.1.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @since 0.1.12\n */\nexport function fromEitherK<E, A extends Array<unknown>, B>(\n  f: (...a: A) => E.Either<E, B>\n): <S>(...a: A) => StateEither<S, E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @since 0.1.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 98,
        "to": 102
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\n\n/**\n * @since 0.1.12\n */\nexport function chainEitherK<E, A, B>(\n  f: (a: A) => E.Either<E, B>\n): <S>(ma: StateEither<S, E, A>) => StateEither<S, E, B> {\n  return chain<any, E, A, B>(fromEitherK(f))\n}",
    "docs": "/**\n * @since 0.1.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 107,
        "to": 111
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function run<S, A>(ma: StateIO<S, A>, s: S): A {\n  return ma(s)()[0]\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 39,
        "to": 41
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromIOK<A extends Array<unknown>, B>(f: (...a: A) => IO<B>): <R>(...a: A) => StateIO<R, B> {\n  return (...a) => fromIO(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainIOK<A, B>(f: (a: A) => IO<B>): <R>(ma: StateIO<R, A>) => StateIO<R, B> {\n  return chain<any, A, B>(fromIOK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function run<S, E, A>(ma: StateTaskEither<S, E, A>, s: S): Promise<Either<E, [A, S]>> {\n  return ma(s)()\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 44,
        "to": 46
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function left<S, E>(e: E): StateTaskEither<S, E, never> {\n  return fromTaskEither(TE.left(e))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function rightTask<S, A>(ma: Task<A>): StateTaskEither<S, never, A> {\n  return fromTaskEither(TE.rightTask(ma))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, never, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 73,
        "to": 75
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function leftTask<S, E>(me: Task<E>): StateTaskEither<S, E, never> {\n  return fromTaskEither(TE.leftTask(me))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function fromIOEither<S, E, A>(ma: IOEither<E, A>): StateTaskEither<S, E, A> {\n  return fromTaskEither(TE.fromIOEither(ma))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function rightIO<S, A>(ma: IO<A>): StateTaskEither<S, never, A> {\n  return fromTaskEither(TE.rightIO(ma))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, never, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function leftIO<S, E>(me: IO<E>): StateTaskEither<S, E, never> {\n  return fromTaskEither(TE.leftIO(me))\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "leftState",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function leftState<S, E>(me: State<S, E>): StateTaskEither<S, E, never> {\n  return s => TE.left(me(s)[0])\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 118,
        "to": 120
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromEitherK<E, A extends Array<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): <S>(...a: A) => StateTaskEither<S, E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 145,
        "to": 149
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainEitherK<E, A, B>(\n  f: (a: A) => Either<E, B>\n): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B> {\n  return chain<any, E, A, B>(fromEitherK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 154,
        "to": 158
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromIOEitherK<E, A extends Array<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): <S>(...a: A) => StateTaskEither<S, E, B> {\n  return (...a) => fromIOEither(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 163,
        "to": 167
      }
    }
  },
  {
    "name": "chainIOEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainIOEitherK<E, A, B>(\n  f: (a: A) => IOEither<E, B>\n): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B> {\n  return chain<any, E, A, B>(fromIOEitherK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 172,
        "to": 176
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromTaskEitherK<E, A extends Array<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n): <S>(...a: A) => StateTaskEither<S, E, B> {\n  return (...a) => fromTaskEither(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 181,
        "to": 185
      }
    }
  },
  {
    "name": "chainTaskEitherK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainTaskEitherK<E, A, B>(\n  f: (a: A) => TaskEither<E, B>\n): <S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B> {\n  return chain<any, E, A, B>(fromTaskEitherK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 190,
        "to": 194
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function fold<A, B>(onNone: () => Task<B>, onSome: (a: A) => Task<B>): (as: TaskOption<A>) => Task<B> {\n  return as => T.fold(as, onNone, onSome)\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function getOrElse<A>(onNone: () => Task<A>): (as: TaskOption<A>) => Task<A> {\n  return as => T.getOrElse(as, onNone)\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function fromNullable<A>(a: A): TaskOption<NonNullable<A>> {\n  return fromOption(optionFromNullable(a))\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<NonNullable<A>>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function fromTaskEither<A>(ma: TaskEither<any, A>): TaskOption<A> {\n  return task.map(ma, optionFromEither)\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "toUndefined",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function toUndefined<A>(ma: TaskOption<A>): Task<A | undefined> {\n  return task.map(ma, optionToUndefined)\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "toNullable",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function toNullable<A>(ma: TaskOption<A>): Task<A | null> {\n  return task.map(ma, optionToNullable)\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "chainTask",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function chainTask<A, B>(f: (a: A) => Task<B>): (ma: TaskOption<A>) => TaskOption<B> {\n  return ma => T.chain(ma, a => fromTask(f(a)))\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 113,
        "to": 115
      }
    }
  },
  {
    "name": "chainOption",
    "text": "\n\n/**\n * @since 0.1.4\n */\nexport function chainOption<A, B>(f: (a: A) => Option<B>): (ma: TaskOption<A>) => TaskOption<B> {\n  return taskMap(optionChain(f))\n}",
    "docs": "/**\n * @since 0.1.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 120,
        "to": 122
      }
    }
  },
  {
    "name": "mapNullable",
    "text": "\n\n/**\n * @since 0.1.5\n */\nexport function mapNullable<A, B>(f: (a: A) => B | null | undefined): (ma: TaskOption<A>) => TaskOption<B> {\n  return taskMap(optionMapNullable(f))\n}",
    "docs": "/**\n * @since 0.1.5\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 127,
        "to": 129
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * @since 0.1.5\n */\nexport function tryCatch<A>(f: Lazy<Promise<A>>): TaskOption<A> {\n  return () =>\n    f().then(\n      a => optionSome(a),\n      () => optionNone\n    )\n}",
    "docs": "/**\n * @since 0.1.5\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 134,
        "to": 140
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function fromOptionK<A extends Array<unknown>, B>(f: (...a: A) => Option<B>): (...a: A) => TaskOption<B> {\n  return (...a) => fromOption(f(...a))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 145,
        "to": 147
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\n\n/**\n * @since 0.1.10\n */\nexport function chainOptionK<A, B>(f: (a: A) => Option<B>): (ma: TaskOption<A>) => TaskOption<B> {\n  return chain(fromOptionK(f))\n}",
    "docs": "/**\n * @since 0.1.10\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 152,
        "to": 154
      }
    }
  },
  {
    "name": "time",
    "text": "\n\n/**\n * Mimics the analogous Unix command: given an action `HKT<M, A>`, we can derive an action `HKT<M, [A, number]>` that\n * returns the elapsed time along with the computed value\n *\n * @example\n * import { io } from 'fp-ts/lib/IO'\n * import { randomInt } from 'fp-ts/lib/Random'\n * import { time } from 'fp-ts-contrib/lib/time'\n *\n * const timeIO = time(io)\n *\n * function fib(n: number): number {\n *   return n <= 1 ? 1 : fib(n - 1) + fib(n - 2)\n * }\n *\n * timeIO(io.map(randomInt(30, 35), fib))() // [ 14930352, 127 ]\n *\n * @since 0.1.0\n */\nexport function time<M extends URIS3>(M: MonadIO3<M>): <R, E, A>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, [A, number]>",
    "docs": "/**\n * Mimics the analogous Unix command: given an action `HKT<M, A>`, we can derive an action `HKT<M, [A, number]>` that\n * returns the elapsed time along with the computed value\n *\n * @example\n * import { io } from 'fp-ts/lib/IO'\n * import { randomInt } from 'fp-ts/lib/Random'\n * import { time } from 'fp-ts-contrib/lib/time'\n *\n * const timeIO = time(io)\n *\n * function fib(n: number): number {\n *   return n <= 1 ? 1 : fib(n - 1) + fib(n - 2)\n * }\n *\n * timeIO(io.map(randomInt(30, 35), fib))() // [ 14930352, 127 ]\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 27,
        "to": 27
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS2>(M: MonadIO2<M>): <E, A>(ma: Kind2<M, E, A>) => Kind2<M, E, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 28,
        "to": 28
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS2, E>(M: MonadIO2C<M, E>): <A>(ma: Kind2<M, E, A>) => Kind2<M, E, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 29,
        "to": 29
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS>(M: MonadIO1<M>): <A>(ma: Kind<M, A>) => Kind<M, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 30,
        "to": 30
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M>(M: MonadIO<M>): <A>(ma: HKT<M, A>) => HKT<M, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 31,
        "to": 31
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M>(M: MonadIO<M>): <A>(ma: HKT<M, A>) => HKT<M, [A, number]> {\n  const nowM = M.fromIO(now)\n  return ma => M.chain(nowM, start => M.chain(ma, a => M.map(nowM, end => [a, end - start])))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 32,
        "to": 35
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n/**\n * Creates a new zipper.\n * @since 0.1.6\n */\nexport function make<A>(lefts: Array<A>, focus: A, rights: Array<A>): Zipper<A> {\n  return { lefts, focus, rights }\n}",
    "docs": "/**\n * Creates a new zipper.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "lefts",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "focus",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "rights",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 58,
        "to": 60
      }
    }
  },
  {
    "name": "length",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function length<A>(fa: Zipper<A>): number {\n  return fa.lefts.length + 1 + fa.rights.length\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 65,
        "to": 67
      }
    }
  },
  {
    "name": "update",
    "text": "\n\n/**\n * Updates the focus of the zipper.\n * @since 0.1.6\n */\nexport function update<A>(a: A): (fa: Zipper<A>) => Zipper<A> {\n  return fa => make(fa.lefts, a, fa.rights)\n}",
    "docs": "/**\n * Updates the focus of the zipper.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 73,
        "to": 75
      }
    }
  },
  {
    "name": "modify",
    "text": "\n\n/**\n * Applies `f` to the focus and update with the result.\n * @since 0.1.6\n */\nexport function modify<A>(f: (a: A) => A): (fa: Zipper<A>) => Zipper<A> {\n  return fa => pipe(fa, update(f(fa.focus)))\n}",
    "docs": "/**\n * Applies `f` to the focus and update with the result.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 81,
        "to": 83
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function toArray<A>(fa: Zipper<A>): Array<A> {\n  return A.snoc(fa.lefts, fa.focus).concat(fa.rights)\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 88,
        "to": 90
      }
    }
  },
  {
    "name": "isOutOfBound",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function isOutOfBound<A>(index: number, fa: Zipper<A>): boolean {\n  return index < 0 || index >= length(fa)\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "index",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "move",
    "text": "\n\n/**\n * Moves focus in the zipper, or `None` if there is no such element.\n * @since 0.1.6\n */\nexport function move<A>(f: (currentIndex: number) => number, fa: Zipper<A>): Option<Zipper<A>> {\n  const newIndex = f(fa.lefts.length)\n  if (isOutOfBound(newIndex, fa)) {\n    return none\n  } else {\n    return fromArray(toArray(fa), newIndex)\n  }\n}",
    "docs": "/**\n * Moves focus in the zipper, or `None` if there is no such element.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(currentIndex: number) => number"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 103,
        "to": 110
      }
    }
  },
  {
    "name": "up",
    "text": "\n\n/**\n * Moves focus of the zipper up.\n * @since 0.1.6\n */\nexport function up<A>(fa: Zipper<A>): Option<Zipper<A>> {\n  return move(decrement, fa)\n}",
    "docs": "/**\n * Moves focus of the zipper up.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "down",
    "text": "\n\n/**\n * Moves focus of the zipper down.\n * @since 0.1.6\n */\nexport function down<A>(fa: Zipper<A>): Option<Zipper<A>> {\n  return move(increment, fa)\n}",
    "docs": "/**\n * Moves focus of the zipper down.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 124,
        "to": 126
      }
    }
  },
  {
    "name": "start",
    "text": "\n\n/**\n * Moves focus to the start of the zipper.\n * @since 0.1.6\n */\nexport function start<A>(fa: Zipper<A>): Zipper<A> {\n  if (A.isEmpty(fa.lefts)) {\n    return fa\n  } else {\n    return make(A.empty, fa.lefts[0], A.snoc(pipe(fa.lefts, A.dropLeft(1)), fa.focus).concat(fa.rights))\n  }\n}",
    "docs": "/**\n * Moves focus to the start of the zipper.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 132,
        "to": 138
      }
    }
  },
  {
    "name": "end",
    "text": "\n\n/**\n * Moves focus to the end of the zipper.\n * @since 0.1.6\n */\nexport function end<A>(fa: Zipper<A>): Zipper<A> {\n  const len = fa.rights.length\n  if (len === 0) {\n    return fa\n  } else {\n    return make(A.snoc(fa.lefts, fa.focus).concat(pipe(fa.rights, A.takeLeft(len - 1))), fa.rights[len - 1], A.empty)\n  }\n}",
    "docs": "/**\n * Moves focus to the end of the zipper.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 144,
        "to": 151
      }
    }
  },
  {
    "name": "insertLeft",
    "text": "\n\n/**\n * Inserts an element to the left of the focus and focuses on the new element.\n * @since 0.1.6\n */\nexport function insertLeft<A>(a: A): (fa: Zipper<A>) => Zipper<A> {\n  return fa => make(fa.lefts, a, A.cons(fa.focus, fa.rights))\n}",
    "docs": "/**\n * Inserts an element to the left of the focus and focuses on the new element.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "insertRight",
    "text": "\n\n/**\n * Inserts an element to the right of the focus and focuses on the new element.\n * @since 0.1.6\n */\nexport function insertRight<A>(a: A): (fa: Zipper<A>) => Zipper<A> {\n  return fa => make(A.snoc(fa.lefts, fa.focus), a, fa.rights)\n}",
    "docs": "/**\n * Inserts an element to the right of the focus and focuses on the new element.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 165,
        "to": 167
      }
    }
  },
  {
    "name": "deleteLeft",
    "text": "\n\n/**\n * Deletes the element at focus and moves the focus to the left. If there is no element on the left,\n * the focus is moved to the right.\n * @since 0.1.6\n */\nexport function deleteLeft<A>(fa: Zipper<A>): Option<Zipper<A>> {\n  const len = fa.lefts.length\n  return fromArray(fa.lefts.concat(fa.rights), len > 0 ? len - 1 : 0)\n}",
    "docs": "/**\n * Deletes the element at focus and moves the focus to the left. If there is no element on the left,\n * the focus is moved to the right.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 174,
        "to": 177
      }
    }
  },
  {
    "name": "deleteRight",
    "text": "\n\n/**\n * Deletes the element at focus and moves the focus to the right. If there is no element on the right,\n * the focus is moved to the left.\n * @since 0.1.6\n */\nexport function deleteRight<A>(fa: Zipper<A>): Option<Zipper<A>> {\n  const lenl = fa.lefts.length\n  const lenr = fa.rights.length\n  return fromArray(fa.lefts.concat(fa.rights), lenr > 0 ? lenl : lenl - 1)\n}",
    "docs": "/**\n * Deletes the element at focus and moves the focus to the right. If there is no element on the right,\n * the focus is moved to the left.\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 184,
        "to": 188
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function getShow<A>(S: Show<A>): Show<Zipper<A>> {\n  const SA = A.getShow(S)\n  return {\n    show: fa => `Zipper(${SA.show(fa.lefts)}, ${S.show(fa.focus)}, ${SA.show(fa.rights)})`\n  }\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 193,
        "to": 198
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function fromArray<A>(as: Array<A>, focusIndex: number = 0): Option<Zipper<A>> {\n  if (A.isEmpty(as) || A.isOutOfBound(focusIndex, as)) {\n    return none\n  } else {\n    return some(make(pipe(as, A.takeLeft(focusIndex)), as[focusIndex], pipe(as, A.dropLeft(focusIndex + 1))))\n  }\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "focusIndex",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 203,
        "to": 209
      }
    }
  },
  {
    "name": "fromNonEmptyArray",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function fromNonEmptyArray<A>(nea: NonEmptyArray<A>): Zipper<A> {\n  return make(A.empty, nea[0], nea.slice(1))\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 214,
        "to": 216
      }
    }
  },
  {
    "name": "of",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function of<A>(focus: A): Zipper<A> {\n  return make(A.empty, focus, A.empty)\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "focus",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 221,
        "to": 223
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function getSemigroup<A>(S: Semigroup<A>): Semigroup<Zipper<A>> {\n  return {\n    concat: (x, y) => make(x.lefts.concat(y.lefts), S.concat(x.focus, y.focus), x.rights.concat(y.rights))\n  }\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 252,
        "to": 256
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * @since 0.1.6\n */\nexport function getMonoid<A>(M: Monoid<A>): Monoid<Zipper<A>> {\n  return {\n    ...getSemigroup(M),\n    empty: make(A.empty, M.empty, A.empty)\n  }\n}",
    "docs": "/**\n * @since 0.1.6\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 261,
        "to": 266
      }
    }
  },
  {
    "name": "repro38",
    "text": " // $ExpectType () => Task<{ a: string; b: number; }>\n\n// issue #38\n\nexport function repro38<F extends URIS>(\n  F: Monad1<F> & {\n    f: Kind<F, void>\n  }\n) {\n  Do(F).do(F.f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 76,
        "to": 82
      }
    }
  },
  {
    "name": "lpadZipWith",
    "text": "\n\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the\n * left input array is short, it will be padded using `none`.\n *\n * It is similar to `zipWith`, but it doesn't discard elements when the left input array is shorter than the right.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import { lpadZipWith } from 'fp-ts-contrib/lib/Align/Array'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const f = (ma: O.Option<number>, b: string) =>\n *   pipe(\n *     ma,\n *     O.fold(() => '*', a => a.toString())\n *   ) + b\n * assert.deepStrictEqual(lpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c', '*d'])\n * assert.deepStrictEqual(lpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c'])\n *\n * @since 0.1.0\n */\nexport function lpadZipWith<A, B, C>(xs: Array<A>, ys: Array<B>, f: (a: Option<A>, b: B) => C): Array<C> {\n  return array.compact(padZipWith(alignArray)(xs, ys, (ma, mb) => option.map(mb, b => f(ma, b))))\n}",
    "docs": "/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the\n * left input array is short, it will be padded using `none`.\n *\n * It is similar to `zipWith`, but it doesn't discard elements when the left input array is shorter than the right.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import { lpadZipWith } from 'fp-ts-contrib/lib/Align/Array'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const f = (ma: O.Option<number>, b: string) =>\n *   pipe(\n *     ma,\n *     O.fold(() => '*', a => a.toString())\n *   ) + b\n * assert.deepStrictEqual(lpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c', '*d'])\n * assert.deepStrictEqual(lpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c'])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: any, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "lpadZip",
    "text": "\n\n/**\n * Takes two arrays and returns an array of corresponding pairs. If the left input array is short, it will be\n * padded using `none`.\n *\n * It is similar to `zip`, but it doesn't discard elements when the left input array is shorter than the right.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { lpadZip } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(lpadZip([1, 2], ['a', 'b', 'c']), [[some(1), 'a'], [some(2), 'b'], [none, 'c']])\n * assert.deepStrictEqual(lpadZip([1, 2, 3], ['a', 'b']), [[some(1), 'a'], [some(2), 'b']])\n *\n * @since 0.1.0\n */\nexport function lpadZip<A, B>(xs: Array<A>, ys: Array<B>): Array<[Option<A>, B]> {\n  return lpadZipWith(xs, ys, (a, b) => tuple(a, b))\n}",
    "docs": "/**\n * Takes two arrays and returns an array of corresponding pairs. If the left input array is short, it will be\n * padded using `none`.\n *\n * It is similar to `zip`, but it doesn't discard elements when the left input array is shorter than the right.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { lpadZip } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(lpadZip([1, 2], ['a', 'b', 'c']), [[some(1), 'a'], [some(2), 'b'], [none, 'c']])\n * assert.deepStrictEqual(lpadZip([1, 2, 3], ['a', 'b']), [[some(1), 'a'], [some(2), 'b']])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[any, B][]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 118,
        "to": 120
      }
    }
  },
  {
    "name": "rpadZipWith",
    "text": "\n\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the\n * right input array is short, it will be padded using `none`.\n *\n * It is similar to `zipWith`, but it doesn't discard elements when the right input array is shorter than the left.\n *\n * @example\n * import { Option, getOrElse } from 'fp-ts/lib/Option'\n * import { rpadZipWith } from 'fp-ts-contrib/lib/Align/Array'\n *\n * const f = (a: number, mb: Option<string>) => a.toString() + getOrElse(() => '*')(mb)\n * assert.deepStrictEqual(rpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c', '4*'])\n * assert.deepStrictEqual(rpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c'])\n *\n * @since 0.1.0\n */\nexport function rpadZipWith<A, B, C>(xs: Array<A>, ys: Array<B>, f: (a: A, b: Option<B>) => C): Array<C> {\n  return lpadZipWith(ys, xs, (a, b) => f(b, a))\n}",
    "docs": "/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If the\n * right input array is short, it will be padded using `none`.\n *\n * It is similar to `zipWith`, but it doesn't discard elements when the right input array is shorter than the left.\n *\n * @example\n * import { Option, getOrElse } from 'fp-ts/lib/Option'\n * import { rpadZipWith } from 'fp-ts-contrib/lib/Align/Array'\n *\n * const f = (a: number, mb: Option<string>) => a.toString() + getOrElse(() => '*')(mb)\n * assert.deepStrictEqual(rpadZipWith([1, 2, 3, 4], ['a', 'b', 'c'], f), ['1a', '2b', '3c', '4*'])\n * assert.deepStrictEqual(rpadZipWith([1, 2, 3], ['a', 'b', 'c', 'd'], f), ['1a', '2b', '3c'])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 138,
        "to": 140
      }
    }
  },
  {
    "name": "rpadZip",
    "text": "\n\n/**\n * Takes two arrays and returns an array of corresponding pairs. If the right input array is short, it will be\n * padded using `none`.\n *\n * It is similar to `zip`, but it doesn't discard elements when the right input array is shorter than the left.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { rpadZip } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(rpadZip([1, 2, 3], ['a', 'b']), [[1, some('a')], [2, some('b')], [3, none]])\n * assert.deepStrictEqual(rpadZip([1, 2], ['a', 'b', 'c']), [[1, some('a')], [2, some('b')]])\n *\n * @since 0.1.0\n */\nexport function rpadZip<A, B>(xs: Array<A>, ys: Array<B>): Array<[A, Option<B>]> {\n  return rpadZipWith(xs, ys, (a, b) => tuple(a, b))\n}",
    "docs": "/**\n * Takes two arrays and returns an array of corresponding pairs. If the right input array is short, it will be\n * padded using `none`.\n *\n * It is similar to `zip`, but it doesn't discard elements when the right input array is shorter than the left.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { rpadZip } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(rpadZip([1, 2, 3], ['a', 'b']), [[1, some('a')], [2, some('b')], [3, none]])\n * assert.deepStrictEqual(rpadZip([1, 2], ['a', 'b', 'c']), [[1, some('a')], [2, some('b')]])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A, any][]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "salign",
    "text": "\n\n/**\n * Align two structures, using a semigroup for combining values.\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { salign } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(salign(alignArray, semigroupSum)([1, 2, 3], [4, 5]), [5, 7, 3])\n *\n * @since 0.1.0\n */\nexport function salign<F extends URIS3, A, L>(\n  F: Align3<F>,\n  S: Semigroup<A>\n): <U, L>(fx: Kind3<F, U, L, A>, fy: Kind3<F, U, L, A>) => Kind3<F, U, L, A>",
    "docs": "/**\n * Align two structures, using a semigroup for combining values.\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { salign } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(salign(alignArray, semigroupSum)([1, 2, 3], [4, 5]), [5, 7, 3])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L>(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 69,
        "to": 72
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS2, A>(\n  F: Align2<F>,\n  S: Semigroup<A>\n): <L>(fx: Kind2<F, L, A>, fy: Kind2<F, L, A>) => Kind2<F, L, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L>(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 73,
        "to": 76
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS2, A, L>(\n  F: Align2C<F, L>,\n  S: Semigroup<A>\n): (fx: Kind2<F, L, A>, fy: Kind2<F, L, A>) => Kind2<F, L, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 77,
        "to": 80
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS, A>(F: Align1<F>, S: Semigroup<A>): (fx: Kind<F, A>, fy: Kind<F, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 81,
        "to": 81
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F, A>(F: Align<F>, S: Semigroup<A>): (fx: HKT<F, A>, fy: HKT<F, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 82,
        "to": 82
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F, A>(F: Align<F>, S: Semigroup<A>): (fx: HKT<F, A>, fy: HKT<F, A>) => HKT<F, A> {\n  return (fx, fy) => F.alignWith(fx, fy, fold(identity, identity, S.concat))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 83,
        "to": 85
      }
    }
  },
  {
    "name": "padZip",
    "text": "\n\n/**\n * Align two structures, using `none` to fill blanks.\n *\n * It is similar to `zip`, but it doesn't discard elements.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { padZip } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(padZip(alignArray)([1, 2, 3], [4, 5]), [[some(1), some(4)], [some(2), some(5)], [some(3), none]])\n *\n * @since 0.1.0\n */\nexport function padZip<F extends URIS3, L>(\n  F: Align3<F>\n): <U, L, A, B>(fa: Kind3<F, U, L, A>, fb: Kind3<F, U, L, B>) => Kind3<F, U, L, [Option<A>, Option<B>]>",
    "docs": "/**\n * Align two structures, using `none` to fill blanks.\n *\n * It is similar to `zip`, but it doesn't discard elements.\n *\n * @example\n * import { some, none } from 'fp-ts/lib/Option'\n * import { padZip } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n *\n * assert.deepStrictEqual(padZip(alignArray)([1, 2, 3], [4, 5]), [[some(1), some(4)], [some(2), some(5)], [some(3), none]])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS2>(\n  F: Align2<F>\n): <L, A, B>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>) => Kind2<F, L, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 104,
        "to": 106
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS2, L>(\n  F: Align2C<F, L>\n): <A, B>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>) => Kind2<F, L, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS>(\n  F: Align1<F>\n): <A, B>(fa: Kind<F, A>, fb: Kind<F, B>) => Kind<F, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F>(F: Align<F>): <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => HKT<F, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 113,
        "to": 113
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F>(F: Align<F>): <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => HKT<F, [Option<A>, Option<B>]> {\n  return (fa, fb) => padZipWith(F)(fa, fb, (a, b) => tuple(a, b))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 114,
        "to": 116
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\n\n/**\n * Align two structures by applying a function to each pair of aligned elements, using `none` to fill blanks.\n *\n * It is similar to `zipWith`, but it doesn't discard elements.\n *\n * @example\n * import { Option, fold, getOrElse } from 'fp-ts/lib/Option'\n * import { padZipWith } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const f = (ma: Option<number>, mb: Option<string>) =>\n *   pipe(\n *     ma,\n *     fold(() => '*', a => a.toString())\n *   ) +\n *   pipe(\n *     mb,\n *     getOrElse(() => '#')\n *   )\n *\n * assert.deepStrictEqual(padZipWith(alignArray)([1, 2], ['a'], f), ['1a', '2#'])\n * assert.deepStrictEqual(padZipWith(alignArray)([1], ['a', 'b'], f), ['1a', '*b'])\n *\n * @since 0.1.0\n */\nexport function padZipWith<F extends URIS3, L>(\n  F: Align3<F>\n): <U, L, A, B, C>(\n  fa: Kind3<F, U, L, A>,\n  fb: Kind3<F, U, L, B>,\n  f: (a: Option<A>, b: Option<B>) => C\n) => Kind3<F, U, L, C>",
    "docs": "/**\n * Align two structures by applying a function to each pair of aligned elements, using `none` to fill blanks.\n *\n * It is similar to `zipWith`, but it doesn't discard elements.\n *\n * @example\n * import { Option, fold, getOrElse } from 'fp-ts/lib/Option'\n * import { padZipWith } from 'fp-ts-contrib/lib/Align'\n * import { alignArray } from 'fp-ts-contrib/lib/Align/Array'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * const f = (ma: Option<number>, mb: Option<string>) =>\n *   pipe(\n *     ma,\n *     fold(() => '*', a => a.toString())\n *   ) +\n *   pipe(\n *     mb,\n *     getOrElse(() => '#')\n *   )\n *\n * assert.deepStrictEqual(padZipWith(alignArray)([1, 2], ['a'], f), ['1a', '2#'])\n * assert.deepStrictEqual(padZipWith(alignArray)([1], ['a', 'b'], f), ['1a', '*b'])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 144,
        "to": 150
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS2>(\n  F: Align2<F>\n): <L, A, B, C>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind2<F, L, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS2, L>(\n  F: Align2C<F, L>\n): <A, B, C>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind2<F, L, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 154,
        "to": 156
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS>(\n  F: Align1<F>\n): <A, B, C>(fa: Kind<F, A>, fb: Kind<F, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind<F, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F>(\n  F: Align<F>\n): <A, B, C>(fa: HKT<F, A>, fb: HKT<F, B>, f: (a: Option<A>, b: Option<B>) => C) => HKT<F, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 160,
        "to": 162
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F>(\n  F: Align<F>\n): <A, B, C>(fa: HKT<F, A>, fb: HKT<F, B>, f: (a: Option<A>, b: Option<B>) => C) => HKT<F, C> {\n  return (fa, fb, f) =>\n    F.alignWith(fa, fb, ab =>\n      pipe(\n        ab,\n        bimap(some, some),\n        fold(\n          a => f(a, none),\n          b => f(none, b),\n          (a, b) => f(a, b)\n        )\n      )\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 163,
        "to": 178
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function alignWith<K extends string, P extends string, A, B, C>(\n  fa: Record<K, A>,\n  fb: Record<P, B>,\n  f: (x: These<A, B>) => C\n): Record<K | P, C>",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<P, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K | P, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 11,
        "to": 15
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\nexport function alignWith<A, B, C>(\n  fa: Record<string, A>,\n  fb: Record<string, B>,\n  f: (x: These<A, B>) => C\n): Record<string, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 16,
        "to": 20
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\nexport function alignWith<A, B, C>(\n  fa: Record<string, A>,\n  fb: Record<string, B>,\n  f: (x: These<A, B>) => C\n): Record<string, C> {\n  const r: Record<string, C> = {}\n  for (const key of Object.keys(fa)) {\n    if (fb.hasOwnProperty(key)) {\n      r[key] = f(both(fa[key], fb[key]))\n    } else {\n      r[key] = f(left(fa[key]))\n    }\n  }\n  for (const key of Object.keys(fb)) {\n    if (!fa.hasOwnProperty(key)) {\n      r[key] = f(right(fb[key]))\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 21,
        "to": 40
      }
    }
  },
  {
    "name": "align",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function align<K extends string, P extends string, A, B>(\n  fa: Record<K, A>,\n  fb: Record<P, B>\n): Record<K | P, These<A, B>>",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K | P, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 45,
        "to": 48
      }
    }
  },
  {
    "name": "align",
    "text": "\nexport function align<A, B>(fa: Record<string, A>, fb: Record<string, B>): Record<string, These<A, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 49,
        "to": 49
      }
    }
  },
  {
    "name": "align",
    "text": "\nexport function align<A, B>(fa: Record<string, A>, fb: Record<string, B>): Record<string, These<A, B>> {\n  return alignWith<A, B, These<A, B>>(fa, fb, identity)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "nil",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function nil<A>(): Record<string, A> {\n  return R.empty\n}",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 57,
        "to": 59
      }
    }
  },
  {
    "name": "getLine",
    "text": "\n\n/**\n * @since 0.1.8\n */\nexport function getLine(question: string): Task<string> {\n  return () =>\n    new Promise(resolve => {\n      const rl = createInterface({\n        input: process.stdin,\n        output: process.stdout\n      })\n\n      rl.question(question, answer => {\n        rl.close()\n        resolve(answer)\n      })\n    })\n}",
    "docs": "/**\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "question",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Task/getLine.ts",
      "lines": {
        "from": 10,
        "to": 23
      }
    }
  },
  {
    "name": "withTimeout",
    "text": "\n\n/**\n * Returns the task result if it completes within a timeout, or a fallback value instead.\n *\n * @example\n * import { withTimeout } from 'fp-ts-contrib/lib/Task/withTimeout'\n * import { delay, of } from 'fp-ts/lib/Task'\n *\n * const completeAfter2s = delay(2000)(of('result'))\n *\n * async function f() {\n *   const a1 = await withTimeout('timeout', 3000)(completeAfter2s)()\n *   assert.strictEqual(a1, 'result')\n *   const a2 = await withTimeout('timeout', 1000)(completeAfter2s)()\n *   assert.strictEqual(a2, 'timeout')\n * }\n *\n * f()\n *\n * @since 0.1.0\n */\nexport function withTimeout<A>(onTimeout: A, millis: number): (ma: Task<A>) => Task<A> {\n  const M = getRaceMonoid<A>()\n  const fallback = delay(millis)(of(onTimeout))\n  return ma => M.concat(ma, fallback)\n}",
    "docs": "/**\n * Returns the task result if it completes within a timeout, or a fallback value instead.\n *\n * @example\n * import { withTimeout } from 'fp-ts-contrib/lib/Task/withTimeout'\n * import { delay, of } from 'fp-ts/lib/Task'\n *\n * const completeAfter2s = delay(2000)(of('result'))\n *\n * async function f() {\n *   const a1 = await withTimeout('timeout', 3000)(completeAfter2s)()\n *   assert.strictEqual(a1, 'result')\n *   const a2 = await withTimeout('timeout', 1000)(completeAfter2s)()\n *   assert.strictEqual(a2, 'timeout')\n * }\n *\n * f()\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onTimeout",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "millis",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Task/withTimeout.ts",
      "lines": {
        "from": 26,
        "to": 30
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function make<O, A>(decoder: D.Decoder<A>, encoder: E.Encoder<O, A>): Codec<O, A> {\n  return {\n    decode: decoder.decode,\n    encode: encoder.encode\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        },
        {
          "name": "encoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 41,
        "to": 46
      }
    }
  },
  {
    "name": "fromDecoder",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function fromDecoder<A>(decoder: D.Decoder<A>): Codec<A, A> {\n  return {\n    decode: decoder.decode,\n    encode: identity\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<A, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 51,
        "to": 56
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function literal<A extends ReadonlyArray<Literal>>(...values: A): Codec<A[number], A[number]> {\n  return fromDecoder(D.literal(...values))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<A[number], A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "withExpected",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function withExpected<O, A>(\n  codec: Codec<O, A>,\n  expected: (actual: unknown, e: D.DecodeError) => D.DecodeError\n): Codec<O, A> {\n  return make(D.withExpected(codec, expected), codec)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "(actual: unknown, e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").DecodeError) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").DecodeError"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 101,
        "to": 106
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function refinement<O, A, B extends A>(\n  from: Codec<O, A>,\n  refinement: (a: A) => a is B,\n  expected: string\n): Codec<O, B> {\n  return make(D.refinement(from, refinement, expected), from)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        },
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => a is B"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 111,
        "to": 117
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function nullable<O, A>(or: Codec<O, A>): Codec<null | O, null | A> {\n  return make(D.nullable(or), E.nullable(or))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function type<P extends Record<string, Codec<any, any>>>(\n  properties: P\n): Codec<{ [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  const decoder: D.Decoder<{ [K in keyof P]: TypeOf<P[K]> }> = D.type(properties) as any\n  return make(decoder, E.type(properties))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 129,
        "to": 134
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Codec<any, any>>>(\n  properties: P\n): Codec<Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return make(D.partial(properties), E.partial(properties))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 139,
        "to": 143
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Codec<O, A>): Codec<Record<string, O>, Record<string, A>> {\n  return make(D.record(codomain), E.record(codomain))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<Record<string, O>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 148,
        "to": 150
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function array<O, A>(items: Codec<O, A>): Codec<Array<O>, Array<A>> {\n  return make(D.array(items), E.array(items))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 155,
        "to": 157
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Codec<any, any>>>(\n  ...components: C\n): Codec<{ [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  const decoder: D.Decoder<{ [K in keyof C]: TypeOf<C[K]> }> = D.tuple(...components) as any\n  const encoder = E.tuple(...components)\n  return make(decoder, encoder)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 162,
        "to": 168
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function intersection<O, A, P, B>(left: Codec<O, A>, right: Codec<P, B>): Codec<O & P, A & B> {\n  return make(D.intersection(left, right), E.intersection(left, right))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O & P, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 173,
        "to": 175
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <M extends Record<string, Codec<any, any>>>(members: M) => Codec<OutputOf<M[keyof M]>, TypeOf<M[keyof M]>> {\n  const sumD = D.sum(tag)\n  const sumE = E.sum(tag)\n  return (members) => make(sumD(members), sumE(members))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<any, any>>>(members: M) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<M[keyof M]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<M[keyof M]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 180,
        "to": 186
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function lazy<O, A>(id: string, f: () => Codec<O, A>): Codec<O, A> {\n  return make(D.lazy(id, f), E.lazy(f))\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 191,
        "to": 193
      }
    }
  },
  {
    "name": "imap",
    "text": "const imap: <E, A, B>(f: (a: A) => B, g: (b: B) => A) => (fa: Codec<E, A>) => Codec<E, B> = (f, g) => (fa) =>\n  imap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 202,
        "to": 203
      }
    }
  },
  {
    "name": "tree",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function tree<A>(value: A, forest: Forest<A> = empty): Tree<A> {\n  return {\n    value,\n    forest\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "forest",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 43,
        "to": 48
      }
    }
  },
  {
    "name": "success",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function success<A>(a: A): Either<DecodeError, A> {\n  return right(a)\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 53,
        "to": 55
      }
    }
  },
  {
    "name": "failure",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function failure<A = never>(message: string): Either<DecodeError, A> {\n  return left([tree(message)])\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "isNotEmpty",
    "text": "\n\n/**\n * @since 2.2.2\n */\nexport function isNotEmpty<A>(as: ReadonlyArray<A>): as is NonEmptyArray<A> {\n  return as.length > 0\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "of",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function of<A>(a: A): Decoder<A> {\n  return {\n    decode: () => success(a)\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 78,
        "to": 82
      }
    }
  },
  {
    "name": "fromGuard",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function fromGuard<A>(guard: G.Guard<A>, expected: string): Decoder<A> {\n  return {\n    decode: (u) => (guard.is(u) ? success(u) : failure(`cannot decode ${JSON.stringify(u)}, should be ${expected}`))\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "guard",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 87,
        "to": 91
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function literal<A extends ReadonlyArray<Literal>>(...values: A): Decoder<A[number]> {\n  if (values.length === 0) {\n    return never\n  }\n  const expected = values.map((value) => JSON.stringify(value)).join(' | ')\n  return fromGuard(G.schemableGuard.literal(...values), expected)\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 96,
        "to": 102
      }
    }
  },
  {
    "name": "withExpected",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.0\n */\nexport function withExpected<A>(\n  decoder: Decoder<A>,\n  expected: (actual: unknown, e: DecodeError) => DecodeError\n): Decoder<A> {\n  return {\n    decode: (u) =>\n      pipe(\n        decoder.decode(u),\n        mapLeft((nea) => expected(u, nea))\n      )\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "(actual: unknown, e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").DecodeError) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").DecodeError"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 145,
        "to": 156
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function refinement<A, B extends A>(\n  from: Decoder<A>,\n  refinement: (a: A) => a is B,\n  expected: string\n): Decoder<B> {\n  return {\n    decode: (u) => {\n      const e = from.decode(u)\n      if (isLeft(e)) {\n        return e\n      }\n      const a = e.right\n      return refinement(a) ? success(a) : failure(`cannot refine ${JSON.stringify(u)}, should be ${expected}`)\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        },
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => a is B"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 161,
        "to": 176
      }
    }
  },
  {
    "name": "parse",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function parse<A, B>(from: Decoder<A>, parser: (a: A) => Either<string, B>): Decoder<B> {\n  return {\n    decode: (u) => {\n      const e = from.decode(u)\n      if (isLeft(e)) {\n        return e\n      }\n      const pe = parser(e.right)\n      if (isLeft(pe)) {\n        return failure(pe.left)\n      }\n      return pe\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        },
        {
          "name": "parser",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 181,
        "to": 195
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function nullable<A>(or: Decoder<A>): Decoder<null | A> {\n  return union(literal(null), or)\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 200,
        "to": 202
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function type<A>(properties: { [K in keyof A]: Decoder<A[K]> }): Decoder<A> {\n  return {\n    decode: (u) => {\n      const e = UnknownRecord.decode(u)\n      if (isLeft(e)) {\n        return e\n      } else {\n        const r = e.right\n        const a: Partial<A> = {}\n        const errors: Array<Tree<string>> = []\n        for (const k in properties) {\n          const e = properties[k].decode(r[k])\n          if (isLeft(e)) {\n            errors.push(tree(`required property ${JSON.stringify(k)}`, e.left))\n          } else {\n            a[k] = e.right\n          }\n        }\n        return isNotEmpty(errors) ? left(errors) : success(a as A)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 207,
        "to": 229
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function partial<A>(properties: { [K in keyof A]: Decoder<A[K]> }): Decoder<Partial<A>> {\n  return {\n    decode: (u) => {\n      const e = UnknownRecord.decode(u)\n      if (isLeft(e)) {\n        return e\n      } else {\n        const r = e.right\n        const a: Partial<A> = {}\n        const errors: Array<Tree<string>> = []\n        for (const k in properties) {\n          // don't add missing properties\n          if (k in r) {\n            const rk = r[k]\n            // don't strip undefined properties\n            if (rk === undefined) {\n              a[k] = undefined\n            } else {\n              const e = properties[k].decode(rk)\n              if (isLeft(e)) {\n                errors.push(tree(`optional property ${JSON.stringify(k)}`, e.left))\n              } else {\n                a[k] = e.right\n              }\n            }\n          }\n        }\n        return isNotEmpty(errors) ? left(errors) : success(a)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 234,
        "to": 265
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function record<A>(codomain: Decoder<A>): Decoder<Record<string, A>> {\n  return {\n    decode: (u) => {\n      const e = UnknownRecord.decode(u)\n      if (isLeft(e)) {\n        return e\n      } else {\n        const r = e.right\n        const a: Record<string, A> = {}\n        const errors: Array<Tree<string>> = []\n        for (const k in r) {\n          const e = codomain.decode(r[k])\n          if (isLeft(e)) {\n            errors.push(tree(`key ${JSON.stringify(k)}`, e.left))\n          } else {\n            a[k] = e.right\n          }\n        }\n        return isNotEmpty(errors) ? left(errors) : success(a)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 270,
        "to": 292
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function array<A>(items: Decoder<A>): Decoder<Array<A>> {\n  return {\n    decode: (u) => {\n      const e = UnknownArray.decode(u)\n      if (isLeft(e)) {\n        return e\n      } else {\n        const us = e.right\n        const len = us.length\n        const a: Array<A> = new Array(len)\n        const errors: Array<Tree<string>> = []\n        for (let i = 0; i < len; i++) {\n          const e = items.decode(us[i])\n          if (isLeft(e)) {\n            errors.push(tree(`item ${i}`, e.left))\n          } else {\n            a[i] = e.right\n          }\n        }\n        return isNotEmpty(errors) ? left(errors) : success(a)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 297,
        "to": 320
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function tuple<A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Decoder<A[K]> }): Decoder<A> {\n  return {\n    decode: (u) => {\n      const e = UnknownArray.decode(u)\n      if (isLeft(e)) {\n        return e\n      }\n      const us = e.right\n      const a: Array<unknown> = []\n      const errors: Array<Tree<string>> = []\n      for (let i = 0; i < components.length; i++) {\n        const e = components[i].decode(us[i])\n        if (isLeft(e)) {\n          errors.push(tree(`component ${i}`, e.left))\n        } else {\n          a.push(e.right)\n        }\n      }\n      return isNotEmpty(errors) ? left(errors) : success(a as any)\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 325,
        "to": 346
      }
    }
  },
  {
    "name": "intersect",
    "text": "\n\n/**\n * @internal\n */\nexport function intersect<A, B>(a: A, b: B): A & B {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A & B"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 355,
        "to": 364
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function intersection<A, B>(left: Decoder<A>, right: Decoder<B>): Decoder<A & B> {\n  return {\n    decode: (u) => {\n      const ea = left.decode(u)\n      if (isLeft(ea)) {\n        return ea\n      }\n      const eb = right.decode(u)\n      if (isLeft(eb)) {\n        return eb\n      }\n      return success(intersect(ea.right, eb.right))\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 369,
        "to": 383
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function lazy<A>(id: string, f: () => Decoder<A>): Decoder<A> {\n  const get = memoize<void, Decoder<A>>(f)\n  return {\n    decode: (u) =>\n      pipe(\n        get().decode(u),\n        mapLeft((nea) => [tree(id, nea)])\n      )\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 388,
        "to": 397
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function sum<T extends string>(tag: T): <A>(members: { [K in keyof A]: Decoder<A[K]> }) => Decoder<A[keyof A]> {\n  return (members) => {\n    const keys = Object.keys(members)\n    if (keys.length === 0) {\n      return never\n    }\n    const expected = keys.map((k) => JSON.stringify(k)).join(' | ')\n    return {\n      decode: (u) => {\n        const e = UnknownRecord.decode(u)\n        if (isLeft(e)) {\n          return e\n        }\n        const v = e.right[tag]\n        if (G.string.is(v) && v in members) {\n          return (members as any)[v].decode(u)\n        }\n        return left([\n          tree(`required property ${JSON.stringify(tag)}`, [\n            tree(`cannot decode ${JSON.stringify(v)}, should be ${expected}`)\n          ])\n        ])\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[K]>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 402,
        "to": 427
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function union<A extends ReadonlyArray<unknown>>(\n  ...members: { [K in keyof A]: Decoder<A[K]> }\n): Decoder<A[number]> {\n  const len = members.length\n  if (len === 0) {\n    return never\n  }\n  return {\n    decode: (u) => {\n      const e = members[0].decode(u)\n      if (isRight(e)) {\n        return e\n      } else {\n        const errors: DecodeError = [tree(`member 0`, e.left)]\n        for (let i = 1; i < len; i++) {\n          const e = members[i].decode(u)\n          if (isRight(e)) {\n            return e\n          } else {\n            errors.push(tree(`member ${i}`, e.left))\n          }\n        }\n        return left(errors)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 432,
        "to": 458
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Decoder<A>) => Decoder<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 467,
        "to": 467
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => Decoder<A>) => (fa: Decoder<A>) => Decoder<A> = (that) => (fa) => alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 479,
        "to": 479
      }
    }
  },
  {
    "name": "id",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function id<A>(): Encoder<A, A> {\n  return {\n    encode: identity\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<A, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 38,
        "to": 42
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function nullable<O, A>(or: Encoder<O, A>): Encoder<null | O, null | A> {\n  return {\n    encode: (a) => (a === null ? null : or.encode(a))\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 51,
        "to": 55
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function type<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<{ [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        o[k] = properties[k].encode(a[k])\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 60,
        "to": 72
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        const v = a[k]\n        // don't add missing properties\n        if (k in a) {\n          // don't strip undefined properties\n          o[k] = v === undefined ? undefined : properties[k].encode(v)\n        }\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 77,
        "to": 94
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Encoder<O, A>): Encoder<Record<string, O>, Record<string, A>> {\n  return {\n    encode: (r) => {\n      const o: Record<string, O> = {}\n      for (const k in r) {\n        o[k] = codomain.encode(r[k])\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<Record<string, O>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 99,
        "to": 109
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function array<O, A>(items: Encoder<O, A>): Encoder<Array<O>, Array<A>> {\n  return {\n    encode: (as) => as.map(items.encode)\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 114,
        "to": 118
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Encoder<any, any>>>(\n  ...components: C\n): Encoder<{ [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return {\n    encode: (as) => components.map((c, i) => c.encode(as[i])) as any\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 123,
        "to": 129
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function intersection<O, A, P, B>(left: Encoder<O, A>, right: Encoder<P, B>): Encoder<O & P, A & B> {\n  return {\n    encode: (ab) => intersect(left.encode(ab), right.encode(ab))\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O & P, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 134,
        "to": 138
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <M extends Record<string, Encoder<any, any>>>(members: M) => Encoder<OutputOf<M[keyof M]>, TypeOf<M[keyof M]>> {\n  return (members) => {\n    return {\n      encode: (a) => members[a[tag]].encode(a)\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<any, any>>>(members: M) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<M[keyof M]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<M[keyof M]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 143,
        "to": 151
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function lazy<O, A>(f: () => Encoder<O, A>): Encoder<O, A> {\n  const get = memoize<void, Encoder<O, A>>(f)\n  return {\n    encode: (a) => get().encode(a)\n  }\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 156,
        "to": 161
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Encoder<E, A>) => Encoder<E, B> = (f) => (fa) =>\n  contramap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 170,
        "to": 171
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <E, A>(ea: Encoder<E, A>) => <B>(ab: Encoder<A, B>) => Encoder<E, B> = (ea) => (ab) =>\n  compose_(ab, ea)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(ab: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<A, B>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 180,
        "to": 181
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.2\n */\nexport function nullable<A>(or: Eq<A>): Eq<null | A> {\n  return {\n    equals: (x, y) => (x === null || y === null ? x === y : or.equals(x, y))\n  }\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 68,
        "to": 72
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.2\n */\nexport function partial<A>(properties: { [K in keyof A]: Eq<A[K]> }): Eq<Partial<A>> {\n  return {\n    equals: (x, y) => {\n      for (const k in properties) {\n        const xk = x[k]\n        const yk = y[k]\n        if (!(xk === undefined || yk === undefined ? xk === yk : properties[k].equals(xk!, yk!))) {\n          return false\n        }\n      }\n      return true\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: any; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 82,
        "to": 95
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.2\n */\nexport function intersection<A, B>(left: Eq<A>, right: Eq<B>): Eq<A & B> {\n  return {\n    equals: (x, y) => left.equals(x, y) && right.equals(x, y)\n  }\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 117,
        "to": 121
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.2\n */\nexport function sum<T extends string>(tag: T): <A>(members: { [K in keyof A]: Eq<A[K]> }) => Eq<A[keyof A]> {\n  return (members: Record<string, Eq<any>>) => {\n    return {\n      equals: (x: Record<string, any>, y: Record<string, any>) => {\n        const vx = x[tag]\n        const vy = y[tag]\n        if (vx !== vy) {\n          return false\n        }\n        return members[vx].equals(x, y)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: any; }) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 126,
        "to": 139
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.2\n */\nexport function lazy<A>(f: () => Eq<A>): Eq<A> {\n  const get = memoize<void, Eq<A>>(f)\n  return {\n    equals: (x, y) => get().equals(x, y)\n  }\n}",
    "docs": "/**\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 144,
        "to": 149
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.0\n */\nexport function literal<A extends ReadonlyArray<Literal>>(...values: A): Guard<A[number]> {\n  return {\n    is: (u: unknown): u is A[number] => values.findIndex((a) => a === u) !== -1\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 29,
        "to": 33
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.0\n */\nexport function refinement<A, B extends A>(from: Guard<A>, refinement: (a: A) => a is B): Guard<B> {\n  return {\n    is: (u: unknown): u is B => from.is(u) && refinement(u)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        },
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => a is B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 88,
        "to": 92
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function nullable<A>(or: Guard<A>): Guard<null | A> {\n  return {\n    is: (u): u is null | A => u === null || or.is(u)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 97,
        "to": 101
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function type<A>(properties: { [K in keyof A]: Guard<A[K]> }): Guard<A> {\n  return refinement(UnknownRecord, (r): r is {\n    [K in keyof A]: A[K]\n  } => {\n    for (const k in properties) {\n      if (!(k in r) || !properties[k].is(r[k])) {\n        return false\n      }\n    }\n    return true\n  })\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 106,
        "to": 117
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function partial<A>(properties: { [K in keyof A]: Guard<A[K]> }): Guard<Partial<A>> {\n  return refinement(UnknownRecord, (r): r is Partial<A> => {\n    for (const k in properties) {\n      const v = r[k]\n      if (v !== undefined && !properties[k].is(v)) {\n        return false\n      }\n    }\n    return true\n  })\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 122,
        "to": 132
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function record<A>(codomain: Guard<A>): Guard<Record<string, A>> {\n  return refinement(UnknownRecord, (r): r is Record<string, A> => {\n    for (const k in r) {\n      if (!codomain.is(r[k])) {\n        return false\n      }\n    }\n    return true\n  })\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 137,
        "to": 146
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function array<A>(items: Guard<A>): Guard<Array<A>> {\n  return refinement(UnknownArray, (us): us is Array<A> => us.every(items.is))\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function tuple<A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Guard<A[K]> }): Guard<A> {\n  return {\n    is: (u): u is A => Array.isArray(u) && u.length === components.length && components.every((c, i) => c.is(u[i]))\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 158,
        "to": 162
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function intersection<A, B>(left: Guard<A>, right: Guard<B>): Guard<A & B> {\n  return {\n    is: (u: unknown): u is A & B => left.is(u) && right.is(u)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 167,
        "to": 171
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function union<A extends ReadonlyArray<unknown>>(...members: { [K in keyof A]: Guard<A[K]> }): Guard<A[number]> {\n  return {\n    is: (u: unknown): u is A | A[number] => members.some((m) => m.is(u))\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 176,
        "to": 180
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function sum<T extends string>(tag: T): <A>(members: { [K in keyof A]: Guard<A[K]> }) => Guard<A[keyof A]> {\n  return (members: Record<string, Guard<unknown>>) =>\n    refinement(UnknownRecord, (r): r is any => {\n      const v = r[tag]\n      if (string.is(v) && v in members) {\n        return members[v].is(r)\n      }\n      return false\n    })\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[K]>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 185,
        "to": 194
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function lazy<A>(f: () => Guard<A>): Guard<A> {\n  const get = memoize<void, Guard<A>>(f)\n  return {\n    is: (u: unknown): u is A => get().is(u)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 199,
        "to": 204
      }
    }
  },
  {
    "name": "getDomainKeys",
    "text": "\n\n/**\n * @internal\n */\nexport function getDomainKeys<D extends Mixed>(domain: D): Record<string, unknown> | undefined {\n  if (isLiteralC(domain)) {\n    const literal = domain.value\n    if (string.is(literal)) {\n      return { [literal]: null }\n    }\n  } else if (isKeyofC(domain)) {\n    return domain.keys\n  } else if (isUnionC(domain)) {\n    const keys = domain.types.map((type) => getDomainKeys(type))\n    return keys.some(undefinedType.is) ? undefined : Object.assign({}, ...keys)\n  }\n  return undefined\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "domain",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1123,
        "to": 1136
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 1.7.1\n */\nexport function record<D extends Mixed, C extends Mixed>(domain: D, codomain: C, name?: string): RecordC<D, C> {\n  const keys = getDomainKeys(domain)\n  return keys\n    ? enumerableRecord(Object.keys(keys), domain, codomain, name)\n    : nonEnumerableRecord(domain, codomain, name)\n}",
    "docs": "/**\n * @since 1.7.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "domain",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        },
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RecordC<D, C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1205,
        "to": 1210
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed, E extends Mixed>(\n  codecs: [A, B, C, D, E],\n  name?: string\n): IntersectionC<[A, B, C, D, E]>",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D, E]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C, D, E]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1406,
        "to": 1409
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed>(\n  codecs: [A, B, C, D],\n  name?: string\n): IntersectionC<[A, B, C, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C, D]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1410,
        "to": 1413
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed>(\n  codecs: [A, B, C],\n  name?: string\n): IntersectionC<[A, B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1414,
        "to": 1417
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed>(codecs: [A, B], name?: string): IntersectionC<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1418,
        "to": 1418
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = `(${codecs.map((type) => type.name).join(' & ')})`\n): IntersectionC<CS> {\n  const len = codecs.length\n  return new IntersectionType(\n    name,\n    (u: unknown): u is any => codecs.every((type) => type.is(u)),\n    codecs.length === 0\n      ? success\n      : (u, c) => {\n          const us: Array<unknown> = []\n          const errors: Errors = []\n          for (let i = 0; i < len; i++) {\n            const codec = codecs[i]\n            const result = codec.validate(u, appendContext(c, String(i), codec, u))\n            if (isLeft(result)) {\n              pushAll(errors, result.left)\n            } else {\n              us.push(result.right)\n            }\n          }\n          return errors.length > 0 ? failures(errors) : success(mergeAll(u, us))\n        },\n    codecs.length === 0\n      ? identity\n      : (a) =>\n          mergeAll(\n            a,\n            codecs.map((codec) => codec.encode(a))\n          ),\n    codecs\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1419,
        "to": 1452
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed, E extends Mixed>(\n  codecs: [A, B, C, D, E],\n  name?: string\n): TupleC<[A, B, C, D, E]>",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D, E]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C, D, E]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1507,
        "to": 1510
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed>(\n  codecs: [A, B, C, D],\n  name?: string\n): TupleC<[A, B, C, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C, D]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1511,
        "to": 1514
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed>(\n  codecs: [A, B, C],\n  name?: string\n): TupleC<[A, B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1515,
        "to": 1518
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed>(codecs: [A, B], name?: string): TupleC<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1519,
        "to": 1519
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed>(codecs: [A], name?: string): TupleC<[A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1520,
        "to": 1520
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<CS extends [Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = `[${codecs.map((type) => type.name).join(', ')}]`\n): TupleC<CS> {\n  const len = codecs.length\n  return new TupleType(\n    name,\n    (u): u is any => UnknownArray.is(u) && u.length === len && codecs.every((type, i) => type.is(u[i])),\n    (u, c) => {\n      const e = UnknownArray.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const us = e.right\n      let as: Array<any> = us.length > len ? us.slice(0, len) : us // strip additional components\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const a = us[i]\n        const type = codecs[i]\n        const result = type.validate(a, appendContext(c, String(i), type, a))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const va = result.right\n          if (va !== a) {\n            /* istanbul ignore next */\n            if (as === us) {\n              as = us.slice()\n            }\n            as[i] = va\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(as)\n    },\n    useIdentity(codecs) ? identity : (a) => codecs.map((type, i) => type.encode(a[i])),\n    codecs\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1521,
        "to": 1559
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */\nexport function refinement<C extends Any>(\n  codec: C,\n  predicate: Predicate<TypeOf<C>>,\n  name: string = `(${codec.name} | ${getFunctionName(predicate)})`\n): // tslint:disable-next-line: deprecation\nRefinementC<C> {\n  return new RefinementType(\n    name,\n    (u): u is TypeOf<C> => codec.is(u) && predicate(u),\n    (i, c) => {\n      const e = codec.validate(i, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const a = e.right\n      return predicate(a) ? success(a) : failure(a, c)\n    },\n    codec.encode,\n    codec,\n    predicate\n  )\n}",
    "docs": "/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RefinementC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2020,
        "to": 2041
      }
    }
  },
  {
    "name": "clean",
    "text": "\n\n/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nexport function clean<A, O = A, I = unknown>(codec: Type<A, O, I>): Type<A, O, I> {\n  return codec as any\n}",
    "docs": "/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2183,
        "to": 2185
      }
    }
  },
  {
    "name": "alias",
    "text": "\n\n/**\n * Keeps the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nexport function alias<A, O, P, I>(\n  codec: PartialType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => PartialType<PP, AA, OO, II>",
    "docs": "/**\n * Keeps the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2205,
        "to": 2215
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, P, I>(\n  // tslint:disable-next-line: deprecation\n  codec: StrictType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => // tslint:disable-next-line: deprecation\nStrictType<PP, AA, OO, II>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").StrictType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").StrictType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2216,
        "to": 2228
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, P, I>(\n  codec: InterfaceType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => InterfaceType<PP, AA, OO, II>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").InterfaceType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").InterfaceType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2229,
        "to": 2239
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, I>(\n  codec: Type<A, O, I>\n): // tslint:disable-next-line: deprecation\n<AA extends Exact<A, AA>, OO extends Exact<O, OO> = O>() => Type<AA, OO, I> {\n  return () => codec as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<AA, OO, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2240,
        "to": 2245
      }
    }
  },
  {
    "name": "getTags",
    "text": "\n\n/**\n * @internal\n */\nexport function getTags(codec: Any): Tags {\n  if (lazyCodecs.indexOf(codec) !== -1) {\n    return emptyTags\n  }\n  if (isTypeC(codec) || isStrictC(codec)) {\n    let index: Tags = emptyTags\n    // tslint:disable-next-line: forin\n    for (let k in codec.props) {\n      const prop = codec.props[k]\n      if (isLiteralC(prop)) {\n        if (index === emptyTags) {\n          index = {}\n        }\n        index[k] = [prop.value]\n      }\n    }\n    return index\n  } else if (isExactC(codec) || isRefinementC(codec)) {\n    return getTags(codec.type)\n  } else if (isIntersectionC(codec)) {\n    return codec.types.reduce((tags, codec) => mergeTags(tags, getTags(codec)), emptyTags)\n  } else if (isUnionC(codec)) {\n    return codec.types.slice(1).reduce((tags, codec) => intersectTags(tags, getTags(codec)), getTags(codec.types[0]))\n  } else if (isRecursiveC(codec)) {\n    lazyCodecs.push(codec)\n    const tags = getTags(codec.type)\n    lazyCodecs.pop()\n    return tags\n  }\n  return emptyTags\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Tags"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2365,
        "to": 2395
      }
    }
  },
  {
    "name": "getIndex",
    "text": "\n\n/**\n * @internal\n */\nexport function getIndex(codecs: NonEmptyArray<Any>): [string, NonEmptyArray<NonEmptyArray<LiteralValue>>] | undefined {\n  const tags = getTags(codecs[0])\n  const keys = Object.keys(tags)\n  const len = codecs.length\n  keys: for (const k of keys) {\n    const all = tags[k].slice()\n    const index: NonEmptyArray<NonEmptyArray<LiteralValue>> = [tags[k]]\n    for (let i = 1; i < len; i++) {\n      const codec = codecs[i]\n      const ctags = getTags(codec)\n      const values = ctags[k]\n      // tslint:disable-next-line: strict-type-predicates\n      if (values === undefined) {\n        continue keys\n      } else {\n        if (values.some((v) => all.indexOf(v) !== -1)) {\n          continue keys\n        } else {\n          all.push(...values)\n          index.push(values)\n        }\n      }\n    }\n    return [k, index]\n  }\n  return undefined\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[string, NonEmptyArray<NonEmptyArray<LiteralValue>>]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2400,
        "to": 2426
      }
    }
  },
  {
    "name": "identity",
    "text": "const identity = <A>(a: A): A => a",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 179,
        "to": 179
      }
    }
  },
  {
    "name": "getFunctionName",
    "text": "const getFunctionName = (f: Function): string =>\n  (f as any).displayName || (f as any).name || `<function${f.length}>`",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 184,
        "to": 185
      }
    }
  },
  {
    "name": "getContextEntry",
    "text": "const getContextEntry = (key: string, decoder: Decoder<any, any>): ContextEntry => ({ key, type: decoder })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "key",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ContextEntry"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 190,
        "to": 190
      }
    }
  },
  {
    "name": "appendContext",
    "text": "const appendContext = (c: Context, key: string, decoder: Decoder<any, any>, actual?: unknown): Context => {\n  const len = c.length\n  const r = Array(len + 1)\n  for (let i = 0; i < len; i++) {\n    r[i] = c[i]\n  }\n  r[len] = { key, type: decoder, actual }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        },
        {
          "name": "key",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        },
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 195,
        "to": 203
      }
    }
  },
  {
    "name": "failure",
    "text": "const failure = <T>(value: unknown, context: Context, message?: string): Validation<T> =>\n  failures([{ value, context, message }])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "context",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 213,
        "to": 214
      }
    }
  },
  {
    "name": "brand",
    "text": "const brand = <C extends Any, N extends string, B extends { readonly [K in N]: symbol }>(\n  codec: C,\n  predicate: Refinement<TypeOf<C>, Branded<TypeOf<C>, B>>,\n  name: N\n): BrandC<C, B> => {\n  // tslint:disable-next-line: deprecation\n  return refinement(codec, predicate, name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").BrandC<C, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 574,
        "to": 581
      }
    }
  },
  {
    "name": "literal",
    "text": "const literal = <V extends LiteralValue>(value: V, name: string = JSON.stringify(value)): LiteralC<V> => {\n  const is = (u: unknown): u is V => u === value\n  return new LiteralType(name, is, (u, c) => (is(u) ? success(value) : failure(u, c)), identity, value)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Other",
            "values": "V"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").LiteralC<V>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 630,
        "to": 633
      }
    }
  },
  {
    "name": "keyof",
    "text": "const keyof = <D extends { [key: string]: unknown }>(\n  keys: D,\n  name: string = Object.keys(keys)\n    .map((k) => JSON.stringify(k))\n    .join(' | ')\n): KeyofC<D> => {\n  const is = (u: unknown): u is keyof D => string.is(u) && hasOwnProperty.call(keys, u)\n  return new KeyofType(name, is, (u, c) => (is(u) ? success(u) : failure(u, c)), identity, keys)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "keys",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").KeyofC<D>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 664,
        "to": 672
      }
    }
  },
  {
    "name": "recursion",
    "text": "const recursion = <A, O = A, I = unknown, C extends Type<A, O, I> = Type<A, O, I>>(\n  name: string,\n  definition: (self: C) => C\n): RecursiveType<C, A, O, I> => {\n  let cache: C\n  const runDefinition = (): C => {\n    if (!cache) {\n      cache = definition(Self)\n      ;(cache as any).name = name\n    }\n    return cache\n  }\n  const Self: any = new RecursiveType<C, A, O, I>(\n    name,\n    (u): u is A => runDefinition().is(u),\n    (u, c) => runDefinition().validate(u, c),\n    (a) => runDefinition().encode(a),\n    runDefinition\n  )\n  return Self\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "definition",
          "type": {
            "__tag": "Other",
            "values": "(self: C) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RecursiveType<C, A, O, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 708,
        "to": 728
      }
    }
  },
  {
    "name": "array",
    "text": "const array = <C extends Mixed>(codec: C, name: string = `Array<${codec.name}>`): ArrayC<C> =>\n  new ArrayType(\n    name,\n    (u): u is Array<TypeOf<C>> => UnknownArray.is(u) && u.every(codec.is),\n    (u, c) => {\n      const e = UnknownArray.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const us = e.right\n      const len = us.length\n      let as: Array<TypeOf<C>> = us\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const ui = us[i]\n        const result = codec.validate(ui, appendContext(c, String(i), codec, ui))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const ai = result.right\n          if (ai !== ui) {\n            if (as === us) {\n              as = us.slice()\n            }\n            as[i] = ai\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(as)\n    },\n    codec.encode === identity ? identity : (a) => a.map(codec.encode),\n    codec\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ArrayC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 757,
        "to": 789
      }
    }
  },
  {
    "name": "type",
    "text": "const type = <P extends Props>(props: P, name: string = getInterfaceTypeName(props)): TypeC<P> => {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new InterfaceType(\n    name,\n    (u): u is { [K in keyof P]: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = types[i]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const vak = result.right\n          if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [x: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const encode = types[i].encode\n            if (encode !== identity) {\n              s[k] = encode(a[k])\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 861,
        "to": 923
      }
    }
  },
  {
    "name": "partial",
    "text": "const partial = <P extends Props>(\n  props: P,\n  name: string = getPartialTypeName(getInterfaceTypeName(props))\n): PartialC<P> => {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new PartialType(\n    name,\n    (u): u is { [K in keyof P]?: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if (uk !== undefined && !props[k].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = props[k]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          if (ak !== undefined) {\n            pushAll(errors, result.left)\n          }\n        } else {\n          const vak = result.right\n          if (vak !== ak) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [key: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const ak = a[k]\n            if (ak !== undefined) {\n              s[k] = types[i].encode(ak)\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 967,
        "to": 1034
      }
    }
  },
  {
    "name": "union",
    "text": "const union = <CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = getUnionName(codecs)\n): UnionC<CS> => {\n  const index = getIndex(codecs)\n  if (index !== undefined && codecs.length > 0) {\n    const [tag, groups] = index\n    const len = groups.length\n    const find = (value: any): number | undefined => {\n      for (let i = 0; i < len; i++) {\n        if (groups[i].indexOf(value) !== -1) {\n          return i\n        }\n      }\n      return undefined\n    }\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(\n      name,\n      (u): u is TypeOf<CS[number]> => {\n        if (UnknownRecord.is(u)) {\n          const i = find(u[tag])\n          return i !== undefined ? codecs[i].is(u) : false\n        }\n        return false\n      },\n      (u, c) => {\n        const e = UnknownRecord.validate(u, c)\n        if (isLeft(e)) {\n          return e\n        }\n        const r = e.right\n        const i = find(r[tag])\n        if (i === undefined) {\n          return failure(u, c)\n        }\n        const codec = codecs[i]\n        return codec.validate(r, appendContext(c, String(i), codec, r))\n      },\n      useIdentity(codecs)\n        ? identity\n        : (a) => {\n            const i = find(a[tag])\n            if (i === undefined) {\n              // https://github.com/gcanti/io-ts/pull/305\n              throw new Error(`no codec found to encode value in union codec ${name}`)\n            } else {\n              return codecs[i].encode(a)\n            }\n          },\n      codecs,\n      tag\n    )\n  } else {\n    return new UnionType(\n      name,\n      (u): u is TypeOf<CS[number]> => codecs.some((type) => type.is(u)),\n      (u, c) => {\n        const errors: Errors = []\n        for (let i = 0; i < codecs.length; i++) {\n          const codec = codecs[i]\n          const result = codec.validate(u, appendContext(c, String(i), codec, u))\n          if (isLeft(result)) {\n            pushAll(errors, result.left)\n          } else {\n            return success(result.right)\n          }\n        }\n        return failures(errors)\n      },\n      useIdentity(codecs)\n        ? identity\n        : (a) => {\n            for (const codec of codecs) {\n              if (codec.is(a)) {\n                return codec.encode(a)\n              }\n            }\n            // https://github.com/gcanti/io-ts/pull/305\n            throw new Error(`no codec found to encode value in union type ${name}`)\n          },\n      codecs\n    )\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").UnionC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1244,
        "to": 1328
      }
    }
  },
  {
    "name": "readonly",
    "text": "const readonly = <C extends Mixed>(codec: C, name: string = `Readonly<${codec.name}>`): ReadonlyC<C> => {\n  return new ReadonlyType(\n    name,\n    codec.is,\n    (u, c) => {\n      const e = codec.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const x = e.right\n      if (process.env.NODE_ENV !== 'production') {\n        return right(Object.freeze(x))\n      }\n      return right(x)\n    },\n    codec.encode === identity ? identity : codec.encode,\n    codec\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ReadonlyC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1589,
        "to": 1607
      }
    }
  },
  {
    "name": "readonlyArray",
    "text": "const readonlyArray = <C extends Mixed>(\n  codec: C,\n  name: string = `ReadonlyArray<${codec.name}>`\n): ReadonlyArrayC<C> => {\n  const arrayType = array(codec)\n  return new ReadonlyArrayType(\n    name,\n    arrayType.is,\n    (u, c) => {\n      const e = arrayType.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const x = e.right\n      if (process.env.NODE_ENV !== 'production') {\n        return right(Object.freeze(x))\n      }\n      return right(x)\n    },\n    arrayType.encode as any,\n    codec\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ReadonlyArrayC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1637,
        "to": 1659
      }
    }
  },
  {
    "name": "strict",
    "text": "const strict = <P extends Props>(props: P, name?: string): ExactC<TypeC<P>> => {\n  return exact(type(props), name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ExactC<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1665,
        "to": 1667
      }
    }
  },
  {
    "name": "taggedUnion",
    "text": "const taggedUnion = <Tag extends string, CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  tag: Tag,\n  codecs: CS,\n  name: string = getUnionName(codecs)\n  // tslint:disable-next-line: deprecation\n): TaggedUnionC<Tag, CS> => {\n  const U = union(codecs, name)\n  // tslint:disable-next-line: deprecation\n  if (U instanceof TaggedUnionType) {\n    return U\n  } else {\n    console.warn(`[io-ts] Cannot build a tagged union for ${name}, returning a de-optimized union`)\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "Tag"
          }
        },
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TaggedUnionC<Tag, CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1708,
        "to": 1723
      }
    }
  },
  {
    "name": "exact",
    "text": "const exact = <C extends HasProps>(codec: C, name: string = getExactTypeName(codec)): ExactC<C> => {\n  const props: Props = getProps(codec)\n  return new ExactType(\n    name,\n    codec.is,\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const ce = codec.validate(u, c)\n      if (isLeft(ce)) {\n        return ce\n      }\n      return right(stripKeys(ce.right, props))\n    },\n    (a) => codec.encode(stripKeys(a, props)),\n    codec\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ExactC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1815,
        "to": 1834
      }
    }
  },
  {
    "name": "type",
    "text": "const type = <P extends Props>(props: P, name: string = getInterfaceTypeName(props)): TypeC<P> => {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new InterfaceType(\n    name,\n    (u): u is { [K in keyof P]: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = types[i]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const vak = result.right\n          if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [x: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const encode = types[i].encode\n            if (encode !== identity) {\n              s[k] = encode(a[k])\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 861,
        "to": 923
      }
    }
  },
  {
    "name": "getValidationError",
    "text": "const getValidationError /* istanbul ignore next */ = (value: unknown, context: Context): ValidationError => ({\n  value,\n  context\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "context",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ValidationError"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1889,
        "to": 1892
      }
    }
  },
  {
    "name": "getDefaultContext",
    "text": "const getDefaultContext /* istanbul ignore next */ = (decoder: Decoder<any, any>): Context => [\n  { key: '', type: decoder }\n]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1898,
        "to": 1900
      }
    }
  },
  {
    "name": "failure",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function failure(es: Array<ValidationError>): Array<string> {\n  return es.map(getMessage)\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "es",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ValidationError[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "string[]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/PathReporter.ts",
      "lines": {
        "from": 34,
        "to": 36
      }
    }
  },
  {
    "name": "success",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function success(): Array<string> {\n  return ['No errors!']\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "string[]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/PathReporter.ts",
      "lines": {
        "from": 41,
        "to": 43
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function make<A>(schema: Schema<A>): Schema<A> {\n  return memoize(schema)\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "schema",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 22,
        "to": 24
      }
    }
  },
  {
    "name": "interpreter",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function interpreter<S extends URIS>(S: Schemable1<S>): <A>(schema: Schema<A>) => Kind<S, A> {\n  return (schema: any) => schema(S)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schemable\").Schemable1<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(schema: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 29,
        "to": 31
      }
    }
  },
  {
    "name": "memoize",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  let cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => B"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schemable.ts",
      "lines": {
        "from": 100,
        "to": 110
      }
    }
  },
  {
    "name": "draw",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function draw(e: DecodeError): string {\n  return e.map(drawTree).join('\\n')\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").DecodeError"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 10,
        "to": 12
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function literal<A extends ReadonlyArray<Literal>>(...values: A): Type<A[number]> {\n  return t.union(values.map((v) => t.literal(v as any)) as any)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.2.3\n */\nexport function refinement<A, B extends A>(from: Type<A>, refinement: (a: A) => a is B, expected: string): Type<B> {\n  // tslint:disable-next-line: deprecation\n  return t.refinement(from, refinement, expected) as any\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        },
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => a is B"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 63,
        "to": 66
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function nullable<A>(or: Type<A>): Type<null | A> {\n  return t.union([t.null, or])\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function type<A>(properties: { [K in keyof A]: Type<A[K]> }): Type<A> {\n  return t.type(properties) as any\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function partial<A>(properties: { [K in keyof A]: Type<A[K]> }): Type<Partial<A>> {\n  return t.partial(properties)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function record<A>(codomain: Type<A>): Type<Record<string, A>> {\n  return t.record(t.string, codomain)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function array<A>(items: Type<A>): Type<Array<A>> {\n  return t.array(items)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function tuple<A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Type<A[K]> }): Type<A> {\n  return t.tuple(components as any) as any\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function intersection<A, B>(left: Type<A>, right: Type<B>): Type<A & B> {\n  return t.intersection([left, right])\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 113,
        "to": 115
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function lazy<A>(id: string, f: () => Type<A>): Type<A> {\n  return t.recursion(id, f)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 120,
        "to": 122
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function sum<T extends string>(_tag: T): <A>(members: { [K in keyof A]: Type<A[K]> }) => Type<A[keyof A]> {\n  return (members) => t.union(Object.values(members) as any)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "_tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 127,
        "to": 129
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function union<A extends ReadonlyArray<unknown>>(...members: { [K in keyof A]: Type<A[K]> }): Type<A[number]> {\n  return t.union(members as any)\n}",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 134,
        "to": 136
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\nexport function literal<A extends ReadonlyArray<S.Literal>>(...values: A): Arbitrary<A[number]> {\n  return fc.oneof(...values.map((v) => fc.constant(v)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 18,
        "to": 20
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\nexport function refinement<A, B extends A>(from: Arbitrary<A>, refinement: (a: A) => a is B): Arbitrary<B> {\n  return from.filter(refinement)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "from",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        },
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => a is B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 46,
        "to": 48
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\nexport function nullable<A>(or: Arbitrary<A>): Arbitrary<null | A> {\n  return fc.oneof(fc.constant(null), or)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "type",
    "text": "\n\nexport function type<A>(properties: { [K in keyof A]: Arbitrary<A[K]> }): Arbitrary<A> {\n  return fc.record(properties)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 54,
        "to": 56
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\nexport function partial<A>(properties: { [K in keyof A]: Arbitrary<A[K]> }): Arbitrary<Partial<A>> {\n  const keys = fc.oneof(...Object.keys(properties).map((p) => fc.constant(p)))\n  return keys.chain((key) => {\n    const p: any = { ...properties }\n    delete p[key]\n    return fc.record(p)\n  })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 58,
        "to": 65
      }
    }
  },
  {
    "name": "record",
    "text": "\n\nexport function record<A>(codomain: Arbitrary<A>): Arbitrary<Record<string, A>> {\n  return fc.dictionary(string, codomain)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "array",
    "text": "\n\nexport function array<A>(items: Arbitrary<A>): Arbitrary<Array<A>> {\n  return fc.array(items)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\nexport function tuple<A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Arbitrary<A[K]> }\n): Arbitrary<A> {\n  if (components.length === 0) {\n    return fc.constant([]) as any\n  }\n  return (fc.tuple as any)(...components)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 75,
        "to": 82
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\nexport function intersection<A, B>(left: Arbitrary<A>, right: Arbitrary<B>): Arbitrary<A & B> {\n  return fc.tuple(left, right).map(([a, b]) => intersect(a, b))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 84,
        "to": 86
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\nexport function sum<T extends string>(\n  _tag: T\n): <A>(members: { [K in keyof A]: Arbitrary<A[K]> }) => Arbitrary<A[keyof A]> {\n  return (members: Record<string, Arbitrary<any>>) => fc.oneof(...Object.keys(members).map((k) => members[k]))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "_tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 88,
        "to": 92
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\nexport function lazy<A>(f: () => Arbitrary<A>): Arbitrary<A> {\n  const get = S.memoize<void, Arbitrary<A>>(f)\n  return fc.constant(null).chain(() => get())\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 94,
        "to": 97
      }
    }
  },
  {
    "name": "union",
    "text": "\n\nexport function union<A extends ReadonlyArray<unknown>>(\n  ...members: { [K in keyof A]: Arbitrary<A[K]> }\n): Arbitrary<A[number]> {\n  return fc.oneof(...members)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 99,
        "to": 103
      }
    }
  },
  {
    "name": "interfaceWithOptionals",
    "text": " // OK!\n\n// ----------------\n\nexport function interfaceWithOptionals<RequiredProps extends t.Props, OptionalProps extends t.Props>(\n  required: RequiredProps,\n  optional: OptionalProps,\n  name?: string\n): t.IntersectionC<[t.TypeC<RequiredProps>, t.PartialC<OptionalProps>]> {\n  return t.intersection([t.type(required), t.partial(optional)], name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "required",
          "type": {
            "__tag": "Other",
            "values": "RequiredProps"
          }
        },
        {
          "name": "optional",
          "type": {
            "__tag": "Other",
            "values": "OptionalProps"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<RequiredProps>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialC<OptionalProps>]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 515,
        "to": 521
      }
    }
  },
  {
    "name": "maybe",
    "text": "\n\n// ----------------\n\nexport function maybe<RT extends t.Any>(\n  type: RT,\n  name?: string\n): t.UnionType<[RT, t.NullType], t.TypeOf<RT> | null, t.OutputOf<RT> | null, t.InputOf<RT> | null> {\n  return t.union<[RT, t.NullType]>([type, t.null], name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "type",
          "type": {
            "__tag": "Other",
            "values": "RT"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").UnionType<[RT, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").NullType], RT[\"_A\"], RT[\"_O\"], RT[\"_I\"]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 525,
        "to": 530
      }
    }
  },
  {
    "name": "assertStrictEqual",
    "text": "\n\nexport function assertStrictEqual<T>(result: t.Validation<T>, expected: any): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        assert.deepStrictEqual(a, expected)\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 7,
        "to": 20
      }
    }
  },
  {
    "name": "assertSuccess",
    "text": "\n\nexport function assertSuccess<T>(result: t.Validation<T>, expected?: T): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        if (expected !== undefined) {\n          assert.deepStrictEqual(a, expected)\n        }\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 22,
        "to": 37
      }
    }
  },
  {
    "name": "assertStrictSuccess",
    "text": "\n\nexport function assertStrictSuccess<T>(result: t.Validation<T>, expected: T): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        /* istanbul ignore next */\n        if (expected !== undefined) {\n          assert.strictEqual(a, expected)\n        }\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 39,
        "to": 55
      }
    }
  },
  {
    "name": "assertFailure",
    "text": "\n\nexport function assertFailure(codec: t.Any, value: unknown, errors: Array<string>): void {\n  const result = codec.decode(value)\n  pipe(\n    result,\n    fold(\n      () => {\n        assert.deepStrictEqual(PathReporter.report(result), errors)\n      },\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a left`)\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "string[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 57,
        "to": 71
      }
    }
  },
  {
    "name": "withDefault",
    "text": "\n\nexport function withDefault<T extends t.Mixed>(\n  type: T,\n  defaultValue: t.TypeOf<T>\n): t.Type<t.TypeOf<T>, t.TypeOf<T>, unknown> {\n  return new t.Type(\n    `withDefault(${type.name}, ${JSON.stringify(defaultValue)})`,\n    type.is,\n    (v) => type.decode(v != null ? v : defaultValue),\n    type.encode\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "type",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        },
        {
          "name": "defaultValue",
          "type": {
            "__tag": "Other",
            "values": "T[\"_A\"]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<T[\"_A\"], T[\"_A\"], unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 101,
        "to": 111
      }
    }
  },
  {
    "name": "strictInterfaceWithOptionals",
    "text": "\n\nexport function strictInterfaceWithOptionals<R extends t.Props, O extends t.Props>(\n  required: R,\n  optional: O,\n  name?: string\n): t.Type<t.TypeOfProps<R> & t.TypeOfPartialProps<O>, t.OutputOfProps<R> & t.OutputOfPartialProps<O>> {\n  return t.exact(t.intersection([t.type(required), t.partial(optional)]), name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "required",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        },
        {
          "name": "optional",
          "type": {
            "__tag": "Other",
            "values": "O"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeOfProps<R> & import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeOfPartialProps<O>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").OutputOfProps<R> & import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").OutputOfPartialProps<O>, unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/strictInterfaceWithOptionals.ts",
      "lines": {
        "from": 5,
        "to": 11
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n\n/**\n * Like `Functor`, `Applicative`s compose. If `F` and `G` have `Applicative` instances, then so does `F<G<_>>`\n *\n * @example\n * import { getApplicativeComposition } from 'fp-ts/lib/Applicative'\n * import { option, Option, some } from 'fp-ts/lib/Option'\n * import { task, Task } from 'fp-ts/lib/Task'\n *\n * // an Applicative instance for Task<Option<A>>\n * const A = getApplicativeComposition(task, option)\n *\n * const x: Task<Option<number>> = task.of(some(1))\n * const y: Task<Option<number>> = task.of(some(2))\n *\n * const sum = (a: number) => (b: number): number => a + b\n *\n * A.ap(A.map(x, sum), y)()\n *   .then(result => assert.deepStrictEqual(result, some(3)))\n *\n * @since 2.0.0\n */\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>",
    "docs": "/**\n * Like `Functor`, `Applicative`s compose. If `F` and `G` have `Applicative` instances, then so does `F<G<_>>`\n *\n * @example\n * import { getApplicativeComposition } from 'fp-ts/lib/Applicative'\n * import { option, Option, some } from 'fp-ts/lib/Option'\n * import { task, Task } from 'fp-ts/lib/Task'\n *\n * // an Applicative instance for Task<Option<A>>\n * const A = getApplicativeComposition(task, option)\n *\n * const x: Task<Option<number>> = task.of(some(1))\n * const y: Task<Option<number>> = task.of(some(2))\n *\n * const sum = (a: number) => (b: number): number => a + b\n *\n * A.ap(A.map(x, sum), y)()\n *   .then(result => assert.deepStrictEqual(result, some(3)))\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 214,
        "to": 217
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2>(\n  F: Applicative2<F>,\n  G: Applicative2<G>\n): ApplicativeComposition22<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 218,
        "to": 221
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 222,
        "to": 225
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS2, G extends URIS>(\n  F: Applicative2<F>,\n  G: Applicative1<G>\n): ApplicativeComposition21<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 226,
        "to": 229
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS, G extends URIS2>(\n  F: Applicative1<F>,\n  G: Applicative2<G>\n): ApplicativeComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 230,
        "to": 233
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS, G extends URIS2, E>(\n  F: Applicative1<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition12C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 234,
        "to": 237
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F extends URIS, G extends URIS>(\n  F: Applicative1<F>,\n  G: Applicative1<G>\n): ApplicativeComposition11<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 238,
        "to": 241
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F, G extends URIS2>(\n  F: Applicative<F>,\n  G: Applicative2<G>\n): ApplicativeCompositionHKT2<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT2<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 242,
        "to": 245
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F, G extends URIS2, E>(\n  F: Applicative<F>,\n  G: Applicative2C<G, E>\n): ApplicativeCompositionHKT2C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT2C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 246,
        "to": 249
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F, G extends URIS>(\n  F: Applicative<F>,\n  G: Applicative1<G>\n): ApplicativeCompositionHKT1<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT1<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 250,
        "to": 253
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F, G>(F: Applicative<F>, G: Applicative<G>): ApplicativeComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 254,
        "to": 254
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\nexport function getApplicativeComposition<F, G>(F: Applicative<F>, G: Applicative<G>): ApplicativeComposition<F, G> {\n  return {\n    map: getFunctorComposition(F, G).map,\n    of: (a) => F.of(G.of(a)),\n    ap: <A, B>(fgab: HKT<F, HKT<G, (a: A) => B>>, fga: HKT<F, HKT<G, A>>): HKT<F, HKT<G, B>> =>\n      F.ap(\n        F.map(fgab, (h) => (ga: HKT<G, A>) => G.ap<A, B>(h, ga)),\n        fga\n      )\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 255,
        "to": 265
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\n\n/* tslint:disable:readonly-array */\n/**\n * Tuple sequencing, i.e., take a tuple of monadic actions and does them from left-to-right, returning the resulting tuple.\n *\n * @example\n * import { sequenceT } from 'fp-ts/lib/Apply'\n * import { option, some, none } from 'fp-ts/lib/Option'\n *\n * const sequenceTOption = sequenceT(option)\n * assert.deepStrictEqual(sequenceTOption(some(1)), some([1]))\n * assert.deepStrictEqual(sequenceTOption(some(1), some('2')), some([1, '2']))\n * assert.deepStrictEqual(sequenceTOption(some(1), some('2'), none), none)\n *\n * @since 2.0.0\n */\nexport function sequenceT<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, T extends Array<Kind4<F, S, R, E, any>>>(\n  ...t: T & { readonly 0: Kind4<F, S, R, E, any> }\n) => Kind4<F, S, R, E, { [K in keyof T]: [T[K]] extends [Kind4<F, S, R, E, infer A>] ? A : never }>",
    "docs": "/**\n * Tuple sequencing, i.e., take a tuple of monadic actions and does them from left-to-right, returning the resulting tuple.\n *\n * @example\n * import { sequenceT } from 'fp-ts/lib/Apply'\n * import { option, some, none } from 'fp-ts/lib/Option'\n *\n * const sequenceTOption = sequenceT(option)\n * assert.deepStrictEqual(sequenceTOption(some(1)), some([1]))\n * assert.deepStrictEqual(sequenceTOption(some(1), some('2')), some([1, '2']))\n * assert.deepStrictEqual(sequenceTOption(some(1), some('2'), none), none)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 129,
        "to": 133
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS3>(\n  F: Apply3<F>\n): <R, E, T extends Array<Kind3<F, R, E, any>>>(\n  ...t: T & { readonly 0: Kind3<F, R, E, any> }\n) => Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 134,
        "to": 138
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <R, T extends Array<Kind3<F, R, E, any>>>(\n  ...t: T & { readonly 0: Kind3<F, R, E, any> }\n) => Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 139,
        "to": 143
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS2>(\n  F: Apply2<F>\n): <E, T extends Array<Kind2<F, E, any>>>(\n  ...t: T & { readonly 0: Kind2<F, E, any> }\n) => Kind2<F, E, { [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 144,
        "to": 148
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <T extends Array<Kind2<F, E, any>>>(\n  ...t: T & { readonly 0: Kind2<F, E, any> }\n) => Kind2<F, E, { [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 149,
        "to": 153
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS>(\n  F: Apply1<F>\n): <T extends Array<Kind<F, any>>>(\n  ...t: T & { readonly 0: Kind<F, any> }\n) => Kind<F, { [K in keyof T]: [T[K]] extends [Kind<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 154,
        "to": 158
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F>(\n  F: Apply<F>\n): <T extends Array<HKT<F, any>>>(\n  ...t: T & { readonly 0: HKT<F, any> }\n) => HKT<F, { [K in keyof T]: [T[K]] extends [HKT<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 159,
        "to": 163
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F>(F: Apply<F>): any {\n  return <A>(...args: Array<HKT<F, A>>) => {\n    const len = args.length\n    const f = getTupleConstructor(len)\n    let fas = F.map(args[0], f)\n    for (let i = 1; i < len; i++) {\n      fas = F.ap(fas, args[i])\n    }\n    return fas\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 164,
        "to": 174
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\n\n/* tslint:disable:readonly-array */\n/**\n * Like `Apply.sequenceT` but works with structs instead of tuples.\n *\n * @example\n * import { either, right, left } from 'fp-ts/lib/Either'\n * import { sequenceS } from 'fp-ts/lib/Apply'\n *\n * const ado = sequenceS(either)\n *\n * assert.deepStrictEqual(\n *   ado({\n *     a: right(1),\n *     b: right(true)\n *   }),\n *   right({ a: 1, b: true })\n * )\n * assert.deepStrictEqual(\n *   ado({\n *     a: right(1),\n *     b: left('error')\n *   }),\n *   left('error')\n * )\n *\n * @since 2.0.0\n */\nexport function sequenceS<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, NER extends Record<string, Kind4<F, S, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind4<F, S, R, E, any>>\n) => Kind4<F, S, R, E, { [K in keyof NER]: [NER[K]] extends [Kind4<F, any, any, any, infer A>] ? A : never }>",
    "docs": "/**\n * Like `Apply.sequenceT` but works with structs instead of tuples.\n *\n * @example\n * import { either, right, left } from 'fp-ts/lib/Either'\n * import { sequenceS } from 'fp-ts/lib/Apply'\n *\n * const ado = sequenceS(either)\n *\n * assert.deepStrictEqual(\n *   ado({\n *     a: right(1),\n *     b: right(true)\n *   }),\n *   right({ a: 1, b: true })\n * )\n * assert.deepStrictEqual(\n *   ado({\n *     a: right(1),\n *     b: left('error')\n *   }),\n *   left('error')\n * )\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, any, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 221,
        "to": 225
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS3>(\n  F: Apply3<F>\n): <R, E, NER extends Record<string, Kind3<F, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>\n) => Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 226,
        "to": 230
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <R, NER extends Record<string, Kind3<F, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>\n) => Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 231,
        "to": 235
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS2>(\n  F: Apply2<F>\n): <E, NER extends Record<string, Kind2<F, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind2<F, E, any>>\n) => Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 236,
        "to": 240
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <NER extends Record<string, Kind2<F, E, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 241,
        "to": 245
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS>(\n  F: Apply1<F>\n): <NER extends Record<string, Kind<F, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => Kind<F, { [K in keyof NER]: [NER[K]] extends [Kind<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 246,
        "to": 250
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F>(\n  F: Apply<F>\n): <NER extends Record<string, HKT<F, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => HKT<F, { [K in keyof NER]: [NER[K]] extends [HKT<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 251,
        "to": 255
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F>(F: Apply<F>): (r: Record<string, HKT<F, any>>) => HKT<F, Record<string, any>> {\n  return (r) => {\n    const keys = Object.keys(r)\n    const len = keys.length\n    const f = getRecordConstructor(keys)\n    let fr = F.map(r[keys[0]], f)\n    for (let i = 1; i < len; i++) {\n      fr = F.ap(fr, r[keys[i]])\n    }\n    return fr\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, any>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 256,
        "to": 267
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\n/* tslint:enable:readonly-array */\n\n/**\n * @internal\n */\nexport function apComposition<F extends URIS2, G extends URIS2>(\n  F: Apply2<F>,\n  G: Apply2<G>\n): <EF, EG, A>(\n  fga: Kind2<F, EF, Kind2<G, EG, A>>\n) => <B>(fgab: Kind2<F, EF, Kind2<G, EG, (a: A) => B>>) => Kind2<F, EF, Kind2<G, EG, B>>",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<EF, EG, A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 273,
        "to": 278
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F extends URIS2, G extends URIS2, EG>(\n  F: Apply2<F>,\n  G: Apply2C<G, EG>\n): <EF, A>(\n  fga: Kind2<F, EF, Kind2<G, EG, A>>\n) => <B>(fgab: Kind2<F, EF, Kind2<G, EG, (a: A) => B>>) => Kind2<F, EF, Kind2<G, EG, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<G, EG>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<EF, A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, EF, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, EG, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 279,
        "to": 284
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F extends URIS, G extends URIS2>(\n  F: Apply1<F>,\n  G: Apply2<G>\n): <E, A>(fga: Kind<F, Kind2<G, E, A>>) => <B>(fgab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 285,
        "to": 288
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F extends URIS, G extends URIS2, E>(\n  F: Apply1<F>,\n  G: Apply2C<G, E>\n): <A>(fga: Kind<F, Kind2<G, E, A>>) => <B>(fgab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 289,
        "to": 292
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F extends URIS, G extends URIS>(\n  F: Apply1<F>,\n  G: Apply1<G>\n): <A>(fga: Kind<F, Kind<G, A>>) => <B>(fgab: Kind<F, Kind<G, (a: A) => B>>) => Kind<F, Kind<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 293,
        "to": 296
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F, G extends URIS2>(\n  F: Apply<F>,\n  G: Apply2<G>\n): <E, A>(fga: HKT<F, Kind2<G, E, A>>) => <B>(fgab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 297,
        "to": 300
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F, G>(\n  F: Apply<F>,\n  G: Apply<G>\n): <A>(fga: HKT<F, HKT<G, A>>) => <B>(fgab: HKT<F, HKT<G, (a: A) => B>>) => HKT<F, HKT<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 301,
        "to": 304
      }
    }
  },
  {
    "name": "apComposition",
    "text": "\nexport function apComposition<F, G>(\n  F: Apply<F>,\n  G: Apply<G>\n): <A>(fga: HKT<F, HKT<G, A>>) => <B>(fgab: HKT<F, HKT<G, (a: A) => B>>) => HKT<F, HKT<G, B>> {\n  return <A>(fga: HKT<F, HKT<G, A>>) => <B>(fgab: HKT<F, HKT<G, (a: A) => B>>): HKT<F, HKT<G, B>> =>\n    F.ap(\n      F.map(fgab, (h) => (ga: HKT<G, A>) => G.ap<A, B>(h, ga)),\n      fga\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => <B>(fgab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 305,
        "to": 314
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Array<B>",
    "docs": "/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 377,
        "to": 377
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 378,
        "to": 378
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A> {\n  return RA.takeLeftWhile(predicate) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 379,
        "to": 381
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\n\n/* tslint:disable:readonly-keyword */\n/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function spanLeft<A, B extends A>(\n  refinement: Refinement<A, B>\n): (as: Array<A>) => { init: Array<B>; rest: Array<A> }",
    "docs": "/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => { init: B[]; rest: A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 397,
        "to": 399
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: Array<A>) => { init: Array<A>; rest: Array<A> }",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => { init: A[]; rest: A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 400,
        "to": 400
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: Array<A>) => { init: Array<A>; rest: Array<A> } {\n  return RA.spanLeft(predicate) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => { init: A[]; rest: A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 401,
        "to": 403
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\n\n/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/lib/Array'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findFirst((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option<B>",
    "docs": "/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/lib/Array'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findFirst((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 471,
        "to": 471
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 472,
        "to": 472
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A> {\n  return RA.findFirst(predicate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 473,
        "to": 475
      }
    }
  },
  {
    "name": "findLast",
    "text": "\n\n/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/lib/Array'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findLast((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option<B>",
    "docs": "/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/lib/Array'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findLast((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 511,
        "to": 511
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 512,
        "to": 512
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A> {\n  return RA.findLast(predicate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 513,
        "to": 515
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\n\n/**\n * Array comprehension\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/lib/Array'\n * import { tuple } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @since 2.0.0\n */\nexport function comprehension<A, B, C, D, R>(\n  input: [Array<A>, Array<B>, Array<C>, Array<D>],\n  f: (a: A, b: B, c: C, d: D) => R,\n  g?: (a: A, b: B, c: C, d: D) => boolean\n): Array<R>",
    "docs": "/**\n * Array comprehension\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/lib/Array'\n * import { tuple } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[], C[], D[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 882,
        "to": 886
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, C, R>(\n  input: [Array<A>, Array<B>, Array<C>],\n  f: (a: A, b: B, c: C) => R,\n  g?: (a: A, b: B, c: C) => boolean\n): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[], C[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 887,
        "to": 891
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(input: [Array<A>], f: (a: A) => R, g?: (a: A) => boolean): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 892,
        "to": 892
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, R>(\n  input: [Array<A>, Array<B>],\n  f: (a: A, b: B) => R,\n  g?: (a: A, b: B) => boolean\n): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 893,
        "to": 897
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(input: [Array<A>], f: (a: A) => boolean, g?: (a: A) => R): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 898,
        "to": 898
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<R>(\n  input: Array<Array<any>>,\n  f: (...xs: Array<any>) => R,\n  g: (...xs: Array<any>) => boolean = () => true\n): Array<R> {\n  return RA.comprehension(input as any, f, g) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "any[][]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...xs: any[]) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(...xs: any[]) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 899,
        "to": 905
      }
    }
  },
  {
    "name": "fold",
    "text": "/**\n * @since 2.2.0\n */\n\n/**\n * Defines the fold over a boolean value.\n * Takes two thunks `onTrue`, `onFalse` and a `boolean` value.\n * If `value` is false, `onFalse()` is returned, otherwise `onTrue()`.\n *\n * @example\n * import { some, map } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n * import { fold } from 'fp-ts/lib/boolean'\n *\n * assert.deepStrictEqual(\n *  pipe(\n *    some(true),\n *    map(fold(() => 'false', () => 'true'))\n *  ),\n *  some('true')\n * )\n *\n * @category destructors\n * @since 2.2.0\n */\nexport function fold<A>(onFalse: () => A, onTrue: () => A): (value: boolean) => A {\n  return (value) => (value ? onTrue() : onFalse())\n}",
    "docs": "/**\n * @since 2.2.0\n *//**\n * Defines the fold over a boolean value.\n * Takes two thunks `onTrue`, `onFalse` and a `boolean` value.\n * If `value` is false, `onFalse()` is returned, otherwise `onTrue()`.\n *\n * @example\n * import { some, map } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n * import { fold } from 'fp-ts/lib/boolean'\n *\n * assert.deepStrictEqual(\n *  pipe(\n *    some(true),\n *    map(fold(() => 'false', () => 'true'))\n *  ),\n *  some('true')\n * )\n *\n * @category destructors\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        },
        {
          "name": "onTrue",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(value: boolean) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/boolean.ts",
      "lines": {
        "from": 26,
        "to": 28
      }
    }
  },
  {
    "name": "getFunctionBooleanAlgebra",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionBooleanAlgebra<B>(B: BooleanAlgebra<B>): <A = never>() => BooleanAlgebra<(a: A) => B> {\n  return () => ({\n    meet: (x, y) => (a) => B.meet(x(a), y(a)),\n    join: (x, y) => (a) => B.join(x(a), y(a)),\n    zero: () => B.zero,\n    one: () => B.one,\n    implies: (x, y) => (a) => B.implies(x(a), y(a)),\n    not: (x) => (a) => B.not(x(a))\n  })\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/BooleanAlgebra.ts",
      "lines": {
        "from": 51,
        "to": 60
      }
    }
  },
  {
    "name": "getDualBooleanAlgebra",
    "text": "\n\n/**\n * Every boolean algebras has a dual algebra, which involves reversing one/zero as well as join/meet.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualBooleanAlgebra<A>(B: BooleanAlgebra<A>): BooleanAlgebra<A> {\n  return {\n    meet: (x, y) => B.join(x, y),\n    join: (x, y) => B.meet(x, y),\n    zero: B.one,\n    one: B.zero,\n    implies: (x, y) => B.join(B.not(x), y),\n    not: B.not\n  }\n}",
    "docs": "/**\n * Every boolean algebras has a dual algebra, which involves reversing one/zero as well as join/meet.\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/BooleanAlgebra.ts",
      "lines": {
        "from": 68,
        "to": 77
      }
    }
  },
  {
    "name": "getMinMaxBoundedDistributiveLattice",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMinMaxBoundedDistributiveLattice<A>(O: Ord<A>): (min: A, max: A) => BoundedDistributiveLattice<A> {\n  const L = getMinMaxDistributiveLattice(O)\n  return (min, max) => ({\n    join: L.join,\n    meet: L.meet,\n    zero: min,\n    one: max\n  })\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(min: A, max: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BoundedDistributiveLattice\").BoundedDistributiveLattice<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/BoundedDistributiveLattice.ts",
      "lines": {
        "from": 20,
        "to": 28
      }
    }
  },
  {
    "name": "tailRec",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function tailRec<A, B>(a: A, f: (a: A) => Either<A, B>): B {\n  let v = f(a)\n  while (v._tag === 'Left') {\n    v = f(v.left)\n  }\n  return v.right\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ChainRec.ts",
      "lines": {
        "from": 51,
        "to": 57
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\n\n/**\n * Compose a value acting on a sum from two values, each acting on one of\n * the components of the sum.\n *\n * Specializing `(+++)` to function application would look like this:\n *\n * ```purescript\n * (+++) :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which\n * takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like\n * `bi-map` would do for the `bi-functor` instance of `Either`.\n *\n * @since 2.0.0\n */\nexport function splitChoice<F extends URIS3>(\n  F: Category3<F> & Choice3<F>\n): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, Either<A, C>, Either<B, D>>",
    "docs": "/**\n * Compose a value acting on a sum from two values, each acting on one of\n * the components of the sum.\n *\n * Specializing `(+++)` to function application would look like this:\n *\n * ```purescript\n * (+++) :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which\n * takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like\n * `bi-map` would do for the `bi-functor` instance of `Either`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\nexport function splitChoice<F extends URIS2>(\n  F: Category2<F> & Choice2<F>\n): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, Either<A, C>, Either<B, D>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\nexport function splitChoice<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, Either<A, C>, Either<B, D>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\nexport function splitChoice<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, Either<A, C>, Either<B, D>> {\n  return (pab, pcd) => F.compose(F.left(pab), F.right(pcd))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 98,
        "to": 102
      }
    }
  },
  {
    "name": "fanin",
    "text": "\n\n/**\n * Compose a value which eliminates a sum from two values, each eliminating\n * one side of the sum.\n *\n * This combinator is useful when assembling values from smaller components,\n * because it provides a way to support two different types of input.\n *\n * Specializing `(|||)` to function application would look like this:\n *\n * ```purescript\n * (|||) :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n * ```\n *\n * We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a\n * single function which takes an `Either` value with the parameter type of `f` on the left side and\n * the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on\n * whether the `Either` value is a `Left` or a `Right`.\n * This allows us to bundle two different computations which both have the same result type into one\n * function which will run the appropriate computation based on the parameter supplied in the `Either` value.\n *\n * @since 2.0.0\n */\nexport function fanin<F extends URIS3>(\n  F: Category3<F> & Choice3<F>\n): <R, A, B, C>(pac: Kind3<F, R, A, C>, pbc: Kind3<F, R, B, C>) => Kind3<F, R, Either<A, B>, C>",
    "docs": "/**\n * Compose a value which eliminates a sum from two values, each eliminating\n * one side of the sum.\n *\n * This combinator is useful when assembling values from smaller components,\n * because it provides a way to support two different types of input.\n *\n * Specializing `(|||)` to function application would look like this:\n *\n * ```purescript\n * (|||) :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n * ```\n *\n * We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a\n * single function which takes an `Either` value with the parameter type of `f` on the left side and\n * the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on\n * whether the `Either` value is a `Left` or a `Right`.\n * This allows us to bundle two different computations which both have the same result type into one\n * function which will run the appropriate computation based on the parameter supplied in the `Either` value.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 126,
        "to": 128
      }
    }
  },
  {
    "name": "fanin",
    "text": "\nexport function fanin<F extends URIS2>(\n  F: Category2<F> & Choice2<F>\n): <A, B, C>(pac: Kind2<F, A, C>, pbc: Kind2<F, B, C>) => Kind2<F, Either<A, B>, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 129,
        "to": 131
      }
    }
  },
  {
    "name": "fanin",
    "text": "\nexport function fanin<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 132,
        "to": 134
      }
    }
  },
  {
    "name": "fanin",
    "text": "\nexport function fanin<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, C> {\n  const splitChoiceF = splitChoice(F)\n  return <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>): HKT2<F, Either<A, B>, C> => {\n    const join: HKT2<F, Either<C, C>, C> = F.promap(F.id<C>(), (e) => (e._tag === 'Left' ? e.left : e.right), identity)\n    return F.compose(join, splitChoiceF(pac, pbc))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 135,
        "to": 143
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getCompactableComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Compactable3C<G, E> & Functor3C<G, E>\n): CompactableComposition23C<F, G, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 222,
        "to": 225
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition22C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 226,
        "to": 229
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition22<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 230,
        "to": 233
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition2C1<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 234,
        "to": 237
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition21<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 238,
        "to": 241
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 242,
        "to": 245
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 246,
        "to": 249
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition11<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 250,
        "to": 253
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F, G>(\n  F: Functor<F>,\n  G: Compactable<G> & Functor<G>\n): CompactableComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 254,
        "to": 257
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\nexport function getCompactableComposition<F, G>(\n  F: Functor<F>,\n  G: Compactable<G> & Functor<G>\n): CompactableComposition<F, G> {\n  const FC = getFunctorComposition(F, G)\n  const CC: CompactableComposition<F, G> = {\n    map: FC.map,\n    compact: (fga) => F.map(fga, G.compact),\n    separate: (fge) => {\n      const left = CC.compact(FC.map(fge, getLeft))\n      const right = CC.compact(FC.map(fge, getRight))\n      return { left, right }\n    }\n  }\n  return CC\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 258,
        "to": 273
      }
    }
  },
  {
    "name": "log",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function log(s: unknown): IO<void> {\n  return () => console.log(s) // tslint:disable-line:no-console\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 9,
        "to": 11
      }
    }
  },
  {
    "name": "warn",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function warn(s: unknown): IO<void> {\n  return () => console.warn(s) // tslint:disable-line:no-console\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 16,
        "to": 18
      }
    }
  },
  {
    "name": "error",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function error(s: unknown): IO<void> {\n  return () => console.error(s) // tslint:disable-line:no-console\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "info",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function info(s: unknown): IO<void> {\n  return () => console.info(s) // tslint:disable-line:no-console\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 30,
        "to": 32
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(S: Show<E>): Show<Const<E, A>> {\n  return {\n    show: (c) => `make(${S.show(c)})`\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 47,
        "to": 51
      }
    }
  },
  {
    "name": "getApply",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply<E>(S: Semigroup<E>): Apply2C<URI, E> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: (fab, fa) => make(S.concat(fab, fa))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"Const\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 111,
        "to": 118
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative<E>(M: Monoid<E>): Applicative2C<URI, E> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    of: () => make(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"Const\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 124,
        "to": 133
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Const<E, A>) => Const<E, B> = (f) => (fa) => contramap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 151,
        "to": 151
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Const<E, A>) => Const<E, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 160,
        "to": 160
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Const<E, A>) => Const<G, B> = (f, g) => (fa) =>\n  bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 168,
        "to": 169
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Const<E, A>) => Const<G, A> = (f) => (fa) => mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 177,
        "to": 177
      }
    }
  },
  {
    "name": "create",
    "text": "const create: IO<Date> = () => new Date()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "Date"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Date.ts",
      "lines": {
        "from": 13,
        "to": 13
      }
    }
  },
  {
    "name": "now",
    "text": "const now: IO<number> = () => new Date().getTime()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Date.ts",
      "lines": {
        "from": 20,
        "to": 20
      }
    }
  },
  {
    "name": "getMinMaxDistributiveLattice",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMinMaxDistributiveLattice<A>(O: Ord<A>): DistributiveLattice<A> {\n  return {\n    meet: min(O),\n    join: max(O)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/DistributiveLattice\").DistributiveLattice<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/DistributiveLattice.ts",
      "lines": {
        "from": 22,
        "to": 27
      }
    }
  },
  {
    "name": "isLeft",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isLeft<E, A>(ma: Either<E, A>): ma is Left<E> {\n  switch (ma._tag) {\n    case 'Left':\n      return true\n    case 'Right':\n      return false\n  }\n}",
    "docs": "/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 74,
        "to": 81
      }
    }
  },
  {
    "name": "isRight",
    "text": "\n\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isRight<E, A>(ma: Either<E, A>): ma is Right<A> {\n  return isLeft(ma) ? false : true\n}",
    "docs": "/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function left<E = never, A = never>(e: E): Either<E, A> {\n  return { _tag: 'Left', left: e }\n}",
    "docs": "/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 104,
        "to": 106
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function right<E = never, A = never>(a: A): Either<E, A> {\n  return { _tag: 'Right', right: a }\n}",
    "docs": "/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 115,
        "to": 117
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/lib/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable<E>(e: E): <A>(a: A) => Either<E, NonNullable<A>> {\n  return <A>(a: A) => (a == null ? left(e) : right(a as NonNullable<A>))\n}",
    "docs": "/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/lib/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, NonNullable<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 134,
        "to": 136
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch } from 'fp-ts/lib/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch<E, A>(f: Lazy<A>, onError: (e: unknown) => E): Either<E, A> {\n  try {\n    return right(f())\n  } catch (e) {\n    return left(onError(e))\n  }\n}",
    "docs": "/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch } from 'fp-ts/lib/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(e: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 162,
        "to": 168
      }
    }
  },
  {
    "name": "parseJSON",
    "text": "\n\n/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError, right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError), right({ a: 1 }))\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError), left(new SyntaxError('Unexpected token } in JSON at position 5')))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function parseJSON<E>(s: string, onError: (reason: unknown) => E): Either<E, unknown> {\n  return tryCatch(() => JSON.parse(s), onError)\n}",
    "docs": "/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError, right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError), right({ a: 1 }))\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError), left(new SyntaxError('Unexpected token } in JSON at position 5')))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, unknown>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 182,
        "to": 184
      }
    }
  },
  {
    "name": "stringifyJSON",
    "text": "\n\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/lib/Either'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(E.stringifyJSON({ a: 1 }, E.toError), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     E.stringifyJSON(circular, E.toError),\n *     E.mapLeft(e => e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function stringifyJSON<E>(u: unknown, onError: (reason: unknown) => E): Either<E, string> {\n  return tryCatch(() => JSON.stringify(u), onError)\n}",
    "docs": "/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/lib/Either'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(E.stringifyJSON({ a: 1 }, E.toError), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     E.stringifyJSON(circular, E.toError),\n *     E.mapLeft(e => e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "u",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, string>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 207,
        "to": 209
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { fold, left, right } from 'fp-ts/lib/Either'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     fold(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     fold(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold<E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B): (ma: Either<E, A>) => B {\n  return (ma) => (isLeft(ma) ? onLeft(ma.left) : onRight(ma.right))\n}",
    "docs": "/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { fold, left, right } from 'fp-ts/lib/Either'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     fold(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     fold(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        },
        {
          "name": "onRight",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 265,
        "to": 267
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function swap<E, A>(ma: Either<E, A>): Either<A, E> {\n  return isLeft(ma) ? right(ma.left) : left(ma.right)\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 292,
        "to": 294
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function orElse<E, A, M>(onLeft: (e: E) => Either<M, A>): (ma: Either<E, A>) => Either<M, A> {\n  return (ma) => (isLeft(ma) ? onLeft(ma.left) : ma)\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 300,
        "to": 302
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(SE: Show<E>, SA: Show<A>): Show<Either<E, A>> {\n  return {\n    show: (ma) => (isLeft(ma) ? `left(${SE.show(ma.left)})` : `right(${SA.show(ma.right)})`)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 544,
        "to": 548
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<E, A>(EL: Eq<E>, EA: Eq<A>): Eq<Either<E, A>> {\n  return {\n    equals: (x, y) =>\n      x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EL",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 554,
        "to": 559
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(S: Semigroup<A>): Semigroup<Either<E, A>> {\n  return {\n    concat: (x, y) => (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right)))\n  }\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 578,
        "to": 582
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<E, A>(S: Semigroup<A>): Semigroup<Either<E, A>> {\n  return {\n    concat: (x, y) => (isLeft(x) ? x : isLeft(y) ? y : right(S.concat(x.right, y.right)))\n  }\n}",
    "docs": "/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 601,
        "to": 605
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<E, A>(M: Monoid<A>): Monoid<Either<E, A>> {\n  return {\n    concat: getApplySemigroup<E, A>(M).concat,\n    empty: right(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 611,
        "to": 616
      }
    }
  },
  {
    "name": "getWitherable",
    "text": "\n\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getWitherable<E>(M: Monoid<E>): Witherable2C<URI, E> {\n  const empty = left(M.empty)\n\n  const compact = <A>(ma: Either<E, Option<A>>): Either<E, A> => {\n    return isLeft(ma) ? ma : ma.right._tag === 'None' ? left(M.empty) : right(ma.right.value)\n  }\n\n  const separate = <A, B>(ma: Either<E, Either<A, B>>): Separated<Either<E, A>, Either<E, B>> => {\n    return isLeft(ma)\n      ? { left: ma, right: ma }\n      : isLeft(ma.right)\n      ? { left: right(ma.right.left), right: empty }\n      : { left: empty, right: right(ma.right.right) }\n  }\n\n  const partitionMap = <A, B, C>(\n    ma: Either<E, A>,\n    f: (a: A) => Either<B, C>\n  ): Separated<Either<E, B>, Either<E, C>> => {\n    if (isLeft(ma)) {\n      return { left: ma, right: ma }\n    }\n    const e = f(ma.right)\n    return isLeft(e) ? { left: right(e.left), right: empty } : { left: empty, right: right(e.right) }\n  }\n\n  const partition = <A>(ma: Either<E, A>, p: Predicate<A>): Separated<Either<E, A>, Either<E, A>> => {\n    return isLeft(ma)\n      ? { left: ma, right: ma }\n      : p(ma.right)\n      ? { left: empty, right: right(ma.right) }\n      : { left: right(ma.right), right: empty }\n  }\n\n  const filterMap = <A, B>(ma: Either<E, A>, f: (a: A) => Option<B>): Either<E, B> => {\n    if (isLeft(ma)) {\n      return ma\n    }\n    const ob = f(ma.right)\n    return ob._tag === 'None' ? left(M.empty) : right(ob.value)\n  }\n\n  const filter = <A>(ma: Either<E, A>, predicate: Predicate<A>): Either<E, A> =>\n    isLeft(ma) ? ma : predicate(ma.right) ? ma : left(M.empty)\n\n  const wither = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ma: Either<E, A>, f: (a: A) => HKT<F, Option<B>>) => HKT<F, Either<E, B>>) => {\n    const traverseF = traverse_(F)\n    return (ma, f) => F.map(traverseF(ma, f), compact)\n  }\n\n  const wilt = <F>(\n    F: Applicative<F>\n  ): (<A, B, C>(\n    ma: Either<E, A>,\n    f: (a: A) => HKT<F, Either<B, C>>\n  ) => HKT<F, Separated<Either<E, B>, Either<E, C>>>) => {\n    const traverseF = traverse_(F)\n    return (ma, f) => F.map(traverseF(ma, f), separate)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    compact,\n    separate,\n    filter,\n    filterMap,\n    partition,\n    partitionMap,\n    traverse: traverse_,\n    sequence,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    wither,\n    wilt\n  }\n}",
    "docs": "/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Witherable\").Witherable2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 624,
        "to": 704
      }
    }
  },
  {
    "name": "getValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidation<E>(\n  S: Semigroup<E>\n): Monad2C<URI, E> &\n  Foldable2<URI> &\n  Traversable2<URI> &\n  Bifunctor2<URI> &\n  Alt2C<URI, E> &\n  Extend2<URI> &\n  ChainRec2C<URI, E> &\n  MonadThrow2C<URI, E> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    of,\n    chain: chain_,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    extend: extend_,\n    traverse: traverse_,\n    sequence,\n    chainRec: chainRec_,\n    throwError: throwError_,\n    ap: (mab, ma) =>\n      isLeft(mab)\n        ? isLeft(ma)\n          ? left(S.concat(mab.left, ma.left))\n          : mab\n        : isLeft(ma)\n        ? ma\n        : right(mab.right(ma.right)),\n    alt: (fx, f) => {\n      if (isRight(fx)) {\n        return fx\n      }\n      const fy = f()\n      return isLeft(fy) ? left(S.concat(fx.left, fy.left)) : fy\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ChainRec\").ChainRec2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 710,
        "to": 752
      }
    }
  },
  {
    "name": "getValidationSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidationSemigroup<E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<Either<E, A>> {\n  return {\n    concat: (fx, fy) =>\n      isLeft(fx)\n        ? isLeft(fy)\n          ? left(SE.concat(fx.left, fy.left))\n          : fx\n        : isLeft(fy)\n        ? fy\n        : right(SA.concat(fx.right, fy.right))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 758,
        "to": 769
      }
    }
  },
  {
    "name": "getValidationMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getValidationMonoid<E, A>(SE: Semigroup<E>, SA: Monoid<A>): Monoid<Either<E, A>> {\n  return {\n    concat: getValidationSemigroup(SE, SA).concat,\n    empty: right(SA.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 775,
        "to": 780
      }
    }
  },
  {
    "name": "toError",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e: unknown): Error {\n  return e instanceof Error ? e : new Error(String(e))\n}",
    "docs": "/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Error"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 821,
        "to": 823
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): <E>(a: A, ma: Either<E, A>) => boolean {\n  return (a, ma) => (isLeft(ma) ? false : E.equals(a, ma.right))\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(a: A, ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 828,
        "to": 830
      }
    }
  },
  {
    "name": "exists",
    "text": "\n\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/lib/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport function exists<A>(predicate: Predicate<A>): <E>(ma: Either<E, A>) => boolean {\n  return (ma) => (isLeft(ma) ? false : predicate(ma.right))\n}",
    "docs": "/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/lib/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 846,
        "to": 848
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <A>(ma: Option<A>) => Either<E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 215,
        "to": 216
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Either<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Either<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Right<A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Left<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 222,
        "to": 225
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <E, B>(onLeft: (e: E) => B) => <A>(ma: Either<E, A>): A | B =>\n  isLeft(ma) ? onLeft(ma.left) : ma.right",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B | A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 275,
        "to": 276
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (ma: Either<E, A>) =>\n  chain_(ma, (a) => (predicate(a) ? right(a) : left(onFalse(a))))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 308,
        "to": 312
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Either<E, A>) => Either<E, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 325,
        "to": 325
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Either<E, A>) => Either<G, B> = (f, g) => (\n  fa\n) => bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 333,
        "to": 335
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Either<E, A>) => Either<G, A> = (f) => (fa) => mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 343,
        "to": 343
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <E, A>(fa: Either<E, A>) => <B>(fab: Either<E, (a: A) => B>) => Either<E, B> = (fa) => (fab) =>\n  ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 351,
        "to": 352
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <E, B>(fb: Either<E, B>) => <A>(fa: Either<E, A>) => Either<E, A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 360,
        "to": 364
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: Either<E, B>) => <A>(fa: Either<E, A>): Either<E, B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 372,
        "to": 376
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW = <D, A, B>(f: (a: A) => Either<D, B>) => <E>(ma: Either<E, A>): Either<D | E, B> => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<D, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<D | E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 384,
        "to": 384
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Either<E, A>) => Either<E, A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 401,
        "to": 402
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <E, A>(mma: Either<E, Either<E, A>>) => Either<E, A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 408,
        "to": 408
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <E, A>(that: () => Either<E, A>) => (fa: Either<E, A>) => Either<E, A> = (that) => (fa) =>\n  alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 417,
        "to": 418
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <E, A>(ma: Either<E, A>) => Either<E, Either<E, A>> = (wa) => extend_(wa, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 424,
        "to": 424
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: Either<E, A>) => B) => (wa: Either<E, A>) => Either<E, B> = (f) => (ma) =>\n  extend_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 430,
        "to": 431
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Either<E, A>) => B = (b, f) => (fa) =>\n  reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 437,
        "to": 438
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Either<E, A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 444,
        "to": 447
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Either<E, A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 453,
        "to": 454
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <E>(ta: Either<E, A>) => HKT<F, Either<E, B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (fa) => traverseF(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 460,
        "to": 465
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <E, A>(\n  ma: Either<E, HKT<F, A>>\n): HKT<F, Either<E, A>> => {\n  return isLeft(ma) ? F.of(left(ma.left)) : F.map<A, Either<E, A>>(ma.right, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 471,
        "to": 475
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getEitherM<M extends URIS2>(M: Monad2<M>): EitherM2<M>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 97,
        "to": 97
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\nexport function getEitherM<M extends URIS>(M: Monad1<M>): EitherM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 98,
        "to": 98
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\nexport function getEitherM<M>(M: Monad<M>): EitherM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 99,
        "to": 99
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\nexport function getEitherM<M>(M: Monad<M>): EitherM<M> {\n  const ap = apComposition(M, E.applyEither)\n  const of = flow(E.right, M.of)\n\n  return {\n    map: (fa, f) => M.map(fa, E.map(f)),\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of,\n    chain: (ma, f) => M.chain(ma, (e) => (E.isLeft(e) ? M.of(E.left(e.left)) : f(e.right))),\n    alt: (fx, f) => M.chain(fx, (e) => (E.isLeft(e) ? f() : of(e.right))),\n    bimap: (ma, f, g) => M.map(ma, (e) => pipe(e, E.bimap(f, g))),\n    mapLeft: (ma, f) => M.map(ma, (e) => pipe(e, E.mapLeft(f))),\n    fold: (ma, onLeft, onRight) => M.chain(ma, E.fold(onLeft, onRight)),\n    getOrElse: (ma, onLeft) => M.chain(ma, E.fold(onLeft, M.of)),\n    orElse: (ma, f) =>\n      M.chain(\n        ma,\n        E.fold(f, (a) => of(a))\n      ),\n    swap: (ma) => M.map(ma, E.swap),\n    rightM: (ma) => M.map(ma, E.right),\n    leftM: (ml) => M.map(ml, E.left),\n    left: (e) => M.of(E.left(e))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 100,
        "to": 124
      }
    }
  },
  {
    "name": "fromEquals",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromEquals<A>(equals: (x: A, y: A) => boolean): Eq<A> {\n  return {\n    equals: (x, y) => x === y || equals(x, y)\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "equals",
          "type": {
            "__tag": "Other",
            "values": "(x: A, y: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 36,
        "to": 40
      }
    }
  },
  {
    "name": "strictEqual",
    "text": "\n\n/**\n * Use `eqStrict` instead\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function strictEqual<A>(a: A, b: A): boolean {\n  return a === b\n}",
    "docs": "/**\n * Use `eqStrict` instead\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 91,
        "to": 93
      }
    }
  },
  {
    "name": "getStructEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getStructEq<O extends ReadonlyRecord<string, any>>(eqs: { [K in keyof O]: Eq<O[K]> }): Eq<O> {\n  return fromEquals((x, y) => {\n    for (const k in eqs) {\n      if (!eqs[k].equals(x[k], y[k])) {\n        return false\n      }\n    }\n    return true\n  })\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "eqs",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof O]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<O[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<O>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 117,
        "to": 126
      }
    }
  },
  {
    "name": "getTupleEq",
    "text": "\n\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { getTupleEq, eqString, eqNumber, eqBoolean } from 'fp-ts/lib/Eq'\n *\n * const E = getTupleEq(eqString, eqNumber, eqBoolean)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleEq<T extends ReadonlyArray<Eq<any>>>(\n  ...eqs: T\n): Eq<{ [K in keyof T]: T[K] extends Eq<infer A> ? A : never }> {\n  return fromEquals((x, y) => eqs.every((E, i) => E.equals(x[i], y[i])))\n}",
    "docs": "/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { getTupleEq, eqString, eqNumber, eqBoolean } from 'fp-ts/lib/Eq'\n *\n * const E = getTupleEq(eqString, eqNumber, eqBoolean)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "eqs",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 143,
        "to": 147
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.6.0\n */\nexport function getMonoid<A>(): Monoid<Eq<A>> {\n  return {\n    concat: (x, y) => fromEquals((a, b) => x.equals(a, b) && y.equals(a, b)),\n    empty\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.6.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 165,
        "to": 170
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => (fa: Eq<A>) => Eq<B> = (f) => (fa) => contramap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "gcd",
    "text": "\n\n/**\n * The *greatest common divisor* of two values\n *\n * @since 2.0.0\n */\nexport function gcd<A>(E: Eq<A>, field: Field<A>): (x: A, y: A) => A {\n  const zero = field.zero\n  const f = (x: A, y: A): A => (E.equals(y, zero) ? x : f(y, field.mod(x, y)))\n  return f\n}",
    "docs": "/**\n * The *greatest common divisor* of two values\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        },
        {
          "name": "field",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Field\").Field<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Field.ts",
      "lines": {
        "from": 39,
        "to": 43
      }
    }
  },
  {
    "name": "lcm",
    "text": "\n\n/**\n * The *least common multiple* of two values\n *\n * @since 2.0.0\n */\nexport function lcm<A>(E: Eq<A>, F: Field<A>): (x: A, y: A) => A {\n  const zero = F.zero\n  const gcdSF = gcd(E, F)\n  return (x, y) => (E.equals(x, zero) || E.equals(y, zero) ? zero : F.div(F.mul(x, y), gcdSF(x, y)))\n}",
    "docs": "/**\n * The *least common multiple* of two values\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Field\").Field<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Field.ts",
      "lines": {
        "from": 50,
        "to": 54
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getFilterableComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Filterable3C<G, E>\n): FilterableComposition23C<F, G, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 450,
        "to": 453
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): FilterableComposition22C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 454,
        "to": 457
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Filterable2<G>\n): FilterableComposition22<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 458,
        "to": 461
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Filterable1<G>\n): FilterableComposition2C1<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 462,
        "to": 465
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Filterable1<G>\n): FilterableComposition21<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 466,
        "to": 469
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): FilterableComposition12C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 470,
        "to": 473
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Filterable2<G>\n): FilterableComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 474,
        "to": 477
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): FilterableComposition11<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 478,
        "to": 481
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F, G>(F: Functor<F>, G: Filterable<G>): FilterableComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 482,
        "to": 482
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\nexport function getFilterableComposition<F, G>(F: Functor<F>, G: Filterable<G>): FilterableComposition<F, G> {\n  const CC = getCompactableComposition(F, G)\n  const FC: FilterableComposition<F, G> = {\n    map: CC.map,\n    compact: CC.compact,\n    separate: CC.separate,\n    partitionMap: (fga, f) => {\n      const left = FC.filterMap(fga, (a) => getLeft(f(a)))\n      const right = FC.filterMap(fga, (a) => getRight(f(a)))\n      return { left, right }\n    },\n    partition: (fga, p) => {\n      const left = FC.filter(fga, (a) => !p(a))\n      const right = FC.filter(fga, p)\n      return { left, right }\n    },\n    filterMap: (fga, f) => F.map(fga, (ga) => G.filterMap(ga, f)),\n    filter: (fga, f) => F.map(fga, (ga) => G.filter(ga, f))\n  }\n  return FC\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 483,
        "to": 503
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n\n/**\n * Returns the composition of two foldables\n *\n * @example\n * import { getFoldableComposition } from 'fp-ts/lib/Foldable'\n * import { array } from 'fp-ts/lib/Array'\n * import { option, some, none } from 'fp-ts/lib/Option'\n * import { monoidString } from 'fp-ts/lib/Monoid'\n *\n * const F = getFoldableComposition(array, option)\n * assert.strictEqual(F.reduce([some('a'), some('b'), some('c')], '', monoidString.concat), 'abc')\n * assert.strictEqual(F.reduce([some('a'), none, some('c')], '', monoidString.concat), 'ac')\n *\n * @since 2.0.0\n */\nexport function getFoldableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Foldable2<F>,\n  G: Foldable2C<G, E>\n): FoldableComposition22C<F, G, E>",
    "docs": "/**\n * Returns the composition of two foldables\n *\n * @example\n * import { getFoldableComposition } from 'fp-ts/lib/Foldable'\n * import { array } from 'fp-ts/lib/Array'\n * import { option, some, none } from 'fp-ts/lib/Option'\n * import { monoidString } from 'fp-ts/lib/Monoid'\n *\n * const F = getFoldableComposition(array, option)\n * assert.strictEqual(F.reduce([some('a'), some('b'), some('c')], '', monoidString.concat), 'abc')\n * assert.strictEqual(F.reduce([some('a'), none, some('c')], '', monoidString.concat), 'ac')\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 176,
        "to": 179
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS2, G extends URIS2>(\n  F: Foldable2<F>,\n  G: Foldable2<G>\n): FoldableComposition22<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 180,
        "to": 183
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS2, G extends URIS, E>(\n  F: Foldable2C<F, E>,\n  G: Foldable1<G>\n): FoldableComposition2C1<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 184,
        "to": 187
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS2, G extends URIS>(\n  F: Foldable2<F>,\n  G: Foldable1<G>\n): FoldableComposition21<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 188,
        "to": 191
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS, G extends URIS2, E>(\n  F: Foldable1<F>,\n  G: Foldable2C<G, E>\n): FoldableComposition12C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 192,
        "to": 195
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS, G extends URIS2>(\n  F: Foldable1<F>,\n  G: Foldable2<G>\n): FoldableComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 196,
        "to": 199
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): FoldableComposition11<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 200,
        "to": 203
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F, G>(F: Foldable<F>, G: Foldable<G>): FoldableComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 204,
        "to": 204
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\nexport function getFoldableComposition<F, G>(F: Foldable<F>, G: Foldable<G>): FoldableComposition<F, G> {\n  return {\n    reduce: (fga, b, f) => F.reduce(fga, b, (b, ga) => G.reduce(ga, b, f)),\n    foldMap: (M) => {\n      const foldMapF = F.foldMap(M)\n      const foldMapG = G.foldMap(M)\n      return (fa, f) => foldMapF(fa, (ga) => foldMapG(ga, f))\n    },\n    reduceRight: (fa, b, f) => F.reduceRight(fa, b, (ga, b) => G.reduceRight(ga, b, f))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 205,
        "to": 215
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n\n/**\n * Similar to 'reduce', but the result is encapsulated in a monad.\n *\n * Note: this function is not generally stack-safe, e.g., for monads which build up thunks a la `IO`.\n *\n * @example\n * import { foldM } from 'fp-ts/lib/Foldable'\n * import { option, some } from 'fp-ts/lib/Option'\n * import { make, tree } from 'fp-ts/lib/Tree'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(foldM(option, tree)(t, 0, (b, a) => (a > 2 ? some(b + a) : some(b))), some(7))\n *\n * @since 2.0.0\n */\nexport function foldM<M extends URIS3, F extends URIS>(\n  M: Monad3<M>,\n  F: Foldable1<F>\n): <R, E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>",
    "docs": "/**\n * Similar to 'reduce', but the result is encapsulated in a monad.\n *\n * Note: this function is not generally stack-safe, e.g., for monads which build up thunks a la `IO`.\n *\n * @example\n * import { foldM } from 'fp-ts/lib/Foldable'\n * import { option, some } from 'fp-ts/lib/Option'\n * import { make, tree } from 'fp-ts/lib/Tree'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(foldM(option, tree)(t, 0, (b, a) => (a > 2 ? some(b + a) : some(b))), some(7))\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 232,
        "to": 235
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M extends URIS3, F extends URIS, E>(\n  M: Monad3C<M, E>,\n  F: Foldable1<F>\n): <R, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 236,
        "to": 239
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Foldable1<F>\n): <E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 240,
        "to": 243
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M extends URIS2, F extends URIS, E>(\n  M: Monad2C<M, E>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 244,
        "to": 247
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind<M, B>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 248,
        "to": 251
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => HKT<M, B>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 252,
        "to": 255
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => HKT<M, B>) => HKT<M, B> {\n  return (fa, b, f) => F.reduce(fa, M.of(b), (mb, a) => M.chain(mb, (b) => f(b, a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 256,
        "to": 261
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\n\n/**\n * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator\n *\n * @example\n * import { intercalate } from 'fp-ts/lib/Foldable'\n * import { monoidString } from 'fp-ts/lib/Monoid'\n * import { make, tree } from 'fp-ts/lib/Tree'\n *\n * const t = make('a', [make('b', []), make('c', []), make('d', [])])\n * assert.strictEqual(intercalate(monoidString, tree)('|', t), 'a|b|c|d')\n *\n * @since 2.0.0\n */\nexport function intercalate<M, F extends URIS3>(\n  M: Monoid<M>,\n  F: Foldable3<F>\n): <R, E>(sep: M, fm: Kind3<F, R, E, M>) => M",
    "docs": "/**\n * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator\n *\n * @example\n * import { intercalate } from 'fp-ts/lib/Foldable'\n * import { monoidString } from 'fp-ts/lib/Monoid'\n * import { make, tree } from 'fp-ts/lib/Tree'\n *\n * const t = make('a', [make('b', []), make('c', []), make('d', [])])\n * assert.strictEqual(intercalate(monoidString, tree)('|', t), 'a|b|c|d')\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 276,
        "to": 279
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS2>(M: Monoid<M>, F: Foldable2<F>): <E>(sep: M, fm: Kind2<F, E, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 280,
        "to": 280
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS2, E>(M: Monoid<M>, F: Foldable2C<F, E>): (sep: M, fm: Kind2<F, E, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 281,
        "to": 281
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (sep: M, fm: Kind<F, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 282,
        "to": 282
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 283,
        "to": 283
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M {\n  interface Acc<M> {\n    readonly init: boolean\n    readonly acc: M\n  }\n  return (sep, fm) => {\n    const go = ({ init, acc }: Acc<M>, x: M): Acc<M> =>\n      init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, sep), x) }\n    return F.reduce(fm, { init: true, acc: M.empty }, go).acc\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 284,
        "to": 294
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\n\n/**\n * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the\n * final result.\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import { traverse_ } from 'fp-ts/lib/Foldable'\n * import { io } from 'fp-ts/lib/IO'\n *\n * let log = ''\n * const append = (s: string) => () => (log += s)\n * traverse_(io, array)(['a', 'b', 'c'], append)()\n * assert.strictEqual(log, 'abc')\n *\n * @since 2.0.0\n */\nexport function traverse_<M extends URIS3, F extends URIS>(\n  M: Applicative3<M>,\n  F: Foldable1<F>\n): <R, E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, void>",
    "docs": "/**\n * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the\n * final result.\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import { traverse_ } from 'fp-ts/lib/Foldable'\n * import { io } from 'fp-ts/lib/IO'\n *\n * let log = ''\n * const append = (s: string) => () => (log += s)\n * traverse_(io, array)(['a', 'b', 'c'], append)()\n * assert.strictEqual(log, 'abc')\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 312,
        "to": 315
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS2, F extends URIS>(\n  M: Applicative2<M>,\n  F: Foldable1<F>\n): <E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 316,
        "to": 319
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS2, F extends URIS, E>(\n  M: Applicative2C<M, E>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 320,
        "to": 323
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS, F extends URIS>(\n  M: Applicative1<M>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind<M, B>) => Kind<M, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 324,
        "to": 327
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M, F>(\n  M: Applicative<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<M, B>) => HKT<M, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 328,
        "to": 331
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M, F>(\n  M: Applicative<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<M, B>) => HKT<M, void> {\n  const applyFirst = <B>(mu: HKT<M, void>, mb: HKT<M, B>): HKT<M, void> => M.ap(M.map(mu, constant), mb)\n  const mu: HKT<M, void> = M.of(undefined)\n  return (fa, f) => F.reduce(fa, mu, (mu, a) => applyFirst(mu, f(a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 332,
        "to": 339
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n\n/* tslint:enable:readonly-array */\n\n/**\n * @since 2.0.0\n */\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2C<G, GI, E>\n): FoldableWithIndexComposition22C<F, FI, G, GI, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<G, GI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition22C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 208,
        "to": 211
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition22<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition22<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 212,
        "to": 215
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FoldableWithIndex2C<F, FI, E>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition2C1<F, FI, G, GI, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<F, FI, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition2C1<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 216,
        "to": 219
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition21<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition21<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 220,
        "to": 223
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 224,
        "to": 227
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 228,
        "to": 231
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition11<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition11<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 232,
        "to": 235
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F, FI, G, GI>(\n  F: FoldableWithIndex<F, FI>,\n  G: FoldableWithIndex<G, GI>\n): FoldableWithIndexComposition<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 236,
        "to": 239
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\nexport function getFoldableWithIndexComposition<F, FI, G, GI>(\n  F: FoldableWithIndex<F, FI>,\n  G: FoldableWithIndex<G, GI>\n): FoldableWithIndexComposition<F, FI, G, GI> {\n  const FC = getFoldableComposition(F, G)\n  return {\n    reduce: FC.reduce,\n    foldMap: FC.foldMap,\n    reduceRight: FC.reduceRight,\n    reduceWithIndex: (fga, b, f) =>\n      F.reduceWithIndex(fga, b, (fi, b, ga) => G.reduceWithIndex(ga, b, (gi, b, a) => f([fi, gi], b, a))),\n    foldMapWithIndex: (M) => {\n      const foldMapWithIndexF = F.foldMapWithIndex(M)\n      const foldMapWithIndexG = G.foldMapWithIndex(M)\n      return (fga, f) => foldMapWithIndexF(fga, (fi, ga) => foldMapWithIndexG(ga, (gi, a) => f([fi, gi], a)))\n    },\n    reduceRightWithIndex: (fga, b, f) =>\n      F.reduceRightWithIndex(fga, b, (fi, ga, b) => G.reduceRightWithIndex(ga, b, (gi, a, b) => f([fi, gi], a, b)))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 240,
        "to": 259
      }
    }
  },
  {
    "name": "identity",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function identity<A>(a: A): A {\n  return a\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "not",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function not<A>(predicate: Predicate<A>): Predicate<A> {\n  return (a) => !predicate(a)\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 62,
        "to": 64
      }
    }
  },
  {
    "name": "constant",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function constant<A>(a: A): Lazy<A> {\n  return () => a\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 69,
        "to": 71
      }
    }
  },
  {
    "name": "flip",
    "text": "\n\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nexport function flip<A, B, C>(f: (a: A, b: B) => C): (b: B, a: A) => C {\n  return (b, a) => f(a, b)\n}",
    "docs": "/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(b: B, a: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 123,
        "to": 125
      }
    }
  },
  {
    "name": "flow",
    "text": "\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from 'fp-ts/lib/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>, B>(ab: (...a: A) => B): (...a: A) => B",
    "docs": "/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from 'fp-ts/lib/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 144,
        "to": 144
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 145,
        "to": 145
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): (...a: A) => D",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 146,
        "to": 150
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 151,
        "to": 156
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => F"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 157,
        "to": 163
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => G"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 164,
        "to": 171
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => H"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 172,
        "to": 180
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => I"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 181,
        "to": 190
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => J"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 191,
        "to": 201
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return ab\n    case 2:\n      return function (this: unknown) {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n      return function (this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n      }\n    case 4:\n      return function (this: unknown) {\n        return de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return function (this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n      }\n    case 6:\n      return function (this: unknown) {\n        return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n      return function (this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n      }\n    case 8:\n      return function (this: unknown) {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n      }\n    case 9:\n      return function (this: unknown) {\n        return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n  }\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Unknown"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 202,
        "to": 250
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function tuple<T extends ReadonlyArray<any>>(...t: T): T {\n  return t\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "t",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "T"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 255,
        "to": 257
      }
    }
  },
  {
    "name": "increment",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function increment(n: number): number {\n  return n + 1\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 262,
        "to": 264
      }
    }
  },
  {
    "name": "decrement",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function decrement(n: number): number {\n  return n - 1\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 269,
        "to": 271
      }
    }
  },
  {
    "name": "absurd",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function absurd<A>(_: never): A {\n  throw new Error('Called `absurd` function which should be uncallable')\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "_",
          "type": {
            "__tag": "Never"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 276,
        "to": 278
      }
    }
  },
  {
    "name": "tupled",
    "text": "\n\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/lib/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B {\n  return (a) => f(...a)\n}",
    "docs": "/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/lib/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 292,
        "to": 294
      }
    }
  },
  {
    "name": "untupled",
    "text": "\n\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled<A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B {\n  return (...a) => f(a)\n}",
    "docs": "/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 301,
        "to": 303
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * See also [`flow`](#flow).\n *\n * @example\n * import { pipe } from 'fp-ts/lib/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * // without pipe\n * assert.strictEqual(double(len('aaa')), 6)\n *\n * // with pipe\n * assert.strictEqual(pipe('aaa', len, double), 6)\n *\n * @since 2.6.3\n */\nexport function pipe<A>(a: A): A",
    "docs": "/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * See also [`flow`](#flow).\n *\n * @example\n * import { pipe } from 'fp-ts/lib/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * // without pipe\n * assert.strictEqual(double(len('aaa')), 6)\n *\n * // with pipe\n * assert.strictEqual(pipe('aaa', len, double), 6)\n *\n * @since 2.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 324,
        "to": 324
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B>(a: A, ab: (a: A) => B): B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 325,
        "to": 325
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 326,
        "to": 326
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 327,
        "to": 327
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 328,
        "to": 328
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): F",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "F"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 329,
        "to": 336
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): G",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "G"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 337,
        "to": 345
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "H"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 346,
        "to": 355
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "I"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 356,
        "to": 366
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): J",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "J"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 367,
        "to": 378
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    case 10:\n      return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))\n  }\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Unknown"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 379,
        "to": 414
      }
    }
  },
  {
    "name": "constTrue",
    "text": "const constTrue = (): boolean => {\n  return true\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "constFalse",
    "text": "const constFalse = (): boolean => {\n  return false\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "constNull",
    "text": "const constNull = (): null => {\n  return null\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Null"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 96,
        "to": 98
      }
    }
  },
  {
    "name": "constUndefined",
    "text": "const constUndefined = (): undefined => {\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Undefined"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 105,
        "to": 107
      }
    }
  },
  {
    "name": "constVoid",
    "text": "const constVoid = (): void => {\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 114,
        "to": 116
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getFunctorComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Functor3C<G, E>\n): FunctorComposition23C<F, G, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 175,
        "to": 178
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Functor2C<G, E>\n): FunctorComposition22C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 179,
        "to": 182
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Functor2<G>\n): FunctorComposition22<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 183,
        "to": 186
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Functor1<G>\n): FunctorComposition2C1<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 187,
        "to": 190
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Functor1<G>\n): FunctorComposition21<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 191,
        "to": 194
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Functor2C<G, E>\n): FunctorComposition12C<F, G, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 195,
        "to": 198
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Functor2<G>\n): FunctorComposition12<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 199,
        "to": 202
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Functor1<G>\n): FunctorComposition11<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 203,
        "to": 206
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 207,
        "to": 207
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\nexport function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G> {\n  return {\n    map: (fa, f) => F.map(fa, (ga) => G.map(ga, f))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 208,
        "to": 212
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n\n/* tslint:enable:readonly-array */\n\n/**\n * @since 2.0.0\n */\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2C<G, FI, E>\n): FunctorWithIndexComposition22C<F, FI, G, GI, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<G, FI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition22C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 166,
        "to": 169
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2<G, FI>\n): FunctorWithIndexComposition22<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<G, FI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition22<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 170,
        "to": 173
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FunctorWithIndex2C<F, FI, E>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition2C1<F, FI, G, GI, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<F, FI, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition2C1<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 174,
        "to": 177
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition21<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition21<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 178,
        "to": 181
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2C<G, GI, E>\n): FunctorWithIndexComposition12C<F, FI, G, GI, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<G, GI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition12C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 182,
        "to": 185
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2<G, GI>\n): FunctorWithIndexComposition12<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 186,
        "to": 189
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition11<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition11<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 190,
        "to": 193
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F, FI, G, GI>(\n  F: FunctorWithIndex<F, FI>,\n  G: FunctorWithIndex<G, GI>\n): FunctorWithIndexComposition<F, FI, G, GI>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 194,
        "to": 197
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\nexport function getFunctorWithIndexComposition<F, FI, G, GI>(\n  F: FunctorWithIndex<F, FI>,\n  G: FunctorWithIndex<G, GI>\n): FunctorWithIndexComposition<F, FI, G, GI> {\n  return {\n    map: getFunctorComposition(F, G).map,\n    mapWithIndex: (fga, f) => F.mapWithIndex(fga, (fi, ga) => G.mapWithIndex(ga, (gi, a) => f([fi, gi], a)))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 198,
        "to": 206
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Identity<A>) => HKT<F, Identity<B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (ta) => traverseF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 66,
        "to": 71
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: Applicative<F>) => <A>(\n  ta: Identity<HKT<F, A>>\n): HKT<F, Identity<A>> => {\n  return F.map(ta, id)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 76,
        "to": 80
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => Identity<A>) => (fa: Identity<A>) => Identity<A> = (that) => (fa) => alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 89,
        "to": 89
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Identity<A>) => <B>(fab: Identity<(a: A) => B>) => Identity<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: (a: A) => B) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 97,
        "to": 97
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: Identity<B>) => <A>(fa: Identity<A>) => Identity<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 105,
        "to": 109
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: Identity<B>) => <A>(fa: Identity<A>): Identity<B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 117,
        "to": 121
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Identity<B>) => (ma: Identity<A>) => Identity<B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 129,
        "to": 129
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => Identity<B>) => (ma: Identity<A>) => Identity<A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 138,
        "to": 139
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <A>(ma: Identity<A>) => Identity<Identity<A>> = (wa) => extend_(wa, id)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 145,
        "to": 145
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Identity<A>) => B) => (wa: Identity<A>) => Identity<B> = (f) => (ma) =>\n  extend_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 157,
        "to": 158
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: Identity<Identity<A>>) => Identity<A> = (mma) => chain_(mma, id)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 164,
        "to": 164
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Identity<A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: A) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 170,
        "to": 173
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Identity<A>) => B = (b, f) => (fa) => reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 179,
        "to": 179
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Identity<A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 185,
        "to": 186
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Identity<A>) => Identity<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 195,
        "to": 195
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<A>(S: Semigroup<A>): Semigroup<IO<A>> {\n  return {\n    concat: (x, y) => () => S.concat(x(), y())\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 157,
        "to": 161
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<A>(M: Monoid<A>): Monoid<IO<A>> {\n  return {\n    concat: getSemigroup(M).concat,\n    empty: of(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 167,
        "to": 172
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: IO<A>) => IO<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 45,
        "to": 45
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: IO<A>) => <B>(fab: IO<(a: A) => B>) => IO<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 53,
        "to": 53
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: IO<B>) => <A>(fa: IO<A>) => IO<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 61,
        "to": 65
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: IO<B>) => <A>(fa: IO<A>): IO<B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 73,
        "to": 77
      }
    }
  },
  {
    "name": "of",
    "text": "const of = <A>(a: A): IO<A> => () => a",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 83,
        "to": 83
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => IO<B>) => (ma: IO<A>) => IO<B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 89,
        "to": 89
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => IO<B>) => (ma: IO<A>) => IO<A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 98,
        "to": 99
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: IO<IO<A>>) => IO<A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 105,
        "to": 105
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * Constructs a new `IOEither` from a function that performs a side effect and might throw\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch<E, A>(f: Lazy<A>, onError: (reason: unknown) => E): IOEither<E, A> {\n  return () => E.tryCatch(f, onError)\n}",
    "docs": "/**\n * Constructs a new `IOEither` from a function that performs a side effect and might throw\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 77,
        "to": 79
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): (...a: A) => IOEither<E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 144,
        "to": 148
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(S: Semigroup<A>): Semigroup<IOEither<E, A>> {\n  return I.getSemigroup(E.getSemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 381,
        "to": 383
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<E, A>(S: Semigroup<A>): Semigroup<IOEither<E, A>> {\n  return I.getSemigroup(E.getApplySemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 392,
        "to": 394
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<E, A>(M: Monoid<A>): Monoid<IOEither<E, A>> {\n  return {\n    concat: getApplySemigroup<E, A>(M).concat,\n    empty: right(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 400,
        "to": 405
      }
    }
  },
  {
    "name": "getIOValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getIOValidation<E>(\n  S: Semigroup<E>\n): Monad2C<URI, E> & Bifunctor2<URI> & Alt2C<URI, E> & MonadIO2C<URI, E> & MonadThrow2C<URI, E> {\n  const V = getValidationM(S, I.monadIO)\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: V.ap,\n    of,\n    chain: chain_,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    alt: V.alt,\n    fromIO: fromIO_,\n    throwError: throwError_\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"IOEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadIO\").MonadIO2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 411,
        "to": 428
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.1.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E> {\n  const W = E.getWitherable(M)\n  const F = getFilterableComposition(I.monadIO, W)\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    compact: F.compact,\n    separate: F.separate,\n    filter: F.filter,\n    filterMap: F.filterMap,\n    partition: F.partition,\n    partitionMap: F.partitionMap\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 434,
        "to": 449
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: IOEither<E, A>): IO<A | B> =>\n  pipe(ma, I.chain(E.fold<E, A, I.IO<A | B>>(onLeft, I.of)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 99,
        "to": 100
      }
    }
  },
  {
    "name": "orElse",
    "text": "const orElse: <E, A, M>(onLeft: (e: E) => IOEither<M, A>) => (ma: IOEither<E, A>) => IOEither<M, A> = (f) =>\n  I.chain(E.fold(f, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<M, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 116,
        "to": 117
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: IOEither<E, A>) => IOEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: IOEither<E, A>) => IOEither<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (ma: IOEither<E, A>) =>\n  pipe(\n    ma,\n    chain((a) => (predicate(a) ? right(a) : left(onFalse(a))))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 131,
        "to": 138
      }
    }
  },
  {
    "name": "chainEitherKW",
    "text": "const chainEitherKW: <E, A, B>(f: (a: A) => Either<E, B>) => <D>(ma: IOEither<D, A>) => IOEither<D | E, B> = (\n  f\n) => chainW(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E | E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 156,
        "to": 158
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: IOEither<E, A>) => IOEither<E, B> = (f) => I.map(E.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 179,
        "to": 179
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: IOEither<E, A>) => IOEither<G, A> = (f) => I.map(E.mapLeft(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 198,
        "to": 198
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <E, B>(fb: IOEither<E, B>) => <A>(fa: IOEither<E, A>) => IOEither<E, A> = (fb) => (fa) =>\n  pipe(\n    fa,\n    map((a) => () => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 216,
        "to": 221
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: IOEither<E, B>) => <A>(fa: IOEither<E, A>): IOEither<E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 229,
        "to": 234
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW = <D, A, B>(f: (a: A) => IOEither<D, B>) => <E>(ma: IOEither<E, A>): IOEither<D | E, B> =>\n  pipe(ma, I.chain(E.fold<E, A, IOEither<D | E, B>>(left, f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<D, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<D | E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 242,
        "to": 243
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => IOEither<E, B>) => (ma: IOEither<E, A>) => IOEither<E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 260,
        "to": 266
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <E, A>(that: () => IOEither<E, A>) => (fa: IOEither<E, A>) => IOEither<E, A> = (that) =>\n  I.chain(E.fold(that, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 281,
        "to": 282
      }
    }
  },
  {
    "name": "bracket",
    "text": "const bracket = <E, A, B>(\n  acquire: IOEither<E, A>,\n  use: (a: A) => IOEither<E, B>,\n  release: (a: A, e: Either<E, B>) => IOEither<E, void>\n): IOEither<E, B> =>\n  pipe(\n    acquire,\n    chain((a) =>\n      pipe(\n        pipe(use(a), I.map(E.right)),\n        chain((e) =>\n          pipe(\n            release(a, e),\n            chain(() => (E.isLeft(e) ? left(e.left) : of(e.right)))\n          )\n        )\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "acquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 293,
        "to": 311
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <A>(ma: Option<A>) => IOEither<E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 317,
        "to": 318
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => IOEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => IOEither<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<never, A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 324,
        "to": 327
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <E, A>(ma: E.Either<E, A>) => IOEither<E, A> = (ma) =>\n  E.isLeft(ma) ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 333,
        "to": 334
      }
    }
  },
  {
    "name": "newIORef",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function newIORef<A>(a: A): IO<IORef<A>> {\n  return () => new IORef(a)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IORef\").IORef<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IORef.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a map into a list of key/value pairs\n *\n * @since 2.0.0\n */\nexport function toUnfoldable<K, F extends URIS>(O: Ord<K>, U: Unfoldable1<F>): <A>(d: Map<K, A>) => Kind<F, [K, A]>",
    "docs": "/**\n * Unfolds a map into a list of key/value pairs\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 90,
        "to": 90
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(O: Ord<K>, U: Unfoldable<F>): <A>(d: Map<K, A>) => HKT<F, [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 91,
        "to": 91
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(O: Ord<K>, U: Unfoldable<F>): <A>(d: Map<K, A>) => HKT<F, [K, A]> {\n  return RM.toUnfoldable(O, U) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, [K, A]>) => Map<K, A>",
    "docs": "/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 186,
        "to": 190
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 191,
        "to": 195
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 196,
        "to": 200
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 201,
        "to": 201
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [K, A]>) => Map<K, A> {\n  return RM.fromFoldable(E, M, F) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 202,
        "to": 204
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function fold<A>(M: Monoid<A>): (as: ReadonlyArray<A>) => A {\n  const foldM = foldSemigroup(M)\n  return (as) => foldM(M.empty, as)\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 97,
        "to": 100
      }
    }
  },
  {
    "name": "getTupleMonoid",
    "text": "\n\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/lib/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleMonoid<T extends ReadonlyArray<Monoid<any>>>(\n  ...monoids: T\n): Monoid<{ [K in keyof T]: T[K] extends Semigroup<infer A> ? A : never }> {\n  return {\n    concat: getTupleSemigroup(...monoids).concat,\n    empty: monoids.map((m) => m.empty)\n  } as any\n}",
    "docs": "/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/lib/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "monoids",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 117,
        "to": 124
      }
    }
  },
  {
    "name": "getDualMonoid",
    "text": "\n\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/lib/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualMonoid<A>(M: Monoid<A>): Monoid<A> {\n  return {\n    concat: getDualSemigroup(M).concat,\n    empty: M.empty\n  }\n}",
    "docs": "/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/lib/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 137,
        "to": 142
      }
    }
  },
  {
    "name": "getFunctionMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionMonoid<M>(M: Monoid<M>): <A = never>() => Monoid<(a: A) => M> {\n  return () => ({\n    concat: getFunctionSemigroup(M)<any>().concat,\n    empty: () => M.empty\n  })\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<(a: A) => M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 148,
        "to": 153
      }
    }
  },
  {
    "name": "getEndomorphismMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEndomorphismMonoid<A = never>(): Monoid<Endomorphism<A>> {\n  return {\n    concat: (x, y) => (a) => x(y(a)),\n    empty: identity\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 159,
        "to": 164
      }
    }
  },
  {
    "name": "getStructMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getStructMonoid<O extends ReadonlyRecord<string, any>>(\n  monoids: { [K in keyof O]: Monoid<O[K]> }\n): Monoid<O> {\n  const empty: any = {}\n  for (const key of Object.keys(monoids)) {\n    empty[key] = monoids[key].empty\n  }\n  return {\n    concat: getStructSemigroup<O>(monoids).concat,\n    empty\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "monoids",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof O]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<O[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<O>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 170,
        "to": 181
      }
    }
  },
  {
    "name": "getMeetMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMeetMonoid<A>(B: Bounded<A>): Monoid<A> {\n  return {\n    concat: getMeetSemigroup(B).concat,\n    empty: B.top\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bounded\").Bounded<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 187,
        "to": 192
      }
    }
  },
  {
    "name": "getJoinMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getJoinMonoid<A>(B: Bounded<A>): Monoid<A> {\n  return {\n    concat: getJoinSemigroup(B).concat,\n    empty: B.bottom\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bounded\").Bounded<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 198,
        "to": 203
      }
    }
  },
  {
    "name": "group",
    "text": "\n\n/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { cons, group } from 'fp-ts/lib/NonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(group(ordNumber)([1, 2, 1, 1]), [\n *   cons(1, []),\n *   cons(2, []),\n *   cons(1, [1])\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function group<A>(\n  E: Eq<A>\n): {\n  (as: NonEmptyArray<A>): NonEmptyArray<NonEmptyArray<A>>\n  (as: Array<A>): Array<NonEmptyArray<A>>\n}",
    "docs": "/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { cons, group } from 'fp-ts/lib/NonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(group(ordNumber)([1, 2, 1, 1]), [\n *   cons(1, []),\n *   cons(2, []),\n *   cons(1, [1])\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>; (as: A[]): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 141,
        "to": 146
      }
    }
  },
  {
    "name": "group",
    "text": "\nexport function group<A>(E: Eq<A>): (as: Array<A>) => Array<NonEmptyArray<A>> {\n  return RNEA.group(E) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 147,
        "to": 149
      }
    }
  },
  {
    "name": "copy",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function copy<A>(nea: NonEmptyArray<A>): NonEmptyArray<A> {\n  const l = nea.length\n  const as = Array(l)\n  for (let i = 0; i < l; i++) {\n    as[i] = nea[i]\n  }\n  return as as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 236,
        "to": 243
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function filter<A, B extends A>(\n  refinement: Refinement<A, B>\n): (nea: NonEmptyArray<A>) => Option<NonEmptyArray<A>>",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 249,
        "to": 251
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (nea: NonEmptyArray<A>) => Option<NonEmptyArray<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 252,
        "to": 252
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (nea: NonEmptyArray<A>) => Option<NonEmptyArray<A>> {\n  return RNEA.filter(predicate) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 253,
        "to": 255
      }
    }
  },
  {
    "name": "concat",
    "text": "\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport function concat<A>(fx: Array<A>, fy: NonEmptyArray<A>): NonEmptyArray<A>",
    "docs": "/**\n * @category constructors\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 274,
        "to": 274
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(fx: NonEmptyArray<A>, fy: Array<A>): NonEmptyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 275,
        "to": 275
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(fx: Array<A>, fy: Array<A>): Array<A> {\n  return RNEA.concat(fx as any, fy as any) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 276,
        "to": 278
      }
    }
  },
  {
    "name": "isSome",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isSome<A>(fa: Option<A>): fa is Some<A> {\n  return fa._tag === 'Some'\n}",
    "docs": "/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 77,
        "to": 79
      }
    }
  },
  {
    "name": "isNone",
    "text": "\n\n/**\n * Returns `true` if the option is `None`, `false` otherwise\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isNone<A>(fa: Option<A>): fa is None {\n  return fa._tag === 'None'\n}",
    "docs": "/**\n * Returns `true` if the option is `None`, `false` otherwise\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "some",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function some<A>(a: A): Option<A> {\n  return { _tag: 'Some', value: a }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 111,
        "to": 113
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable<A>(a: A): Option<NonNullable<A>> {\n  return a == null ? none : some(a as NonNullable<A>)\n}",
    "docs": "/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 129,
        "to": 131
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\n\n/**\n * Returns a smart constructor based on the given predicate\n *\n * @example\n * import { none, some, fromPredicate } from 'fp-ts/lib/Option'\n *\n * const getOption = fromPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), none)\n * assert.deepStrictEqual(getOption(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromPredicate<A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>",
    "docs": "/**\n * Returns a smart constructor based on the given predicate\n *\n * @example\n * import { none, some, fromPredicate } from 'fp-ts/lib/Option'\n *\n * const getOption = fromPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), none)\n * assert.deepStrictEqual(getOption(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 147,
        "to": 147
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<A>(predicate: Predicate<A>): (a: A) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 148,
        "to": 148
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<A>(predicate: Predicate<A>): (a: A) => Option<A> {\n  return (a) => (predicate(a) ? some(a) : none)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 149,
        "to": 151
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in\n * `Some`\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch<A>(f: Lazy<A>): Option<A> {\n  try {\n    return some(f())\n  } catch (e) {\n    return none\n  }\n}",
    "docs": "/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in\n * `Some`\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 171,
        "to": 177
      }
    }
  },
  {
    "name": "getLeft",
    "text": "\n\n/**\n * Returns an `E` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft<E, A>(ma: Either<E, A>): Option<E> {\n  return ma._tag === 'Right' ? none : some(ma.left)\n}",
    "docs": "/**\n * Returns an `E` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 185,
        "to": 187
      }
    }
  },
  {
    "name": "getRight",
    "text": "\n\n/**\n * Returns an `A` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight<E, A>(ma: Either<E, A>): Option<A> {\n  return ma._tag === 'Left' ? none : some(ma.right)\n}",
    "docs": "/**\n * Returns an `A` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 195,
        "to": 197
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * Takes a default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold<A, B>(onNone: () => B, onSome: (a: A) => B): (ma: Option<A>) => B {\n  return (ma) => (isNone(ma) ? onNone() : onSome(ma.value))\n}",
    "docs": "/**\n * Takes a default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 236,
        "to": 238
      }
    }
  },
  {
    "name": "toNullable",
    "text": "\n\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toNullable<A>(ma: Option<A>): A | null {\n  return isNone(ma) ? null : ma.value\n}",
    "docs": "/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 265,
        "to": 267
      }
    }
  },
  {
    "name": "toUndefined",
    "text": "\n\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toUndefined<A>(ma: Option<A>): A | undefined {\n  return isNone(ma) ? undefined : ma.value\n}",
    "docs": "/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 294,
        "to": 296
      }
    }
  },
  {
    "name": "mapNullable",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values\n *\n * @example\n * import { some, none, fromNullable, mapNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function mapNullable<A, B>(f: (a: A) => B | null | undefined): (ma: Option<A>) => Option<B> {\n  return (ma) => (isNone(ma) ? none : fromNullable(f(ma.value)))\n}",
    "docs": "/**\n * This is `chain` + `fromNullable`, useful when working with optional values\n *\n * @example\n * import { some, none, fromNullable, mapNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 381,
        "to": 383
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<A>(S: Show<A>): Show<Option<A>> {\n  return {\n    show: (ma) => (isNone(ma) ? 'none' : `some(${S.show(ma.value)})`)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 695,
        "to": 699
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<Option<A>> {\n  return {\n    equals: (x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value))\n  }\n}",
    "docs": "/**\n * @example\n * import { none, some, getEq } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 716,
        "to": 720
      }
    }
  },
  {
    "name": "getOrd",
    "text": "\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/lib/Option'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd<A>(O: Ord<A>): Ord<Option<A>> {\n  return {\n    equals: getEq(O).equals,\n    compare: (x, y) => (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1)\n  }\n}",
    "docs": "/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/lib/Option'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 743,
        "to": 748
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<A>(S: Semigroup<A>): Semigroup<Option<A>> {\n  return {\n    concat: (x, y) => (isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none)\n  }\n}",
    "docs": "/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 773,
        "to": 777
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<A>(M: Monoid<A>): Monoid<Option<A>> {\n  return {\n    concat: getApplySemigroup(M).concat,\n    empty: some(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 783,
        "to": 788
      }
    }
  },
  {
    "name": "getFirstMonoid",
    "text": "\n\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid<A = never>(): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(x) ? y : x),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 812,
        "to": 817
      }
    }
  },
  {
    "name": "getLastMonoid",
    "text": "\n\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid<A = never>(): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(y) ? x : y),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 841,
        "to": 846
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<A>(S: Semigroup<A>): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 872,
        "to": 877
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, ma: Option<A>) => boolean {\n  return (a, ma) => (isNone(ma) ? false : E.equals(a, ma.value))\n}",
    "docs": "/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 933,
        "to": 935
      }
    }
  },
  {
    "name": "exists",
    "text": "\n\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists<A>(predicate: Predicate<A>): (ma: Option<A>) => boolean {\n  return (ma) => (isNone(ma) ? false : predicate(ma.value))\n}",
    "docs": "/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 968,
        "to": 970
      }
    }
  },
  {
    "name": "getRefinement",
    "text": "\n\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/lib/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement<A, B extends A>(getOption: (a: A) => Option<B>): Refinement<A, B> {\n  return (a: A): a is B => isSome(getOption(a))\n}",
    "docs": "/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/lib/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "getOption",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 989,
        "to": 991
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <E, A>(ma: Either<E, A>) => Option<A> = (ma) => (ma._tag === 'Left' ? none : some(ma.right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 203,
        "to": 203
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <B>(onNone: () => B) => <A>(ma: Option<A>): A | B => (isNone(ma) ? onNone() : ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B | A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 304,
        "to": 304
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Option<A>) => Option<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 443,
        "to": 443
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Option<A>) => <B>(fab: Option<(a: A) => B>) => Option<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 451,
        "to": 451
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: Option<B>) => <A>(fa: Option<A>) => Option<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 459,
        "to": 463
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: Option<B>) => <A>(fa: Option<A>): Option<B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 471,
        "to": 475
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Option<B>) => (ma: Option<A>) => Option<B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 483,
        "to": 483
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => Option<B>) => (ma: Option<A>) => Option<A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 492,
        "to": 493
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: Option<Option<A>>) => Option<A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 499,
        "to": 499
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => Option<A>) => (fa: Option<A>) => Option<A> = (that) => (fa) => alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 529,
        "to": 529
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <A>(ma: Option<A>) => Option<Option<A>> = (wa) => extend_(wa, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 535,
        "to": 535
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Option<A>) => B) => (wa: Option<A>) => Option<B> = (f) => (ma) => extend_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 541,
        "to": 541
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Option<A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 547,
        "to": 550
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Option<A>) => B = (b, f) => (fa) => reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 556,
        "to": 556
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Option<A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 562,
        "to": 563
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact: <A>(fa: Option<Option<A>>) => Option<A> = (ma) => chain_(ma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 569,
        "to": 569
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate: <A, B>(ma: Option<Either<A, B>>) => Separated<Option<A>, Option<B>> = (ma) => {\n  const o = map_(ma, (e) => ({\n    left: getLeft(e),\n    right: getRight(e)\n  }))\n  return isNone(o) ? defaultSeparate : o.value\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ left: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>; right: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 575,
        "to": 581
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Option<A>) => Option<B>\n  <A>(predicate: Predicate<A>): (fa: Option<A>) => Option<A>\n} = <A>(predicate: Predicate<A>) => (fa: Option<A>) => filter_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 587,
        "to": 590
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: Option<A>) => Option<B> = (f) => (fa) =>\n  filterMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 596,
        "to": 597
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Option<A>) => Separated<Option<A>, Option<B>>\n  <A>(predicate: Predicate<A>): (fa: Option<A>) => Separated<Option<A>, Option<A>>\n} = <A>(predicate: Predicate<A>) => (fa: Option<A>) => partition_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 603,
        "to": 606
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Option<A>) => Separated<Option<B>, Option<C>> = (f) => (fa) => partitionMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 612,
        "to": 614
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Option<A>) => HKT<F, Option<B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (ta) => traverseF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 620,
        "to": 625
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: Applicative<F>) => <A>(\n  ta: Option<HKT<F, A>>\n): HKT<F, Option<A>> => {\n  return isNone(ta) ? F.of(none) : F.map(ta.value, some)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 631,
        "to": 635
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (ta: Option<A>) => HKT<F, Option<B>>) => {\n  const witherF = wither_(F)\n  return (f) => (ta) => witherF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 641,
        "to": 646
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (wa: Option<A>) => HKT<F, Separated<Option<B>, Option<C>>>) => {\n  const wiltF = wilt_(F)\n  return (f) => (ta) => wiltF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 652,
        "to": 657
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getOptionM<M extends URIS2>(M: Monad2<M>): OptionM2<M>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\nexport function getOptionM<M extends URIS2, E>(M: Monad2C<M, E>): OptionM2C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 93,
        "to": 93
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\nexport function getOptionM<M extends URIS>(M: Monad1<M>): OptionM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 94,
        "to": 94
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\nexport function getOptionM<M>(M: Monad<M>): OptionM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 95,
        "to": 95
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\nexport function getOptionM<M>(M: Monad<M>): OptionM<M> {\n  const A = getApplicativeComposition(M, applicativeOption)\n  const fnone = M.of(none)\n\n  return {\n    map: A.map,\n    ap: A.ap,\n    of: A.of,\n    chain: (ma, f) =>\n      M.chain(\n        ma,\n        fold(() => fnone, f)\n      ),\n    alt: (fx, fy) =>\n      M.chain(\n        fx,\n        fold(fy, (a) => M.of(some(a)))\n      ),\n    fold: (ma, onNone, onSome) => M.chain(ma, fold(onNone, onSome)),\n    getOrElse: (ma, onNone) => M.chain(ma, fold(onNone, M.of)),\n    fromM: (ma) => M.map(ma, some),\n    none: () => fnone\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 96,
        "to": 119
      }
    }
  },
  {
    "name": "lt",
    "text": "\n\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport function lt<A>(O: Ord<A>): (x: A, y: A) => boolean {\n  return (x, y) => O.compare(x, y) === -1\n}",
    "docs": "/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "gt",
    "text": "\n\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport function gt<A>(O: Ord<A>): (x: A, y: A) => boolean {\n  return (x, y) => O.compare(x, y) === 1\n}",
    "docs": "/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "leq",
    "text": "\n\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport function leq<A>(O: Ord<A>): (x: A, y: A) => boolean {\n  return (x, y) => O.compare(x, y) !== 1\n}",
    "docs": "/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "geq",
    "text": "\n\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport function geq<A>(O: Ord<A>): (x: A, y: A) => boolean {\n  return (x, y) => O.compare(x, y) !== -1\n}",
    "docs": "/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "min",
    "text": "\n\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport function min<A>(O: Ord<A>): (x: A, y: A) => A {\n  return (x, y) => (O.compare(x, y) === 1 ? y : x)\n}",
    "docs": "/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "max",
    "text": "\n\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport function max<A>(O: Ord<A>): (x: A, y: A) => A {\n  return (x, y) => (O.compare(x, y) === -1 ? y : x)\n}",
    "docs": "/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "clamp",
    "text": "\n\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport function clamp<A>(O: Ord<A>): (low: A, hi: A) => (x: A) => A {\n  const minO = min(O)\n  const maxO = max(O)\n  return (low, hi) => (x) => maxO(minO(x, hi), low)\n}",
    "docs": "/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(low: A, hi: A) => (x: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 125,
        "to": 129
      }
    }
  },
  {
    "name": "between",
    "text": "\n\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport function between<A>(O: Ord<A>): (low: A, hi: A) => (x: A) => boolean {\n  const lessThanO = lt(O)\n  const greaterThanO = gt(O)\n  return (low, hi) => (x) => (lessThanO(x, low) || greaterThanO(x, hi) ? false : true)\n}",
    "docs": "/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(low: A, hi: A) => (x: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 136,
        "to": 140
      }
    }
  },
  {
    "name": "fromCompare",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromCompare<A>(compare: (x: A, y: A) => Ordering): Ord<A> {\n  const optimizedCompare = (x: A, y: A): Ordering => (x === y ? 0 : compare(x, y))\n  return {\n    equals: (x, y) => optimizedCompare(x, y) === 0,\n    compare: optimizedCompare\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "compare",
          "type": {
            "__tag": "Other",
            "values": "(x: A, y: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 146,
        "to": 152
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Use `getMonoid` instead\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport function getSemigroup<A = never>(): Semigroup<Ord<A>> {\n  return {\n    concat: (x, y) => fromCompare((a, b) => monoidOrdering.concat(x.compare(a, b), y.compare(a, b)))\n  }\n}",
    "docs": "/**\n * Use `getMonoid` instead\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 161,
        "to": 165
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/lib/Array'\n * import { contramap, getDualOrd, getMonoid, ordBoolean, ordNumber, ordString } from 'fp-ts/lib/Ord'\n * import { pipe } from 'fp-ts/lib/function'\n * import { fold } from 'fp-ts/lib/Monoid'\n *\n * interface User {\n *   id: number\n *   name: string\n *   age: number\n *   rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   ordString,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   ordNumber,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   ordBoolean,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = fold(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = fold(M)([getDualOrd(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport function getMonoid<A = never>(): Monoid<Ord<A>> {\n  // tslint:disable-next-line: deprecation\n  const S = getSemigroup<A>()\n  return {\n    concat: S.concat,\n    empty: fromCompare(() => 0)\n  }\n}",
    "docs": "/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/lib/Array'\n * import { contramap, getDualOrd, getMonoid, ordBoolean, ordNumber, ordString } from 'fp-ts/lib/Ord'\n * import { pipe } from 'fp-ts/lib/function'\n * import { fold } from 'fp-ts/lib/Monoid'\n *\n * interface User {\n *   id: number\n *   name: string\n *   age: number\n *   rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   ordString,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   ordNumber,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   ordBoolean,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = fold(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = fold(M)([getDualOrd(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 231,
        "to": 238
      }
    }
  },
  {
    "name": "getTupleOrd",
    "text": "\n\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple\n *\n * @example\n * import { getTupleOrd, ordString, ordNumber, ordBoolean } from 'fp-ts/lib/Ord'\n *\n * const O = getTupleOrd(ordString, ordNumber, ordBoolean)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleOrd<T extends ReadonlyArray<Ord<any>>>(\n  ...ords: T\n): Ord<{ [K in keyof T]: T[K] extends Ord<infer A> ? A : never }> {\n  const len = ords.length\n  return fromCompare((x, y) => {\n    let i = 0\n    for (; i < len - 1; i++) {\n      const r = ords[i].compare(x[i], y[i])\n      if (r !== 0) {\n        return r\n      }\n    }\n    return ords[i].compare(x[i], y[i])\n  })\n}",
    "docs": "/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple\n *\n * @example\n * import { getTupleOrd, ordString, ordNumber, ordBoolean } from 'fp-ts/lib/Ord'\n *\n * const O = getTupleOrd(ordString, ordNumber, ordBoolean)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 254,
        "to": 268
      }
    }
  },
  {
    "name": "getDualOrd",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualOrd<A>(O: Ord<A>): Ord<A> {\n  return fromCompare((x, y) => O.compare(y, x))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 274,
        "to": 276
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => (fa: Ord<A>) => Ord<B> = (f) => (fa) => contramap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 297,
        "to": 297
      }
    }
  },
  {
    "name": "sign",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function sign(n: number): Ordering {\n  return n <= -1 ? -1 : n >= 1 ? 1 : 0\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ordering.ts",
      "lines": {
        "from": 17,
        "to": 19
      }
    }
  },
  {
    "name": "invert",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function invert(O: Ordering): Ordering {\n  switch (O) {\n    case -1:\n      return 1\n    case 1:\n      return -1\n    default:\n      return 0\n  }\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ordering.ts",
      "lines": {
        "from": 53,
        "to": 62
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function pipeable<F extends URIS4, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain4<F>\n  ? PipeableChain4<F>\n  : I extends Apply4<F>\n  ? PipeableApply4<F>\n  : I extends Functor4<F>\n  ? PipeableFunctor4<F>\n  : {}) &\n  (I extends Contravariant4<F> ? PipeableContravariant4<F> : {}) &\n  (I extends FunctorWithIndex4<F, infer Ix> ? PipeableFunctorWithIndex4<F, Ix> : {}) &\n  (I extends Bifunctor4<F> ? PipeableBifunctor4<F> : {}) &\n  (I extends Extend4<F> ? PipeableExtend4<F> : {}) &\n  (I extends FoldableWithIndex4<F, infer Ix>\n    ? PipeableFoldableWithIndex4<F, Ix>\n    : I extends Foldable4<F>\n    ? PipeableFoldable4<F>\n    : {}) &\n  (I extends Alt4<F> ? PipeableAlt4<F> : {}) &\n  (I extends FilterableWithIndex4<F, infer Ix>\n    ? PipeableFilterableWithIndex4<F, Ix>\n    : I extends Filterable4<F>\n    ? PipeableFilterable4<F>\n    : I extends Compactable4<F>\n    ? PipeableCompactable4<F>\n    : {}) &\n  (I extends Profunctor4<F> ? PipeableProfunctor4<F> : {}) &\n  (I extends Semigroupoid4<F> ? PipeableSemigroupoid4<F> : {}) &\n  (I extends MonadThrow4<F> ? PipeableMonadThrow4<F> : {})",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex4<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex4<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex4<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow4<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1224,
        "to": 1252
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F extends URIS3, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain3<F>\n  ? PipeableChain3<F>\n  : I extends Apply3<F>\n  ? PipeableApply3<F>\n  : I extends Functor3<F>\n  ? PipeableFunctor3<F>\n  : {}) &\n  (I extends Contravariant3<F> ? PipeableContravariant3<F> : {}) &\n  (I extends FunctorWithIndex3<F, infer Ix> ? PipeableFunctorWithIndex3<F, Ix> : {}) &\n  (I extends Bifunctor3<F> ? PipeableBifunctor3<F> : {}) &\n  (I extends Extend3<F> ? PipeableExtend3<F> : {}) &\n  (I extends FoldableWithIndex3<F, infer Ix>\n    ? PipeableFoldableWithIndex3<F, Ix>\n    : I extends Foldable3<F>\n    ? PipeableFoldable3<F>\n    : {}) &\n  (I extends Alt3<F> ? PipeableAlt3<F> : {}) &\n  (I extends FilterableWithIndex3<F, infer Ix>\n    ? PipeableFilterableWithIndex3<F, Ix>\n    : I extends Filterable3<F>\n    ? PipeableFilterable3<F>\n    : I extends Compactable3<F>\n    ? PipeableCompactable3<F>\n    : {}) &\n  (I extends Profunctor3<F> ? PipeableProfunctor3<F> : {}) &\n  (I extends Semigroupoid3<F> ? PipeableSemigroupoid3<F> : {}) &\n  (I extends MonadThrow3<F> ? PipeableMonadThrow3<F> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex3<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex3<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex3<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow3<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1253,
        "to": 1281
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F extends URIS3, I, E>(\n  I: { readonly URI: F } & I\n): (I extends Chain3C<F, E>\n  ? PipeableChain3C<F, E>\n  : I extends Apply3C<F, E>\n  ? PipeableApply3C<F, E>\n  : I extends Functor3C<F, E>\n  ? PipeableFunctor3C<F, E>\n  : {}) &\n  (I extends Contravariant3C<F, E> ? PipeableContravariant3C<F, E> : {}) &\n  (I extends FunctorWithIndex3C<F, infer Ix, E> ? PipeableFunctorWithIndex3C<F, Ix, E> : {}) &\n  (I extends Bifunctor3C<F, E> ? PipeableBifunctor3C<F, E> : {}) &\n  (I extends Extend3C<F, E> ? PipeableExtend3C<F, E> : {}) &\n  (I extends FoldableWithIndex3C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex3C<F, Ix, E>\n    : I extends Foldable3C<F, E>\n    ? PipeableFoldable3C<F, E>\n    : {}) &\n  (I extends Alt3C<F, E> ? PipeableAlt3C<F, E> : {}) &\n  (I extends FilterableWithIndex3C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex3C<F, Ix, E>\n    : I extends Filterable3C<F, E>\n    ? PipeableFilterable3C<F, E>\n    : I extends Compactable3C<F, E>\n    ? PipeableCompactable3C<F, E>\n    : {}) &\n  (I extends Profunctor3C<F, E> ? PipeableProfunctor3C<F, E> : {}) &\n  (I extends Semigroupoid3C<F, E> ? PipeableSemigroupoid3C<F, E> : {}) &\n  (I extends MonadThrow3C<F, E> ? PipeableMonadThrow3C<F, E> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex3C<F, Ix, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex3C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex3C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow3C<F, E> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1282,
        "to": 1310
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F extends URIS2, I, E>(\n  I: { readonly URI: F; readonly _E: E } & I\n): (I extends Chain2C<F, E>\n  ? PipeableChain2C<F, E>\n  : I extends Apply2C<F, E>\n  ? PipeableApply2C<F, E>\n  : I extends Functor2C<F, E>\n  ? PipeableFunctor2C<F, E>\n  : {}) &\n  (I extends Contravariant2C<F, E> ? PipeableContravariant2C<F, E> : {}) &\n  (I extends FunctorWithIndex2C<F, infer Ix, E> ? PipeableFunctorWithIndex2C<F, Ix, E> : {}) &\n  (I extends Extend2C<F, E> ? PipeableExtend2C<F, E> : {}) &\n  (I extends FoldableWithIndex2C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex2C<F, Ix, E>\n    : I extends Foldable2C<F, E>\n    ? PipeableFoldable2C<F, E>\n    : {}) &\n  (I extends Alt2C<F, E> ? PipeableAlt2C<F, E> : {}) &\n  (I extends FilterableWithIndex2C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex2C<F, Ix, E>\n    : I extends Filterable2C<F, E>\n    ? PipeableFilterable2C<F, E>\n    : I extends Compactable2C<F, E>\n    ? PipeableCompactable2C<F, E>\n    : {}) &\n  (I extends Profunctor2C<F, E> ? PipeableProfunctor2C<F, E> : {}) &\n  (I extends Semigroupoid2C<F, E> ? PipeableSemigroupoid2C<F, E> : {}) &\n  (I extends MonadThrow2C<F, E> ? PipeableMonadThrow2C<F, E> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; readonly _E: E; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex2C<F, Ix, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex2C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex2C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow2C<F, E> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1311,
        "to": 1338
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F extends URIS2, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain2<F>\n  ? PipeableChain2<F>\n  : I extends Apply2<F>\n  ? PipeableApply2<F>\n  : I extends Functor2<F>\n  ? PipeableFunctor2<F>\n  : {}) &\n  (I extends Contravariant2<F> ? PipeableContravariant2<F> : {}) &\n  (I extends FunctorWithIndex2<F, infer Ix> ? PipeableFunctorWithIndex2<F, Ix> : {}) &\n  (I extends Bifunctor2<F> ? PipeableBifunctor2<F> : {}) &\n  (I extends Extend2<F> ? PipeableExtend2<F> : {}) &\n  (I extends FoldableWithIndex2<F, infer Ix>\n    ? PipeableFoldableWithIndex2<F, Ix>\n    : I extends Foldable2<F>\n    ? PipeableFoldable2<F>\n    : {}) &\n  (I extends Alt2<F> ? PipeableAlt2<F> : {}) &\n  (I extends FilterableWithIndex2<F, infer Ix>\n    ? PipeableFilterableWithIndex2<F, Ix>\n    : I extends Filterable2<F>\n    ? PipeableFilterable2<F>\n    : I extends Compactable2<F>\n    ? PipeableCompactable2<F>\n    : {}) &\n  (I extends Profunctor2<F> ? PipeableProfunctor2<F> : {}) &\n  (I extends Semigroupoid2<F> ? PipeableSemigroupoid2<F> : {}) &\n  (I extends MonadThrow2<F> ? PipeableMonadThrow2<F> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex2<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex2<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex2<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow2<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1339,
        "to": 1367
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F extends URIS, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain1<F>\n  ? PipeableChain1<F>\n  : I extends Apply1<F>\n  ? PipeableApply1<F>\n  : I extends Functor1<F>\n  ? PipeableFunctor1<F>\n  : {}) &\n  (I extends Contravariant1<F> ? PipeableContravariant1<F> : {}) &\n  (I extends FunctorWithIndex1<F, infer Ix> ? PipeableFunctorWithIndex1<F, Ix> : {}) &\n  (I extends Extend1<F> ? PipeableExtend1<F> : {}) &\n  (I extends FoldableWithIndex1<F, infer Ix>\n    ? PipeableFoldableWithIndex1<F, Ix>\n    : I extends Foldable1<F>\n    ? PipeableFoldable1<F>\n    : {}) &\n  (I extends Alt1<F> ? PipeableAlt1<F> : {}) &\n  (I extends FilterableWithIndex1<F, infer Ix>\n    ? PipeableFilterableWithIndex1<F, Ix>\n    : I extends Filterable1<F>\n    ? PipeableFilterable1<F>\n    : I extends Compactable1<F>\n    ? PipeableCompactable1<F>\n    : {}) &\n  (I extends MonadThrow1<F> ? PipeableMonadThrow1<F> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex1<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex1<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex1<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow1<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1368,
        "to": 1393
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain<F>\n  ? PipeableChain<F>\n  : I extends Apply<F>\n  ? PipeableApply<F>\n  : I extends Functor<F>\n  ? PipeableFunctor<F>\n  : {}) &\n  (I extends Contravariant<F> ? PipeableContravariant<F> : {}) &\n  (I extends FunctorWithIndex<F, infer Ix> ? PipeableFunctorWithIndex<F, Ix> : {}) &\n  (I extends Bifunctor<F> ? PipeableBifunctor<F> : {}) &\n  (I extends Extend<F> ? PipeableExtend<F> : {}) &\n  (I extends FoldableWithIndex<F, infer Ix>\n    ? PipeableFoldableWithIndex<F, Ix>\n    : I extends Foldable<F>\n    ? PipeableFoldable<F>\n    : {}) &\n  (I extends Alt<F> ? PipeableAlt<F> : {}) &\n  (I extends FilterableWithIndex<F, infer Ix>\n    ? PipeableFilterableWithIndex<F, Ix>\n    : I extends Filterable<F>\n    ? PipeableFilterable<F>\n    : I extends Compactable<F>\n    ? PipeableCompactable<F>\n    : {}) &\n  (I extends Profunctor<F> ? PipeableProfunctor<F> : {}) &\n  (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) &\n  (I extends MonadThrow<F> ? PipeableMonadThrow<F> : {})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1394,
        "to": 1422
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\nexport function pipeable<F, I>(I: { readonly URI: F } & I): Record<string, unknown> {\n  const r: any = {}\n  if (isFunctor<F>(I)) {\n    const map: PipeableFunctor<F>['map'] = (f) => (fa) => I.map(fa, f)\n    r.map = map\n  }\n  if (isContravariant<F>(I)) {\n    const contramap: PipeableContravariant<F>['contramap'] = (f) => (fa) => I.contramap(fa, f)\n    r.contramap = contramap\n  }\n  if (isFunctorWithIndex<F>(I)) {\n    const mapWithIndex: PipeableFunctorWithIndex<F, unknown>['mapWithIndex'] = (f) => (fa) => I.mapWithIndex(fa, f)\n    r.mapWithIndex = mapWithIndex\n  }\n  if (isApply<F>(I)) {\n    const ap: PipeableApply<F>['ap'] = (fa) => (fab) => I.ap(fab, fa)\n    const apFirst: PipeableApply<F>['apFirst'] = (fb) => (fa) =>\n      I.ap(\n        I.map(fa, (a) => () => a),\n        fb\n      )\n    r.ap = ap\n    r.apFirst = apFirst\n    r.apSecond = <B>(fb: HKT<F, B>) => <A>(fa: HKT<F, A>): HKT<F, B> =>\n      I.ap(\n        I.map(fa, () => (b: B) => b),\n        fb\n      )\n  }\n  if (isChain<F>(I)) {\n    const chain: PipeableChain<F>['chain'] = (f) => (ma) => I.chain(ma, f)\n    const chainFirst: PipeableChain<F>['chainFirst'] = (f) => (ma) => I.chain(ma, (a) => I.map(f(a), () => a))\n    const flatten: PipeableChain<F>['flatten'] = (mma) => I.chain(mma, identity)\n    r.chain = chain\n    r.chainFirst = chainFirst\n    r.flatten = flatten\n  }\n  if (isBifunctor<F>(I)) {\n    const bimap: PipeableBifunctor<F>['bimap'] = (f, g) => (fa) => I.bimap(fa, f, g)\n    const mapLeft: PipeableBifunctor<F>['mapLeft'] = (f) => (fa) => I.mapLeft(fa, f)\n    r.bimap = bimap\n    r.mapLeft = mapLeft\n  }\n  if (isExtend<F>(I)) {\n    const extend: PipeableExtend<F>['extend'] = (f) => (wa) => I.extend(wa, f)\n    const duplicate: PipeableExtend<F>['duplicate'] = (wa) => I.extend(wa, identity)\n    r.extend = extend\n    r.duplicate = duplicate\n  }\n  if (isFoldable<F>(I)) {\n    const reduce: PipeableFoldable<F>['reduce'] = (b, f) => (fa) => I.reduce(fa, b, f)\n    const foldMap: PipeableFoldable<F>['foldMap'] = (M) => {\n      const foldMapM = I.foldMap(M)\n      return (f) => (fa) => foldMapM(fa, f)\n    }\n    const reduceRight: PipeableFoldable<F>['reduceRight'] = (b, f) => (fa) => I.reduceRight(fa, b, f)\n    r.reduce = reduce\n    r.foldMap = foldMap\n    r.reduceRight = reduceRight\n  }\n  if (isFoldableWithIndex<F>(I)) {\n    const reduceWithIndex: PipeableFoldableWithIndex<F, unknown>['reduceWithIndex'] = (b, f) => (fa) =>\n      I.reduceWithIndex(fa, b, f)\n    const foldMapWithIndex: PipeableFoldableWithIndex<F, unknown>['foldMapWithIndex'] = (M) => {\n      const foldMapM = I.foldMapWithIndex(M)\n      return (f) => (fa) => foldMapM(fa, f)\n    }\n    const reduceRightWithIndex: PipeableFoldableWithIndex<F, unknown>['reduceRightWithIndex'] = (b, f) => (fa) =>\n      I.reduceRightWithIndex(fa, b, f)\n    r.reduceWithIndex = reduceWithIndex\n    r.foldMapWithIndex = foldMapWithIndex\n    r.reduceRightWithIndex = reduceRightWithIndex\n  }\n  if (isAlt<F>(I)) {\n    const alt: PipeableAlt<F>['alt'] = (that) => (fa) => I.alt(fa, that)\n    r.alt = alt\n  }\n  if (isCompactable<F>(I)) {\n    r.compact = I.compact\n    r.separate = I.separate\n  }\n  if (isFilterable<F>(I)) {\n    const filter: PipeableFilterable<F>['filter'] = <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) =>\n      I.filter(fa, predicate)\n    const filterMap: PipeableFilterable<F>['filterMap'] = (f) => (fa) => I.filterMap(fa, f)\n    const partition: PipeableFilterable<F>['partition'] = <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) =>\n      I.partition(fa, predicate)\n    const partitionMap: PipeableFilterable<F>['partitionMap'] = (f) => (fa) => I.partitionMap(fa, f)\n    r.filter = filter\n    r.filterMap = filterMap\n    r.partition = partition\n    r.partitionMap = partitionMap\n  }\n  if (isFilterableWithIndex<F>(I)) {\n    const filterWithIndex: PipeableFilterableWithIndex<F, unknown>['filterWithIndex'] = <A>(\n      predicateWithIndex: PredicateWithIndex<unknown, A>\n    ) => (fa: HKT<F, A>) => I.filterWithIndex(fa, predicateWithIndex)\n    const filterMapWithIndex: PipeableFilterableWithIndex<F, unknown>['filterMapWithIndex'] = (f) => (fa) =>\n      I.filterMapWithIndex(fa, f)\n    const partitionWithIndex: PipeableFilterableWithIndex<F, unknown>['partitionWithIndex'] = <A>(\n      predicateWithIndex: PredicateWithIndex<unknown, A>\n    ) => (fa: HKT<F, A>) => I.partitionWithIndex(fa, predicateWithIndex)\n    const partitionMapWithIndex: PipeableFilterableWithIndex<F, unknown>['partitionMapWithIndex'] = (f) => (fa) =>\n      I.partitionMapWithIndex(fa, f)\n    r.filterWithIndex = filterWithIndex\n    r.filterMapWithIndex = filterMapWithIndex\n    r.partitionWithIndex = partitionWithIndex\n    r.partitionMapWithIndex = partitionMapWithIndex\n  }\n  if (isProfunctor<F>(I)) {\n    const promap: PipeableProfunctor<F>['promap'] = (f, g) => (fa) => I.promap(fa, f, g)\n    r.promap = promap\n  }\n  if (isSemigroupoid<F>(I)) {\n    const compose: PipeableSemigroupoid<F>['compose'] = (that) => (fa) => I.compose(fa, that)\n    r.compose = compose\n  }\n  if (isMonadThrow<F>(I)) {\n    const fromOption: PipeableMonadThrow<F>['fromOption'] = (onNone) => (ma) =>\n      ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value)\n    const fromEither: PipeableMonadThrow<F>['fromEither'] = (ma) =>\n      ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right)\n    const fromPredicate: PipeableMonadThrow<F>['fromPredicate'] = <E, A>(\n      predicate: Predicate<A>,\n      onFalse: (a: A) => E\n    ) => (a: A) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a)))\n    const filterOrElse: PipeableMonadThrow<F>['filterOrElse'] = <E, A>(\n      predicate: Predicate<A>,\n      onFalse: (a: A) => E\n    ) => (ma: HKT<F, A>) => I.chain(ma, (a) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a))))\n    r.fromOption = fromOption\n    r.fromEither = fromEither\n    r.fromPredicate = fromPredicate\n    r.filterOrElse = filterOrElse\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, unknown>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1423,
        "to": 1559
      }
    }
  },
  {
    "name": "randomInt",
    "text": "\n\n/**\n * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly\n * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of\n * `low` or `high` is not an integer.\n *\n * @since 2.0.0\n */\nexport function randomInt(low: number, high: number): IO<number> {\n  return pipe(\n    random,\n    map((n) => Math.floor((high - low + 1) * n + low))\n  )\n}",
    "docs": "/**\n * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly\n * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of\n * `low` or `high` is not an integer.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "low",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "high",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 22,
        "to": 27
      }
    }
  },
  {
    "name": "randomRange",
    "text": "\n\n/**\n * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what\n * happens if `maximum < minimum`.\n *\n * @since 2.0.0\n */\nexport function randomRange(min: number, max: number): IO<number> {\n  return pipe(\n    random,\n    map((n) => (max - min) * n + min)\n  )\n}",
    "docs": "/**\n * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what\n * happens if `maximum < minimum`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "min",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "max",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 35,
        "to": 40
      }
    }
  },
  {
    "name": "random",
    "text": "const random: IO<number> = () => Math.random()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 13,
        "to": 13
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<R, A>(S: Semigroup<A>): Semigroup<Reader<R, A>> {\n  return {\n    concat: (x, y) => (e) => S.concat(x(e), y(e))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 223,
        "to": 227
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<R, A>(M: Monoid<A>): Monoid<Reader<R, A>> {\n  return {\n    concat: getSemigroup<R, A>(M).concat,\n    empty: () => M.empty\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 233,
        "to": 238
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R>() => Reader<R, R> = () => F.identity",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "typeof import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").identity"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 37,
        "to": 37
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, A>(f: (r: R) => A) => Reader<R, A> = (f) => (r) => f(r)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 45,
        "to": 45
      }
    }
  },
  {
    "name": "local",
    "text": "const local: <Q, R>(f: (d: Q) => R) => <A>(ma: Reader<R, A>) => Reader<Q, A> = (f) => (ma) => (q) => ma(f(q))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(d: Q) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => (q: Q) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 58,
        "to": 58
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <R, A>(a: A) => Reader<R, A> = (a) => () => a",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 64,
        "to": 64
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, A>) => Reader<R, B> = (f) => (fa) => (r) => f(fa(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => (r: R) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 77,
        "to": 77
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <R, A>(fa: Reader<R, A>) => <B>(fab: Reader<R, (a: A) => B>) => Reader<R, B> = (fa) => (fab) => (r) =>\n  fab(r)(fa(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, (a: A) => B>) => (r: R) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 85,
        "to": 86
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <R, B>(fb: Reader<R, B>) => <A>(fa: Reader<R, A>): Reader<R, A> =>\n  F.pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 94,
        "to": 99
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, B>(fb: Reader<R, B>) => <A>(fa: Reader<R, A>): Reader<R, B> =>\n  F.pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 107,
        "to": 112
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW: <R, A, B>(f: (a: A) => Reader<R, B>) => <Q>(ma: Reader<Q, A>) => Reader<Q & R, B> = (f) => (\n  fa\n) => (r) => f(fa(r))(r)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<Q, A>) => (r: Q & R) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 120,
        "to": 122
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, R, B>(f: (a: A) => Reader<R, B>) => (ma: Reader<R, A>) => Reader<R, A> = (f) =>\n  chain((a) =>\n    F.pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 139,
        "to": 145
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <E, A>(la: Reader<E, A>) => <B>(ab: Reader<A, B>) => Reader<E, B> = (la) => (ab) =>\n  compose_(ab, la)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "la",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(ab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<A, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 159,
        "to": 160
      }
    }
  },
  {
    "name": "promap",
    "text": "const promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Reader<E, A>) => Reader<D, B> = (f, g) => (\n  fbc\n) => promap_(fbc, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 166,
        "to": 168
      }
    }
  },
  {
    "name": "local",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function local<Q, R>(f: (f: Q) => R): <E, A>(ma: ReaderEither<R, E, A>) => ReaderEither<Q, E, A> {\n  return (ma) => (q) => ma(f(q))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(f: Q) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 152,
        "to": 154
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): <R>(...a: A) => ReaderEither<R, E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 160,
        "to": 164
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<R, E, A>(S: Semigroup<A>): Semigroup<ReaderEither<R, E, A>> {\n  return R.getSemigroup(E.getSemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 372,
        "to": 374
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<R, E, A>(S: Semigroup<A>): Semigroup<ReaderEither<R, E, A>> {\n  return R.getSemigroup(E.getApplySemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 383,
        "to": 385
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<R, E, A>(M: Monoid<A>): Monoid<ReaderEither<R, E, A>> {\n  return {\n    concat: getApplySemigroup<R, E, A>(M).concat,\n    empty: right(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 391,
        "to": 396
      }
    }
  },
  {
    "name": "getReaderValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.3.0\n */\nexport function getReaderValidation<E>(\n  S: Semigroup<E>\n): Monad3C<URI, E> & Bifunctor3<URI> & Alt3C<URI, E> & MonadThrow3C<URI, E> {\n  const V = getValidationM(S, R.monadReader)\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: V.ap,\n    of,\n    chain: chain_,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    alt: V.alt,\n    throwError: throwError_\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.3.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<\"ReaderEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<\"ReaderEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 402,
        "to": 418
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R, E = never>() => ReaderEither<R, E, R> = () => E.right",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "typeof import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").right"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 66,
        "to": 66
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, E = never, A = never>(f: (r: R) => A) => ReaderEither<R, E, A> = (f) => flow(f, E.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<never, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 72,
        "to": 72
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <R, E, A>(ma: E.Either<E, A>) => ReaderEither<R, E, A> = (ma) =>\n  E.isLeft(ma) ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 78,
        "to": 79
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <R, A>(ma: Option<A>) => ReaderEither<R, E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 85,
        "to": 86
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => ReaderEither<U, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => ReaderEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<unknown, never, A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<unknown, E, never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 92,
        "to": 95
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <R, E, B>(onLeft: (e: E) => Reader<R, B>) => <Q, A>(\n  ma: ReaderEither<Q, E, A>\n): Reader<Q & R, A | B> => pipe(ma, R.chain(E.fold<E, A, R.Reader<Q & R, A | B>>(onLeft, R.of)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<Q & R, B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "orElse",
    "text": "const orElse: <E, R, M, A>(\n  onLeft: (e: E) => ReaderEither<R, M, A>\n) => (ma: ReaderEither<R, E, A>) => ReaderEither<R, M, A> = (f) => R.chain(E.fold(f, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<M, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 136,
        "to": 138
      }
    }
  },
  {
    "name": "chainEitherKW",
    "text": "const chainEitherKW: <E, A, B>(\n  f: (a: A) => Either<E, B>\n) => <R, D>(ma: ReaderEither<R, D, A>) => ReaderEither<R, D | E, B> = (f) => chainW(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 172,
        "to": 174
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n    ma: ReaderEither<R, E, A>\n  ) => ReaderEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(ma: ReaderEither<R, E, A>) =>\n  pipe(\n    ma,\n    chain((a) => (predicate(a) ? right(a) : left(onFalse(a))))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 188,
        "to": 197
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, B> = (f) =>\n  R.map(E.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 207,
        "to": 208
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <R, A>(fa: ReaderEither<R, E, A>) => ReaderEither<R, G, A> = (f) =>\n  R.map(E.mapLeft(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 229,
        "to": 230
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <R, E, B>(\n  fb: ReaderEither<R, E, B>\n) => <A>(fa: ReaderEither<R, E, A>) => ReaderEither<R, E, A> = (fb) => (fa) =>\n  pipe(\n    fa,\n    map((a) => () => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 250,
        "to": 257
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, E, B>(fb: ReaderEither<R, E, B>) => <A>(fa: ReaderEither<R, E, A>): ReaderEither<R, E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 265,
        "to": 270
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW = <R, E, A, B>(f: (a: A) => ReaderEither<R, E, B>) => <Q, D>(\n  ma: ReaderEither<Q, D, A>\n): ReaderEither<Q & R, D | E, B> => pipe(ma, R.chain(E.fold<D, A, ReaderEither<Q & R, D | E, B>>(left, f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<Q & R, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 278,
        "to": 280
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <R, E, A, B>(\n  f: (a: A) => ReaderEither<R, E, B>\n) => (ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 299,
        "to": 307
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <R, E, A>(\n  that: () => ReaderEither<R, E, A>\n) => (fa: ReaderEither<R, E, A>) => ReaderEither<R, E, A> = (that) => R.chain(E.fold(that, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 324,
        "to": 326
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getReaderM<M extends URIS3>(M: Monad3<M>): ReaderM3<M>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 123,
        "to": 123
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\nexport function getReaderM<M extends URIS2>(M: Monad2<M>): ReaderM2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 124,
        "to": 124
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\nexport function getReaderM<M extends URIS2, E>(M: Monad2C<M, E>): ReaderM2C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 125,
        "to": 125
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\nexport function getReaderM<M extends URIS>(M: Monad1<M>): ReaderM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 126,
        "to": 126
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\nexport function getReaderM<M>(M: Monad<M>): ReaderM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 127,
        "to": 127
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\nexport function getReaderM<M>(M: Monad<M>): ReaderM<M> {\n  return {\n    map: (ma, f) => (r) => M.map(ma(r), f),\n    of: (a) => () => M.of(a),\n    ap: (mab, ma) => (r) => M.ap(mab(r), ma(r)),\n    chain: (ma, f) => (r) => M.chain(ma(r), (a) => f(a)(r)),\n    ask: () => M.of,\n    asks: (f) => (r) => M.map(M.of(r), f),\n    local: (ma, f) => (q) => ma(f(q)),\n    fromReader: (ma) => (r) => M.of(ma(r)),\n    fromM: (ma) => () => ma\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 128,
        "to": 140
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromIOK<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>): <R>(...a: A) => ReaderTask<R, B> {\n  return (...a) => fromIO(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromTaskK<A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Task<B>\n): <R>(...a: A) => ReaderTask<R, B> {\n  return (...a) => fromTask(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 95,
        "to": 99
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.3.0\n */\nexport function getSemigroup<R, A>(S: Semigroup<A>): Semigroup<ReaderTask<R, A>> {\n  return R.getSemigroup(T.getSemigroup<A>(S))\n}",
    "docs": "/**\n * @category instances\n * @since 2.3.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 239,
        "to": 241
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.3.0\n */\nexport function getMonoid<R, A>(M: Monoid<A>): Monoid<ReaderTask<R, A>> {\n  return {\n    concat: getSemigroup<R, A>(M).concat,\n    empty: of(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.3.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 247,
        "to": 252
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.4.0\n */\nexport function run<R, A>(ma: ReaderTask<R, A>, r: R): Promise<A> {\n  return ma(r)()\n}",
    "docs": "/**\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 295,
        "to": 297
      }
    }
  },
  {
    "name": "fromReader",
    "text": "const fromReader: <R, A = never>(ma: Reader<R, A>) => ReaderTask<R, A> = (ma) => flow(ma, T.of)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 44,
        "to": 44
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R>() => ReaderTask<R, R> = () => T.of",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 58,
        "to": 58
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, A = never>(f: (r: R) => A) => ReaderTask<R, A> = (f) => (r) => pipe(T.of(r), T.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 64,
        "to": 64
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "const chainIOK: <A, B>(f: (a: A) => IO<B>) => <R>(ma: ReaderTask<R, A>) => ReaderTask<R, B> = (f) =>\n  chain((a) => fromIO(f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 88,
        "to": 89
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "const chainTaskK: <A, B>(f: (a: A) => Task<B>) => <R>(ma: ReaderTask<R, A>) => ReaderTask<R, B> = (f) =>\n  chain((a) => fromTask(f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 105,
        "to": 106
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R>(fa: ReaderTask<R, A>) => ReaderTask<R, B> = (f) => (fa) =>\n  flow(fa, T.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => (r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 116,
        "to": 117
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <R, A>(fa: ReaderTask<R, A>) => <B>(fab: ReaderTask<R, (a: A) => B>) => ReaderTask<R, B> = (fa) => (\n  fab\n) => (r) => pipe(fab(r), T.ap(fa(r)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, (a: A) => B>) => (r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 125,
        "to": 127
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <R, B>(fb: ReaderTask<R, B>) => <A>(fa: ReaderTask<R, A>): ReaderTask<R, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 135,
        "to": 140
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, B>(fb: ReaderTask<R, B>) => <A>(fa: ReaderTask<R, A>): ReaderTask<R, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 148,
        "to": 153
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <R, A>(a: A) => ReaderTask<R, A> = (a) => () => T.of(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 159,
        "to": 159
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, R, B>(f: (a: A) => ReaderTask<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, B> = (f) => (\n  fa\n) => (r) =>\n  pipe(\n    fa(r),\n    T.chain((a) => f(a)(r))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => (r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 167,
        "to": 173
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, R, B>(f: (a: A) => ReaderTask<R, B>) => (ma: ReaderTask<R, A>) => ReaderTask<R, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 182,
        "to": 188
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function left<R, E = never, A = never>(e: E): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.left(e))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 46,
        "to": 48
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightTask<R, E = never, A = never>(ma: Task<A>): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.rightTask(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftTask<R, E = never, A = never>(me: Task<E>): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.leftTask(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 68,
        "to": 70
      }
    }
  },
  {
    "name": "leftReaderTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function leftReaderTask<R, E = never, A = never>(me: ReaderTask<R, E>): ReaderTaskEither<R, E, A> {\n  return (r) => TE.leftTask(me(r))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 91,
        "to": 93
      }
    }
  },
  {
    "name": "rightReaderTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function rightReaderTask<R, E = never, A = never>(ma: ReaderTask<R, A>): ReaderTaskEither<R, E, A> {\n  return (r) => TE.rightTask(ma(r))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "leftReader",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftReader<R, E = never, A = never>(me: Reader<R, E>): ReaderTaskEither<R, E, A> {\n  return (r) => TE.left(me(r))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromIOEither<R, E, A>(ma: IOEither<E, A>): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.fromIOEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 115,
        "to": 117
      }
    }
  },
  {
    "name": "fromReaderEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromReaderEither<R, E, A>(ma: ReaderEither<R, E, A>): ReaderTaskEither<R, E, A> {\n  return (r) => TE.fromEither(ma(r))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 123,
        "to": 125
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightIO<R, E = never, A = never>(ma: IO<A>): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.rightIO(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 131,
        "to": 133
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftIO<R, E = never, A = never>(me: IO<E>): ReaderTaskEither<R, E, A> {\n  return fromTaskEither(TE.leftIO(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 139,
        "to": 141
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category destructors\n * @since 2.0.0\n */\nexport function fold<R, E, A, B>(\n  onLeft: (e: E) => ReaderTask<R, B>,\n  onRight: (a: A) => ReaderTask<R, B>\n): (ma: ReaderTaskEither<R, E, A>) => ReaderTask<R, B> {\n  return (ma) => (r) =>\n    pipe(\n      ma(r),\n      TE.fold(\n        (e) => onLeft(e)(r),\n        (a) => onRight(a)(r)\n      )\n    )\n}",
    "docs": "/**\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        },
        {
          "name": "onRight",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 188,
        "to": 200
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function orElse<R, E, A, M>(\n  onLeft: (e: E) => ReaderTaskEither<R, M, A>\n): (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, M, A> {\n  return (ma) => (r) => TE.orElse<E, A, M>((e) => onLeft(e)(r))(ma(r))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 229,
        "to": 233
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function swap<R, E, A>(ma: ReaderTaskEither<R, E, A>): ReaderTaskEither<R, A, E> {\n  return (e) => TE.swap(ma(e))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, A, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 239,
        "to": 241
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): <R>(...a: A) => ReaderTaskEither<R, E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 269,
        "to": 273
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromIOEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): <R>(...a: A) => ReaderTaskEither<R, E, B> {\n  return (...a) => fromIOEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 297,
        "to": 301
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromTaskEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n): <R>(...a: A) => ReaderTaskEither<R, E, B> {\n  return (...a) => fromTaskEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 325,
        "to": 329
      }
    }
  },
  {
    "name": "bracket",
    "text": "\n\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @MonadThrow\n * @since 2.0.4\n */\nexport function bracket<R, E, A, B>(\n  aquire: ReaderTaskEither<R, E, A>,\n  use: (a: A) => ReaderTaskEither<R, E, B>,\n  release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>\n): ReaderTaskEither<R, E, B> {\n  return (r) =>\n    TE.bracket(\n      aquire(r),\n      (a) => use(a)(r),\n      (a, e) => release(a, e)(r)\n    )\n}",
    "docs": "/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @MonadThrow\n * @since 2.0.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "aquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 495,
        "to": 506
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<R, E, A>(S: Semigroup<A>): Semigroup<ReaderTaskEither<R, E, A>> {\n  return R.getSemigroup(TE.getSemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 572,
        "to": 574
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<R, E, A>(S: Semigroup<A>): Semigroup<ReaderTaskEither<R, E, A>> {\n  return R.getSemigroup(TE.getApplySemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 583,
        "to": 585
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<R, E, A>(M: Monoid<A>): Monoid<ReaderTaskEither<R, E, A>> {\n  return {\n    concat: getApplySemigroup<R, E, A>(M).concat,\n    empty: right(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 591,
        "to": 596
      }
    }
  },
  {
    "name": "getReaderTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.3.0\n */\nexport function getReaderTaskValidation<E>(\n  S: Semigroup<E>\n): Monad3C<URI, E> & Bifunctor3<URI> & Alt3C<URI, E> & MonadTask3C<URI, E> & MonadThrow3C<URI, E> {\n  const V = getValidationM(S, monadReaderTask)\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    of,\n    chain: chain_,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    ap: V.ap,\n    alt: V.alt,\n    fromIO: fromIO_,\n    fromTask: fromTask_,\n    throwError: throwError_\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.3.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<\"ReaderTaskEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 602,
        "to": 620
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.0.0\n */\nexport function run<R, E, A>(ma: ReaderTaskEither<R, E, A>, r: R): Promise<Either<E, A>> {\n  return ma(r)()\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 671,
        "to": 673
      }
    }
  },
  {
    "name": "right",
    "text": "const right: <R, E = never, A = never>(a: A) => ReaderTaskEither<R, E, A> = (a) => () => TE.right(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 54,
        "to": 54
      }
    }
  },
  {
    "name": "rightReader",
    "text": "const rightReader: <R, E = never, A = never>(ma: Reader<R, A>) => ReaderTaskEither<R, E, A> = (ma) => (r) =>\n  TE.right(ma(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 84,
        "to": 85
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R, E = never>() => ReaderTaskEither<R, E, R> = () => TE.right",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<E = never, A = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 147,
        "to": 147
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, E = never, A = never>(f: (r: R) => A) => ReaderTaskEither<R, E, A> = (f) => (r) =>\n  pipe(TE.right(r), TE.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<never, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 153,
        "to": 154
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <R, E, A>(ma: Either<E, A>) => ReaderTaskEither<R, E, A> = (ma) =>\n  ma._tag === 'Left' ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 160,
        "to": 161
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <R, A>(ma: Option<A>) => ReaderTaskEither<R, E, A> = (onNone) => (\n  ma\n) => (ma._tag === 'None' ? left(onNone()) : right(ma.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 167,
        "to": 169
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <U>(a: A) => ReaderTaskEither<U, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => ReaderTaskEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<unknown, never, A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<unknown, E, never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 175,
        "to": 178
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <R, E, B>(\n  onLeft: (e: E) => ReaderTask<R, B>\n): (<Q, A>(ma: ReaderTaskEither<Q, E, A>) => ReaderTask<Q & R, A | B>) => (ma) => (r) =>\n  TE.getOrElseW((e: E) => onLeft(e)(r))(ma(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<Q & R, B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 208,
        "to": 211
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n    ma: ReaderTaskEither<R, E, A>\n  ) => ReaderTaskEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(ma: ReaderTaskEither<R, E, A>) =>\n  pipe(\n    ma,\n    chain((a) => (predicate(a) ? right(a) : left(onFalse(a))))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 254,
        "to": 263
      }
    }
  },
  {
    "name": "chainEitherKW",
    "text": "const chainEitherKW: <E, A, B>(\n  f: (a: A) => Either<E, B>\n) => <R, D>(ma: ReaderTaskEither<R, D, A>) => ReaderTaskEither<R, D | E, B> = (f) => chainW(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 281,
        "to": 283
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW: <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n) => <R, D>(ma: ReaderTaskEither<R, D, A>) => ReaderTaskEither<R, D | E, B> = (f) => chainW(fromIOEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 309,
        "to": 311
      }
    }
  },
  {
    "name": "chainTaskEitherKW",
    "text": "const chainTaskEitherKW: <E, A, B>(\n  f: (a: A) => TaskEither<E, B>\n) => <R, D>(ma: ReaderTaskEither<R, D, A>) => ReaderTaskEither<R, D | E, B> = (f) => chainW(fromTaskEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 337,
        "to": 339
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R, E>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B> = (\n  f\n) => (fa) => flow(fa, TE.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => (r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 360,
        "to": 362
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <R>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, B> = (f, g) => (fa) => bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 370,
        "to": 373
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <R, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, G, A> = (\n  f\n) => (fa) => mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 381,
        "to": 383
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <R, E, A>(\n  fa: ReaderTaskEither<R, E, A>\n) => <B>(fab: ReaderTaskEither<R, E, (a: A) => B>) => ReaderTaskEither<R, E, B> = (fa) => (fab) => (r) =>\n  pipe(fab(r), TE.ap(fa(r)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, (a: A) => B>) => (r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 391,
        "to": 394
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <R, E, B>(\n  fb: ReaderTaskEither<R, E, B>\n) => <A>(fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A> = (fb) => (fa) =>\n  pipe(\n    fa,\n    map((a) => () => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 402,
        "to": 409
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, E, B>(fb: ReaderTaskEither<R, E, B>) => <A>(\n  fa: ReaderTaskEither<R, E, A>\n): ReaderTaskEither<R, E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 417,
        "to": 424
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW: <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n) => <Q, D>(ma: ReaderTaskEither<Q, D, A>) => ReaderTaskEither<Q & R, D | E, B> = (f) => (fa) => (r) =>\n  pipe(\n    fa(r),\n    TE.chainW((a) => f(a)(r))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q, D, A>) => (r: Q & R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 432,
        "to": 438
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n) => (ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 457,
        "to": 465
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <R, E, A>(\n  that: () => ReaderTaskEither<R, E, A>\n) => (fa: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A> = (that) => (fa) => alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 482,
        "to": 484
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.5.0\n */\n// tslint:disable-next-line: readonly-array\nexport function fromArray<A>(as: Array<A>): ReadonlyArray<A> {\n  const l = as.length\n  if (l === 0) {\n    return empty\n  }\n  const ras = Array(l)\n  for (let i = 0; i < l; i++) {\n    ras[i] = as[i]\n  }\n  return ras\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 41,
        "to": 51
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\n// tslint:disable-next-line: readonly-array\nexport function toArray<A>(ras: ReadonlyArray<A>): Array<A> {\n  const l = ras.length\n  const as = Array(l)\n  for (let i = 0; i < l; i++) {\n    as[i] = ras[i]\n  }\n  return as\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ras",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 58,
        "to": 65
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<A>(S: Show<A>): Show<ReadonlyArray<A>> {\n  return {\n    show: (as) => `[${as.map(S.show).join(', ')}]`\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 71,
        "to": 75
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`\n *\n * @example\n * import { getMonoid } from 'fp-ts/lib/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid<A = never>(): Monoid<ReadonlyArray<A>> {\n  return {\n    concat,\n    empty\n  }\n}",
    "docs": "/**\n * Returns a `Monoid` for `ReadonlyArray<A>`\n *\n * @example\n * import { getMonoid } from 'fp-ts/lib/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 108,
        "to": 113
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import { eqString } from 'fp-ts/lib/Eq'\n * import { getEq } from 'fp-ts/lib/ReadonlyArray'\n *\n * const E = getEq(eqString)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<ReadonlyArray<A>> {\n  return {\n    equals: (xs, ys) => xs === ys || (xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])))\n  }\n}",
    "docs": "/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import { eqString } from 'fp-ts/lib/Eq'\n * import { getEq } from 'fp-ts/lib/ReadonlyArray'\n *\n * const E = getEq(eqString)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 131,
        "to": 135
      }
    }
  },
  {
    "name": "getOrd",
    "text": "\n\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/lib/ReadonlyArray'\n * import { ordString } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordString)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getOrd<A>(O: Ord<A>): Ord<ReadonlyArray<A>> {\n  return fromCompare((a, b) => {\n    const aLen = a.length\n    const bLen = b.length\n    const len = Math.min(aLen, bLen)\n    for (let i = 0; i < len; i++) {\n      const ordering = O.compare(a[i], b[i])\n      if (ordering !== 0) {\n        return ordering\n      }\n    }\n    return ordNumber.compare(aLen, bLen)\n  })\n}",
    "docs": "/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/lib/ReadonlyArray'\n * import { ordString } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordString)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 156,
        "to": 169
      }
    }
  },
  {
    "name": "makeBy",
    "text": "\n\n/**\n * Return a list of length `n` with element `i` initialized with `f(i)`\n *\n * @example\n * import { makeBy } from 'fp-ts/lib/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function makeBy<A>(n: number, f: (i: number) => A): ReadonlyArray<A> {\n  // tslint:disable-next-line: readonly-array\n  const r: Array<A> = []\n  for (let i = 0; i < n; i++) {\n    r.push(f(i))\n  }\n  return r\n}",
    "docs": "/**\n * Return a list of length `n` with element `i` initialized with `f(i)`\n *\n * @example\n * import { makeBy } from 'fp-ts/lib/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 190,
        "to": 197
      }
    }
  },
  {
    "name": "range",
    "text": "\n\n/**\n * Create an array containing a range of integers, including both endpoints\n *\n * @example\n * import { range } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function range(start: number, end: number): ReadonlyArray<number> {\n  return makeBy(end - start + 1, (i) => start + i)\n}",
    "docs": "/**\n * Create an array containing a range of integers, including both endpoints\n *\n * @example\n * import { range } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "start",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly number[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 210,
        "to": 212
      }
    }
  },
  {
    "name": "replicate",
    "text": "\n\n/**\n * Create an array containing a value repeated the specified number of times\n *\n * @example\n * import { replicate } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function replicate<A>(n: number, a: A): ReadonlyArray<A> {\n  return makeBy(n, () => a)\n}",
    "docs": "/**\n * Create an array containing a value repeated the specified number of times\n *\n * @example\n * import { replicate } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 225,
        "to": 227
      }
    }
  },
  {
    "name": "flatten",
    "text": "\n\n/**\n * Removes one level of nesting\n *\n * @example\n * import { flatten } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(flatten([[1], [2], [3]]), [1, 2, 3])\n *\n * @category Monad\n * @since 2.5.0\n */\nexport function flatten<A>(mma: ReadonlyArray<ReadonlyArray<A>>): ReadonlyArray<A> {\n  let rLen = 0\n  const len = mma.length\n  for (let i = 0; i < len; i++) {\n    rLen += mma[i].length\n  }\n  const r = Array(rLen)\n  let start = 0\n  for (let i = 0; i < len; i++) {\n    const arr = mma[i]\n    const l = arr.length\n    for (let j = 0; j < l; j++) {\n      r[j + start] = arr[j]\n    }\n    start += l\n  }\n  return r\n}",
    "docs": "/**\n * Removes one level of nesting\n *\n * @example\n * import { flatten } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(flatten([[1], [2], [3]]), [1, 2, 3])\n *\n * @category Monad\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "readonly (readonly A[])[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 240,
        "to": 257
      }
    }
  },
  {
    "name": "foldLeft",
    "text": "\n\n/**\n * Break an array into its first element and remaining elements\n *\n * @example\n * import { foldLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = foldLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function foldLeft<A, B>(\n  onNil: () => B,\n  onCons: (head: A, tail: ReadonlyArray<A>) => B\n): (as: ReadonlyArray<A>) => B {\n  return (as) => (isEmpty(as) ? onNil() : onCons(as[0], as.slice(1)))\n}",
    "docs": "/**\n * Break an array into its first element and remaining elements\n *\n * @example\n * import { foldLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = foldLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNil",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        },
        {
          "name": "onCons",
          "type": {
            "__tag": "Other",
            "values": "(head: A, tail: readonly A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 271,
        "to": 276
      }
    }
  },
  {
    "name": "foldRight",
    "text": "\n\n/**\n * Break an array into its initial elements and the last element\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function foldRight<A, B>(\n  onNil: () => B,\n  onCons: (init: ReadonlyArray<A>, last: A) => B\n): (as: ReadonlyArray<A>) => B {\n  return (as) => (isEmpty(as) ? onNil() : onCons(as.slice(0, as.length - 1), as[as.length - 1]))\n}",
    "docs": "/**\n * Break an array into its initial elements and the last element\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onNil",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        },
        {
          "name": "onCons",
          "type": {
            "__tag": "Other",
            "values": "(init: readonly A[], last: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 284,
        "to": 289
      }
    }
  },
  {
    "name": "scanLeft",
    "text": "\n\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * ```ts\n * import { scanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n * ```\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function scanLeft<A, B>(b: B, f: (b: B, a: A) => B): (as: ReadonlyArray<A>) => ReadonlyArray<B> {\n  return (as) => {\n    const l = as.length\n    // tslint:disable-next-line: readonly-array\n    const r: Array<B> = new Array(l + 1)\n    r[0] = b\n    for (let i = 0; i < l; i++) {\n      r[i + 1] = f(r[i], as[i])\n    }\n    return r\n  }\n}",
    "docs": "/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * ```ts\n * import { scanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n * ```\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 303,
        "to": 314
      }
    }
  },
  {
    "name": "scanRight",
    "text": "\n\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function scanRight<A, B>(b: B, f: (a: A, b: B) => B): (as: ReadonlyArray<A>) => ReadonlyArray<B> {\n  return (as) => {\n    const l = as.length\n    // tslint:disable-next-line: readonly-array\n    const r: Array<B> = new Array(l + 1)\n    r[l] = b\n    for (let i = l - 1; i >= 0; i--) {\n      r[i] = f(as[i], r[i + 1])\n    }\n    return r\n  }\n}",
    "docs": "/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 327,
        "to": 338
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "\n\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @since 2.5.0\n */\nexport function isEmpty<A>(as: ReadonlyArray<A>): boolean {\n  return as.length === 0\n}",
    "docs": "/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 350,
        "to": 352
      }
    }
  },
  {
    "name": "isNonEmpty",
    "text": "\n\n/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyReadonlyArray<A>`\n *\n * @category guards\n * @since 2.5.0\n */\nexport function isNonEmpty<A>(as: ReadonlyArray<A>): as is ReadonlyNonEmptyArray<A> {\n  return as.length > 0\n}",
    "docs": "/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyReadonlyArray<A>`\n *\n * @category guards\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 360,
        "to": 362
      }
    }
  },
  {
    "name": "isOutOfBound",
    "text": "\n\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport function isOutOfBound<A>(i: number, as: ReadonlyArray<A>): boolean {\n  return i < 0 || i >= as.length\n}",
    "docs": "/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 369,
        "to": 371
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n/**\n * This function provides a safe way to read a value at a particular index from an array\n *\n * @example\n * import { lookup } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(lookup(1, [1, 2, 3]), some(2))\n * assert.deepStrictEqual(lookup(3, [1, 2, 3]), none)\n *\n * @since 2.5.0\n */\nexport function lookup<A>(i: number, as: ReadonlyArray<A>): Option<A> {\n  return isOutOfBound(i, as) ? none : some(as[i])\n}",
    "docs": "/**\n * This function provides a safe way to read a value at a particular index from an array\n *\n * @example\n * import { lookup } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(lookup(1, [1, 2, 3]), some(2))\n * assert.deepStrictEqual(lookup(3, [1, 2, 3]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 385,
        "to": 387
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * Attaches an element to the front of an array, creating a new non empty array\n *\n * @example\n * import { cons } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(cons(0, [1, 2, 3]), [0, 1, 2, 3])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function cons<A>(head: A, tail: ReadonlyArray<A>): ReadonlyNonEmptyArray<A> {\n  const len = tail.length\n  const r = Array(len + 1)\n  for (let i = 0; i < len; i++) {\n    r[i + 1] = tail[i]\n  }\n  r[0] = head\n  return (r as unknown) as ReadonlyNonEmptyArray<A>\n}",
    "docs": "/**\n * Attaches an element to the front of an array, creating a new non empty array\n *\n * @example\n * import { cons } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(cons(0, [1, 2, 3]), [0, 1, 2, 3])\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 400,
        "to": 408
      }
    }
  },
  {
    "name": "snoc",
    "text": "\n\n/**\n * Append an element to the end of an array, creating a new non empty array\n *\n * @example\n * import { snoc } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(snoc([1, 2, 3], 4), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function snoc<A>(init: ReadonlyArray<A>, end: A): ReadonlyNonEmptyArray<A> {\n  const len = init.length\n  const r = Array(len + 1)\n  for (let i = 0; i < len; i++) {\n    r[i] = init[i]\n  }\n  r[len] = end\n  return (r as unknown) as ReadonlyNonEmptyArray<A>\n}",
    "docs": "/**\n * Append an element to the end of an array, creating a new non empty array\n *\n * @example\n * import { snoc } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(snoc([1, 2, 3], 4), [1, 2, 3, 4])\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "init",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 421,
        "to": 429
      }
    }
  },
  {
    "name": "head",
    "text": "\n\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport function head<A>(as: ReadonlyArray<A>): Option<A> {\n  return isEmpty(as) ? none : some(as[0])\n}",
    "docs": "/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 443,
        "to": 445
      }
    }
  },
  {
    "name": "last",
    "text": "\n\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport function last<A>(as: ReadonlyArray<A>): Option<A> {\n  return lookup(as.length - 1, as)\n}",
    "docs": "/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 459,
        "to": 461
      }
    }
  },
  {
    "name": "tail",
    "text": "\n\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport function tail<A>(as: ReadonlyArray<A>): Option<ReadonlyArray<A>> {\n  return isEmpty(as) ? none : some(as.slice(1))\n}",
    "docs": "/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 475,
        "to": 477
      }
    }
  },
  {
    "name": "init",
    "text": "\n\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport function init<A>(as: ReadonlyArray<A>): Option<ReadonlyArray<A>> {\n  const len = as.length\n  return len === 0 ? none : some(as.slice(0, len - 1))\n}",
    "docs": "/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 491,
        "to": 494
      }
    }
  },
  {
    "name": "takeLeft",
    "text": "\n\n/**\n * Keep only a number of elements from the start of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { takeLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function takeLeft(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => as.slice(0, n)\n}",
    "docs": "/**\n * Keep only a number of elements from the start of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { takeLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 508,
        "to": 510
      }
    }
  },
  {
    "name": "takeRight",
    "text": "\n\n/**\n * Keep only a number of elements from the end of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { takeRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5])\n *\n * @since 2.5.0\n */\nexport function takeRight(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => (n === 0 ? empty : as.slice(-n))\n}",
    "docs": "/**\n * Keep only a number of elements from the end of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { takeRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 523,
        "to": 525
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>",
    "docs": "/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 538,
        "to": 538
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 539,
        "to": 539
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => {\n    const i = spanIndexUncurry(as, predicate)\n    const init = Array(i)\n    for (let j = 0; j < i; j++) {\n      init[j] = as[j]\n    }\n    return init\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 540,
        "to": 549
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\n\n/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @since 2.5.0\n */\nexport function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Spanned<B, A>",
    "docs": "/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<B, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 582,
        "to": 582
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned<A, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 583,
        "to": 583
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned<A, A> {\n  return (as) => {\n    const i = spanIndexUncurry(as, predicate)\n    const init = Array(i)\n    for (let j = 0; j < i; j++) {\n      init[j] = as[j]\n    }\n    const l = as.length\n    const rest = Array(l - i)\n    for (let j = i; j < l; j++) {\n      rest[j - i] = as[j]\n    }\n    return { init, rest }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 584,
        "to": 598
      }
    }
  },
  {
    "name": "dropLeft",
    "text": "\n\n/**\n * Drop a number of elements from the start of an array, creating a new array\n *\n * @example\n * import { dropLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function dropLeft(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => as.slice(n, as.length)\n}",
    "docs": "/**\n * Drop a number of elements from the start of an array, creating a new array\n *\n * @example\n * import { dropLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 611,
        "to": 613
      }
    }
  },
  {
    "name": "dropRight",
    "text": "\n\n/**\n * Drop a number of elements from the end of an array, creating a new array\n *\n * @example\n * import { dropRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3, 4, 5]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function dropRight(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => as.slice(0, as.length - n)\n}",
    "docs": "/**\n * Drop a number of elements from the end of an array, creating a new array\n *\n * @example\n * import { dropRight } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3, 4, 5]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 626,
        "to": 628
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\n\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { dropLeftWhile } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropLeftWhile((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), [2, 4, 5])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function dropLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => {\n    const i = spanIndexUncurry(as, predicate)\n    const l = as.length\n    const rest = Array(l - i)\n    for (let j = i; j < l; j++) {\n      rest[j - i] = as[j]\n    }\n    return rest\n  }\n}",
    "docs": "/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { dropLeftWhile } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(dropLeftWhile((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), [2, 4, 5])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 641,
        "to": 651
      }
    }
  },
  {
    "name": "findIndex",
    "text": "\n\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport function findIndex<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<number> {\n  return (as) => {\n    const len = as.length\n    for (let i = 0; i < len; i++) {\n      if (predicate(as[i])) {\n        return some(i)\n      }\n    }\n    return none\n  }\n}",
    "docs": "/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 665,
        "to": 675
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\n\n/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findFirst((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @since 2.5.0\n */\nexport function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>",
    "docs": "/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findFirst((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 688,
        "to": 688
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 689,
        "to": 689
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A> {\n  return (as) => {\n    const len = as.length\n    for (let i = 0; i < len; i++) {\n      if (predicate(as[i])) {\n        return some(as[i])\n      }\n    }\n    return none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 690,
        "to": 700
      }
    }
  },
  {
    "name": "findFirstMap",
    "text": "\n\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport function findFirstMap<A, B>(f: (a: A) => Option<B>): (as: ReadonlyArray<A>) => Option<B> {\n  return (as) => {\n    const len = as.length\n    for (let i = 0; i < len; i++) {\n      const v = f(as[i])\n      if (isSome(v)) {\n        return v\n      }\n    }\n    return none\n  }\n}",
    "docs": "/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 721,
        "to": 732
      }
    }
  },
  {
    "name": "findLast",
    "text": "\n\n/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findLast((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @since 2.5.0\n */\nexport function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>",
    "docs": "/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findLast((x: { a: number, b: number }) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 745,
        "to": 745
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 746,
        "to": 746
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A> {\n  return (as) => {\n    const len = as.length\n    for (let i = len - 1; i >= 0; i--) {\n      if (predicate(as[i])) {\n        return some(as[i])\n      }\n    }\n    return none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 747,
        "to": 757
      }
    }
  },
  {
    "name": "findLastMap",
    "text": "\n\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport function findLastMap<A, B>(f: (a: A) => Option<B>): (as: ReadonlyArray<A>) => Option<B> {\n  return (as) => {\n    const len = as.length\n    for (let i = len - 1; i >= 0; i--) {\n      const v = f(as[i])\n      if (isSome(v)) {\n        return v\n      }\n    }\n    return none\n  }\n}",
    "docs": "/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 778,
        "to": 789
      }
    }
  },
  {
    "name": "findLastIndex",
    "text": "\n\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface X {\n *   a: number\n *   b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport function findLastIndex<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<number> {\n  return (as) => {\n    const len = as.length\n    for (let i = len - 1; i >= 0; i--) {\n      if (predicate(as[i])) {\n        return some(i)\n      }\n    }\n    return none\n  }\n}",
    "docs": "/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface X {\n *   a: number\n *   b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 809,
        "to": 819
      }
    }
  },
  {
    "name": "unsafeInsertAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function unsafeInsertAt<A>(i: number, a: A, as: ReadonlyArray<A>): ReadonlyArray<A> {\n  // tslint:disable-next-line: readonly-array\n  const xs = as.slice()\n  xs.splice(i, 0, a)\n  return xs\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 824,
        "to": 829
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\n\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport function insertAt<A>(i: number, a: A): (as: ReadonlyArray<A>) => Option<ReadonlyArray<A>> {\n  return (as) => (i < 0 || i > as.length ? none : some(unsafeInsertAt(i, a, as)))\n}",
    "docs": "/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 842,
        "to": 844
      }
    }
  },
  {
    "name": "unsafeUpdateAt",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function unsafeUpdateAt<A>(i: number, a: A, as: ReadonlyArray<A>): ReadonlyArray<A> {\n  if (as[i] === a) {\n    return as\n  } else {\n    // tslint:disable-next-line: readonly-array\n    const xs = as.slice()\n    xs[i] = a\n    return xs\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 850,
        "to": 859
      }
    }
  },
  {
    "name": "updateAt",
    "text": "\n\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport function updateAt<A>(i: number, a: A): (as: ReadonlyArray<A>) => Option<ReadonlyArray<A>> {\n  return (as) => (isOutOfBound(i, as) ? none : some(unsafeUpdateAt(i, a, as)))\n}",
    "docs": "/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 873,
        "to": 875
      }
    }
  },
  {
    "name": "unsafeDeleteAt",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function unsafeDeleteAt<A>(i: number, as: ReadonlyArray<A>): ReadonlyArray<A> {\n  // tslint:disable-next-line: readonly-array\n  const xs = as.slice()\n  xs.splice(i, 1)\n  return xs\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 881,
        "to": 886
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport function deleteAt(i: number): <A>(as: ReadonlyArray<A>) => Option<ReadonlyArray<A>> {\n  return (as) => (isOutOfBound(i, as) ? none : some(unsafeDeleteAt(i, as)))\n}",
    "docs": "/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 900,
        "to": 902
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "\n\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport function modifyAt<A>(i: number, f: (a: A) => A): (as: ReadonlyArray<A>) => Option<ReadonlyArray<A>> {\n  return (as) => (isOutOfBound(i, as) ? none : some(unsafeUpdateAt(i, f(as[i]), as)))\n}",
    "docs": "/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/lib/ReadonlyArray'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 918,
        "to": 920
      }
    }
  },
  {
    "name": "reverse",
    "text": "\n\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function reverse<A>(as: ReadonlyArray<A>): ReadonlyArray<A> {\n  return as.slice().reverse()\n}",
    "docs": "/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 933,
        "to": 935
      }
    }
  },
  {
    "name": "rights",
    "text": "\n\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/lib/ReadonlyArray'\n * import { right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function rights<E, A>(as: ReadonlyArray<Either<E, A>>): ReadonlyArray<A> {\n  // tslint:disable-next-line: readonly-array\n  const r: Array<A> = []\n  const len = as.length\n  for (let i = 0; i < len; i++) {\n    const a = as[i]\n    if (a._tag === 'Right') {\n      r.push(a.right)\n    }\n  }\n  return r\n}",
    "docs": "/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/lib/ReadonlyArray'\n * import { right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 949,
        "to": 960
      }
    }
  },
  {
    "name": "lefts",
    "text": "\n\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/lib/ReadonlyArray'\n * import { left, right } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport function lefts<E, A>(as: ReadonlyArray<Either<E, A>>): ReadonlyArray<E> {\n  // tslint:disable-next-line: readonly-array\n  const r: Array<E> = []\n  const len = as.length\n  for (let i = 0; i < len; i++) {\n    const a = as[i]\n    if (a._tag === 'Left') {\n      r.push(a.left)\n    }\n  }\n  return r\n}",
    "docs": "/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/lib/ReadonlyArray'\n * import { left, right } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly E[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 973,
        "to": 984
      }
    }
  },
  {
    "name": "sort",
    "text": "\n\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/lib/ReadonlyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(sort(ordNumber)([3, 2, 1]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function sort<A>(O: Ord<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => as.slice().sort(O.compare)\n}",
    "docs": "/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/lib/ReadonlyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(sort(ordNumber)([3, 2, 1]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 998,
        "to": 1000
      }
    }
  },
  {
    "name": "zipWith",
    "text": "\n\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function zipWith<A, B, C>(fa: ReadonlyArray<A>, fb: ReadonlyArray<B>, f: (a: A, b: B) => C): ReadonlyArray<C> {\n  // tslint:disable-next-line: readonly-array\n  const fc: Array<C> = []\n  const len = Math.min(fa.length, fb.length)\n  for (let i = 0; i < len; i++) {\n    fc[i] = f(fa[i], fb[i])\n  }\n  return fc\n}",
    "docs": "/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly C[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1014,
        "to": 1022
      }
    }
  },
  {
    "name": "zip",
    "text": "\n\n/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(zip([1, 2, 3], ['a', 'b', 'c', 'd']), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function zip<A, B>(fa: ReadonlyArray<A>, fb: ReadonlyArray<B>): ReadonlyArray<readonly [A, B]> {\n  return zipWith(fa, fb, (a, b) => [a, b])\n}",
    "docs": "/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(zip([1, 2, 3], ['a', 'b', 'c', 'd']), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly (readonly [A, B])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1036,
        "to": 1038
      }
    }
  },
  {
    "name": "unzip",
    "text": "\n\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport function unzip<A, B>(as: ReadonlyArray<readonly [A, B]>): readonly [ReadonlyArray<A>, ReadonlyArray<B>] {\n  // tslint:disable-next-line: readonly-array\n  const fa: Array<A> = []\n  // tslint:disable-next-line: readonly-array\n  const fb: Array<B> = []\n\n  for (let i = 0; i < as.length; i++) {\n    fa[i] = as[i][0]\n    fb[i] = as[i][1]\n  }\n\n  return [fa, fb]\n}",
    "docs": "/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly (readonly [A, B])[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [readonly A[], readonly B[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1050,
        "to": 1062
      }
    }
  },
  {
    "name": "rotate",
    "text": "\n\n/**\n * Rotate an array to the right by `n` steps\n *\n * @example\n * import { rotate } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function rotate(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => {\n    const len = as.length\n    if (n === 0 || len <= 1 || len === Math.abs(n)) {\n      return as\n    } else if (n < 0) {\n      return rotate(len + n)(as)\n    } else {\n      return as.slice(-n).concat(as.slice(0, len - n))\n    }\n  }\n}",
    "docs": "/**\n * Rotate an array to the right by `n` steps\n *\n * @example\n * import { rotate } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1075,
        "to": 1086
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * Test if a value is a member of an array. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an array of type `ReadonlyArray<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, [1, 2, 3]), true)\n * assert.strictEqual(elem(eqNumber)(4, [1, 2, 3]), false)\n *\n * @since 2.5.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, as: ReadonlyArray<A>) => boolean {\n  return (a, as) => {\n    const predicate = (element: A) => E.equals(element, a)\n    let i = 0\n    const len = as.length\n    for (; i < len; i++) {\n      if (predicate(as[i])) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "/**\n * Test if a value is a member of an array. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an array of type `ReadonlyArray<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, [1, 2, 3]), true)\n * assert.strictEqual(elem(eqNumber)(4, [1, 2, 3]), false)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, as: readonly A[]) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1102,
        "to": 1114
      }
    }
  },
  {
    "name": "uniq",
    "text": "\n\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(uniq(eqNumber)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function uniq<A>(E: Eq<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  const elemS = elem(E)\n  return (as) => {\n    // tslint:disable-next-line: readonly-array\n    const r: Array<A> = []\n    const len = as.length\n    let i = 0\n    for (; i < len; i++) {\n      const a = as[i]\n      if (!elemS(a, r)) {\n        r.push(a)\n      }\n    }\n    return len === r.length ? as : r\n  }\n}",
    "docs": "/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(uniq(eqNumber)([1, 2, 1]), [1, 2])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1128,
        "to": 1143
      }
    }
  },
  {
    "name": "sortBy",
    "text": "\n\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/lib/ReadonlyArray'\n * import { ord, ordString, ordNumber } from 'fp-ts/lib/Ord'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n * const byName = ord.contramap(ordString, (p: Person) => p.name)\n * const byAge = ord.contramap(ordNumber, (p: Person) => p.age)\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function sortBy<A>(ords: ReadonlyArray<Ord<A>>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  const M = getOrdMonoid<A>()\n  return sort(ords.reduce(M.concat, M.empty))\n}",
    "docs": "/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/lib/ReadonlyArray'\n * import { ord, ordString, ordNumber } from 'fp-ts/lib/Ord'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n * const byName = ord.contramap(ordString, (p: Person) => p.name)\n * const byAge = ord.contramap(ordNumber, (p: Person) => p.age)\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1173,
        "to": 1176
      }
    }
  },
  {
    "name": "chop",
    "text": "\n\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq, eqNumber } from 'fp-ts/lib/Eq'\n * import { chop, spanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return chop(as => {\n *     const { init, rest } = spanLeft((a: A) => S.equals(a, as[0]))(as)\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(eqNumber)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function chop<A, B>(\n  f: (as: ReadonlyNonEmptyArray<A>) => readonly [B, ReadonlyArray<A>]\n): (as: ReadonlyArray<A>) => ReadonlyArray<B> {\n  return (as) => {\n    // tslint:disable-next-line: readonly-array\n    const result: Array<B> = []\n    let cs: ReadonlyArray<A> = as\n    while (isNonEmpty(cs)) {\n      const [b, c] = f(cs)\n      result.push(b)\n      cs = c\n    }\n    return result\n  }\n}",
    "docs": "/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq, eqNumber } from 'fp-ts/lib/Eq'\n * import { chop, spanLeft } from 'fp-ts/lib/ReadonlyArray'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return chop(as => {\n *     const { init, rest } = spanLeft((a: A) => S.equals(a, as[0]))(as)\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(eqNumber)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1198,
        "to": 1212
      }
    }
  },
  {
    "name": "splitAt",
    "text": "\n\n/**\n * Splits an array into two pieces, the first piece has `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport function splitAt(n: number): <A>(as: ReadonlyArray<A>) => readonly [ReadonlyArray<A>, ReadonlyArray<A>] {\n  return (as) => [as.slice(0, n), as.slice(n)]\n}",
    "docs": "/**\n * Splits an array into two pieces, the first piece has `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly [readonly A[], readonly A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1224,
        "to": 1226
      }
    }
  },
  {
    "name": "chunksOf",
    "text": "\n\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n *\n * @since 2.5.0\n */\nexport function chunksOf(n: number): <A>(as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>> {\n  const f = chop(splitAt(n))\n  return (as) => (as.length === 0 ? empty : isOutOfBound(n - 1, as) ? [as] : f(as))\n}",
    "docs": "/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/lib/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly (readonly A[])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1247,
        "to": 1250
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\n\n/**\n * Array comprehension\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/lib/ReadonlyArray'\n * import { tuple } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @since 2.5.0\n */\nexport function comprehension<A, B, C, D, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>, ReadonlyArray<D>],\n  f: (a: A, b: B, c: C, d: D) => R,\n  g?: (a: A, b: B, c: C, d: D) => boolean\n): ReadonlyArray<R>",
    "docs": "/**\n * Array comprehension\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/lib/ReadonlyArray'\n * import { tuple } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[], readonly C[], readonly D[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1272,
        "to": 1276
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, C, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>],\n  f: (a: A, b: B, c: C) => R,\n  g?: (a: A, b: B, c: C) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[], readonly C[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1277,
        "to": 1281
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(\n  input: readonly [ReadonlyArray<A>],\n  f: (a: A) => R,\n  g?: (a: A) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1282,
        "to": 1286
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>],\n  f: (a: A, b: B) => R,\n  g?: (a: A, b: B) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1287,
        "to": 1291
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(\n  input: readonly [ReadonlyArray<A>],\n  f: (a: A) => boolean,\n  g?: (a: A) => R\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1292,
        "to": 1296
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<R>(\n  input: ReadonlyArray<ReadonlyArray<any>>,\n  f: (...xs: ReadonlyArray<any>) => R,\n  g: (...xs: ReadonlyArray<any>) => boolean = () => true\n): ReadonlyArray<R> {\n  const go = (scope: ReadonlyArray<any>, input: ReadonlyArray<ReadonlyArray<any>>): ReadonlyArray<R> => {\n    if (input.length === 0) {\n      return g(...scope) ? [f(...scope)] : empty\n    } else {\n      return chain_(input[0], (x) => go(snoc(scope, x), input.slice(1)))\n    }\n  }\n  return go(empty, input)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly (readonly any[])[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...xs: readonly any[]) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(...xs: readonly any[]) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1297,
        "to": 1310
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(union(eqNumber)([1, 2], [2, 3]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function union<A>(E: Eq<A>): (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>) => ReadonlyArray<A> {\n  const elemE = elem(E)\n  return (xs, ys) =>\n    concat(\n      xs,\n      ys.filter((a) => !elemE(a, xs))\n    )\n}",
    "docs": "/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(union(eqNumber)([1, 2], [2, 3]), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1324,
        "to": 1331
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(intersection(eqNumber)([1, 2], [2, 3]), [2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function intersection<A>(E: Eq<A>): (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>) => ReadonlyArray<A> {\n  const elemE = elem(E)\n  return (xs, ys) => xs.filter((a) => elemE(a, ys))\n}",
    "docs": "/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(intersection(eqNumber)([1, 2], [2, 3]), [2])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1346,
        "to": 1349
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(difference(eqNumber)([1, 2], [2, 3]), [1])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function difference<A>(E: Eq<A>): (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>) => ReadonlyArray<A> {\n  const elemE = elem(E)\n  return (xs, ys) => xs.filter((a) => !elemE(a, ys))\n}",
    "docs": "/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/lib/ReadonlyArray'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(difference(eqNumber)([1, 2], [2, 3]), [1])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1364,
        "to": 1367
      }
    }
  },
  {
    "name": "of",
    "text": "const of = <A>(a: A): ReadonlyArray<A> => [a]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1372,
        "to": 1372
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => ReadonlyArray<A>) => (fa: ReadonlyArray<A>) => ReadonlyArray<A> = (that) => (fa) =>\n  alt_(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1567,
        "to": 1568
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: ReadonlyArray<A>) => <B>(fab: ReadonlyArray<(a: A) => B>) => ReadonlyArray<B> = (fa) => (\n  fab\n) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: readonly ((a: A) => B)[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1576,
        "to": 1578
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: ReadonlyArray<B>) => <A>(fa: ReadonlyArray<A>) => ReadonlyArray<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1586,
        "to": 1590
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: ReadonlyArray<B>) => <A>(fa: ReadonlyArray<A>): ReadonlyArray<B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1598,
        "to": 1602
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => ReadonlyArray<B>) => (ma: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (ma) =>\n  chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1610,
        "to": 1611
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => ReadonlyArray<B>) => (ma: ReadonlyArray<A>) => ReadonlyArray<A> = (f) => (\n  ma\n) => chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1620,
        "to": 1622
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <A>(wa: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>> = (wa) => extend_(wa, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly (readonly A[])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1628,
        "to": 1628
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1637,
        "to": 1637
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (\n  fa\n) => mapWithIndex_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1643,
        "to": 1645
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact: <A>(fa: ReadonlyArray<Option<A>>) => ReadonlyArray<A> = (as) => filterMap_(as, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1651,
        "to": 1651
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <A, B>(fa: ReadonlyArray<Either<A, B>>): Separated<ReadonlyArray<A>, ReadonlyArray<B>> => {\n  // tslint:disable-next-line: readonly-array\n  const left: Array<A> = []\n  // tslint:disable-next-line: readonly-array\n  const right: Array<B> = []\n  for (const e of fa) {\n    if (e._tag === 'Left') {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return {\n    left,\n    right\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly A[], readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1657,
        "to": 1673
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: ReadonlyArray<A>) => ReadonlyArray<B>\n  <A>(predicate: Predicate<A>): (fa: ReadonlyArray<A>) => ReadonlyArray<A>\n} = <A>(predicate: Predicate<A>) => (fa: ReadonlyArray<A>) => filter_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1679,
        "to": 1682
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (fa) =>\n  filterMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1688,
        "to": 1689
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>\n  <A>(predicate: Predicate<A>): (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>\n} = <A>(predicate: Predicate<A>) => (fa: ReadonlyArray<A>) => partition_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly A[], readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1695,
        "to": 1700
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "const partitionWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (fa: ReadonlyArray<A>) =>\n  partitionWithIndex_(fa, predicateWithIndex)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly A[], readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1706,
        "to": 1714
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<B>, ReadonlyArray<C>> = (f) => (fa) => partitionMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly B[], readonly C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1720,
        "to": 1722
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "const partitionMapWithIndex: <A, B, C>(\n  f: (i: number, a: A) => Either<B, C>\n) => (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<B>, ReadonlyArray<C>> = (f) => (fa) =>\n  partitionMapWithIndex_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly B[], readonly C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1728,
        "to": 1731
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "const filterMapWithIndex: <A, B>(\n  f: (i: number, a: A) => Option<B>\n) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (fa) => filterMapWithIndex_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1737,
        "to": 1739
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (fa: ReadonlyArray<A>) => ReadonlyArray<B>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: ReadonlyArray<A>) => ReadonlyArray<A>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (fa: ReadonlyArray<A>): ReadonlyArray<A> =>\n  filterWithIndex_(fa, predicateWithIndex)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1745,
        "to": 1749
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (fa: ReadonlyArray<A>) => B) => (wa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (\n  ma\n) => extend_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(fa: readonly A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1755,
        "to": 1757
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: ReadonlyArray<A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: readonly A[]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1763,
        "to": 1766
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "const foldMapWithIndex: <M>(M: Monoid<M>) => <A>(f: (i: number, a: A) => M) => (fa: ReadonlyArray<A>) => M = (\n  M\n) => {\n  const foldMapWithIndexM = foldMapWithIndex_(M)\n  return (f) => (fa) => foldMapWithIndexM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (i: number, a: A) => M) => (fa: readonly A[]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1772,
        "to": 1777
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B = (b, f) => (fa) =>\n  reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1783,
        "to": 1784
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "const reduceWithIndex: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B = (b, f) => (\n  fa\n) => reduceWithIndex_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1790,
        "to": 1792
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1798,
        "to": 1799
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "const reduceRightWithIndex: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B = (\n  b,\n  f\n) => (fa) => reduceRightWithIndex_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1805,
        "to": 1808
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (ta) => traverseF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1835,
        "to": 1840
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: Applicative<F>) => <A>(\n  ta: ReadonlyArray<HKT<F, A>>\n): HKT<F, ReadonlyArray<A>> => {\n  return reduce_(ta, F.of(zero_()), (fas, fa) =>\n    F.ap(\n      F.map(fas, (as) => (a: A) => snoc(as, a)),\n      fa\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1845,
        "to": 1854
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "const traverseWithIndex: PipeableTraverseWithIndex1<URI, number> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (i: number, a: A) => HKT<F, B>) => (ta: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) => {\n  const traverseWithIndexF = traverseWithIndex_(F)\n  return (f) => (ta) => traverseWithIndexF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1859,
        "to": 1864
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (ta: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) => {\n  const witherF = wither_(F)\n  return (f) => (ta) => witherF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ta: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1870,
        "to": 1875
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B, C>(\n  f: (a: A) => HKT<F, Either<B, C>>\n) => (wa: ReadonlyArray<A>) => HKT<F, Separated<ReadonlyArray<B>, ReadonlyArray<C>>>) => {\n  const wiltF = wilt_(F)\n  return (f) => (ta) => wiltF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (wa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<readonly B[], readonly C[]>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1881,
        "to": 1888
      }
    }
  },
  {
    "name": "fromMap",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function fromMap<K, A>(m: Map<K, A>): ReadonlyMap<K, A> {\n  return new Map(m)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "m",
          "type": {
            "__tag": "Other",
            "values": "Map<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 33,
        "to": 35
      }
    }
  },
  {
    "name": "toMap",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toMap<K, A>(m: ReadonlyMap<K, A>): Map<K, A> {\n  return new Map(m)\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "m",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 41,
        "to": 43
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<K, A>(SK: Show<K>, SA: Show<A>): Show<ReadonlyMap<K, A>> {\n  return {\n    show: (m) => {\n      let elements = ''\n      m.forEach((a, k) => {\n        elements += `[${SK.show(k)}, ${SA.show(a)}], `\n      })\n      if (elements !== '') {\n        elements = elements.substring(0, elements.length - 2)\n      }\n      return `new Map([${elements}])`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 49,
        "to": 62
      }
    }
  },
  {
    "name": "size",
    "text": "\n\n/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.5.0\n */\nexport function size<K, A>(d: ReadonlyMap<K, A>): number {\n  return d.size\n}",
    "docs": "/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "d",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 69,
        "to": 71
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "\n\n/**\n * Test whether or not a map is empty\n *\n * @since 2.5.0\n */\nexport function isEmpty<K, A>(d: ReadonlyMap<K, A>): boolean {\n  return d.size === 0\n}",
    "docs": "/**\n * Test whether or not a map is empty\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "d",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 78,
        "to": 80
      }
    }
  },
  {
    "name": "member",
    "text": "\n\n/**\n * Test whether or not a key exists in a map\n *\n * @since 2.5.0\n */\nexport function member<K>(E: Eq<K>): <A>(k: K, m: ReadonlyMap<K, A>) => boolean {\n  const lookupE = lookup(E)\n  return (k, m) => O.isSome(lookupE(k, m))\n}",
    "docs": "/**\n * Test whether or not a key exists in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m: ReadonlyMap<K, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 87,
        "to": 90
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * Test whether or not a value is a member of a map\n *\n * @since 2.5.0\n */\nexport function elem<A>(E: Eq<A>): <K>(a: A, m: ReadonlyMap<K, A>) => boolean {\n  return (a, m) => {\n    const values = m.values()\n    let e: Next<A>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const v = e.value\n      if (E.equals(a, v)) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "/**\n * Test whether or not a value is a member of a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(a: A, m: ReadonlyMap<K, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 102,
        "to": 115
      }
    }
  },
  {
    "name": "keys",
    "text": "\n\n/**\n * Get a sorted array of the keys contained in a map\n *\n * @since 2.5.0\n */\nexport function keys<K>(O: Ord<K>): <A>(m: ReadonlyMap<K, A>) => ReadonlyArray<K> {\n  return (m) => Array.from(m.keys()).sort(O.compare)\n}",
    "docs": "/**\n * Get a sorted array of the keys contained in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: ReadonlyMap<K, A>) => readonly K[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "values",
    "text": "\n\n/**\n * Get a sorted array of the values contained in a map\n *\n * @since 2.5.0\n */\nexport function values<A>(O: Ord<A>): <K>(m: ReadonlyMap<K, A>) => ReadonlyArray<A> {\n  return (m) => Array.from(m.values()).sort(O.compare)\n}",
    "docs": "/**\n * Get a sorted array of the values contained in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(m: ReadonlyMap<K, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 131,
        "to": 133
      }
    }
  },
  {
    "name": "collect",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => ReadonlyArray<B> {\n  const keysO = keys(O)\n  return <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>): ReadonlyArray<B> => {\n    // tslint:disable-next-line: readonly-array\n    const out: Array<B> = []\n    const ks = keysO(m)\n    for (const key of ks) {\n      out.push(f(key, m.get(key)!))\n    }\n    return out\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 138,
        "to": 149
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\n\n/**\n * Get a sorted of the key/value pairs contained in a map\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function toReadonlyArray<K>(O: Ord<K>): <A>(m: ReadonlyMap<K, A>) => ReadonlyArray<readonly [K, A]> {\n  return collect(O)((k, a) => [k, a] as const)\n}",
    "docs": "/**\n * Get a sorted of the key/value pairs contained in a map\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: ReadonlyMap<K, A>) => readonly (readonly [K, A])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a map into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function toUnfoldable<K, F extends URIS>(\n  ord: Ord<K>,\n  U: Unfoldable1<F>\n): <A>(d: ReadonlyMap<K, A>) => Kind<F, readonly [K, A]>",
    "docs": "/**\n * Unfolds a map into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 167,
        "to": 170
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(ord: Ord<K>, U: Unfoldable<F>): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 171,
        "to": 171
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(\n  ord: Ord<K>,\n  U: Unfoldable<F>\n): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]> {\n  const toArrayO = toReadonlyArray(ord)\n  return (d) => {\n    const arr = toArrayO(d)\n    const len = arr.length\n    return U.unfold(0, (b) => (b < len ? O.some([arr[b], b + 1]) : O.none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 172,
        "to": 182
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\n\n/**\n * Insert or replace a key/value pair in a map\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function insertAt<K>(E: Eq<K>): <A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A> {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, a) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isNone(found)) {\n      const r = new Map(m)\n      r.set(k, a)\n      return r\n    } else if (found.value[1] !== a) {\n      const r = new Map(m)\n      r.set(found.value[0], a)\n      return r\n    }\n    return m\n  }\n}",
    "docs": "/**\n * Insert or replace a key/value pair in a map\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 190,
        "to": 205
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete a key and value from a map\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function deleteAt<K>(E: Eq<K>): (k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A> {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isSome(found)) {\n      const r = new Map(m)\n      r.delete(found.value[0])\n      return r\n    }\n    return m\n  }\n}",
    "docs": "/**\n * Delete a key and value from a map\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 213,
        "to": 224
      }
    }
  },
  {
    "name": "updateAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function updateAt<K>(E: Eq<K>): <A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => Option<ReadonlyMap<K, A>> {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, a) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isNone(found)) {\n      return O.none\n    }\n    const r = new Map(m)\n    r.set(found.value[0], a)\n    return O.some(r)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 229,
        "to": 240
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function modifyAt<K>(\n  E: Eq<K>\n): <A>(k: K, f: (a: A) => A) => (m: ReadonlyMap<K, A>) => Option<ReadonlyMap<K, A>> {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, f) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isNone(found)) {\n      return O.none\n    }\n    const r = new Map(m)\n    r.set(found.value[0], f(found.value[1]))\n    return O.some(r)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, f: (a: A) => A) => (m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 245,
        "to": 258
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */\nexport function pop<K>(E: Eq<K>): (k: K) => <A>(m: ReadonlyMap<K, A>) => Option<readonly [A, ReadonlyMap<K, A>]> {\n  const lookupE = lookup(E)\n  const deleteAtE = deleteAt(E)\n  return (k) => {\n    const deleteAtEk = deleteAtE(k)\n    return (m) =>\n      pipe(\n        lookupE(k, m),\n        O.map((a) => [a, deleteAtEk(m)])\n      )\n  }\n}",
    "docs": "/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, ReadonlyMap<K, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 265,
        "to": 276
      }
    }
  },
  {
    "name": "lookupWithKey",
    "text": "\n\n/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.5.0\n */\nexport function lookupWithKey<K>(E: Eq<K>): <A>(k: K, m: ReadonlyMap<K, A>) => Option<readonly [K, A]> {\n  return <A>(k: K, m: ReadonlyMap<K, A>) => {\n    const entries = m.entries()\n    let e: Next<readonly [K, A]>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = entries.next()).done) {\n      const [ka, a] = e.value\n      if (E.equals(ka, k)) {\n        return O.some([ka, a])\n      }\n    }\n    return O.none\n  }\n}",
    "docs": "/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 284,
        "to": 297
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n/**\n * Lookup the value for a key in a `Map`.\n *\n * @since 2.5.0\n */\nexport function lookup<K>(E: Eq<K>): <A>(k: K, m: ReadonlyMap<K, A>) => Option<A> {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, m) =>\n    pipe(\n      lookupWithKeyE(k, m),\n      O.map(([_, a]) => a)\n    )\n}",
    "docs": "/**\n * Lookup the value for a key in a `Map`.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 304,
        "to": 311
      }
    }
  },
  {
    "name": "isSubmap",
    "text": "\n\n/**\n * Test whether or not one Map contains all of the keys and values contained in another Map\n *\n * @since 2.5.0\n */\nexport function isSubmap<K, A>(SK: Eq<K>, SA: Eq<A>): (d1: ReadonlyMap<K, A>, d2: ReadonlyMap<K, A>) => boolean {\n  const lookupWithKeyS = lookupWithKey(SK)\n  return (d1: ReadonlyMap<K, A>, d2: ReadonlyMap<K, A>): boolean => {\n    const entries = d1.entries()\n    let e: Next<readonly [K, A]>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = entries.next()).done) {\n      const [k, a] = e.value\n      const d2OptA = lookupWithKeyS(k, d2)\n      if (O.isNone(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "/**\n * Test whether or not one Map contains all of the keys and values contained in another Map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(d1: ReadonlyMap<K, A>, d2: ReadonlyMap<K, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 318,
        "to": 333
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<K, A>(SK: Eq<K>, SA: Eq<A>): Eq<ReadonlyMap<K, A>> {\n  const isSubmap_ = isSubmap(SK, SA)\n  return fromEquals((x, y) => isSubmap_(x, y) && isSubmap_(y, x))\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 344,
        "to": 347
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<ReadonlyMap<K, A>> {\n  const lookupWithKeyS = lookupWithKey(SK)\n  return {\n    concat: (mx, my) => {\n      if (mx === empty) {\n        return my\n      }\n      if (my === empty) {\n        return mx\n      }\n      const r = new Map(mx)\n      const entries = my.entries()\n      let e: Next<readonly [K, A]>\n      // tslint:disable-next-line: strict-boolean-expressions\n      while (!(e = entries.next()).done) {\n        const [k, a] = e.value\n        const mxOptA = lookupWithKeyS(k, mx)\n        if (O.isSome(mxOptA)) {\n          r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a))\n        } else {\n          r.set(k, a)\n        }\n      }\n      return r\n    },\n    empty\n  }\n}",
    "docs": "/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 355,
        "to": 382
      }
    }
  },
  {
    "name": "singleton",
    "text": "\n\n/**\n * Create a map with one key/value pair\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function singleton<K, A>(k: K, a: A): ReadonlyMap<K, A> {\n  return new Map([[k, a]])\n}",
    "docs": "/**\n * Create a map with one key/value pair\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 390,
        "to": 392
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 401,
        "to": 405
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 406,
        "to": 410
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 411,
        "to": 415
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 416,
        "to": 420
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A> {\n  return (fka: HKT<F, readonly [K, A]>) => {\n    const lookupWithKeyE = lookupWithKey(E)\n    return F.reduce<readonly [K, A], Map<K, A>>(fka, new Map<K, A>(), (b, [k, a]) => {\n      const bOpt = lookupWithKeyE(k, b)\n      if (O.isSome(bOpt)) {\n        b.set(bOpt.value[0], M.concat(bOpt.value[1], a))\n      } else {\n        b.set(k, a)\n      }\n      return b\n    })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 421,
        "to": 438
      }
    }
  },
  {
    "name": "getFilterableWithIndex",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getFilterableWithIndex<K = never>(): FilterableWithIndex2C<URI, K, K> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    mapWithIndex: mapWithIndex_,\n    compact,\n    separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    partitionMapWithIndex: partitionMapWithIndex_,\n    partitionWithIndex: partitionWithIndex_,\n    filterMapWithIndex: filterMapWithIndex_,\n    filterWithIndex: filterWithIndex_\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 666,
        "to": 683
      }
    }
  },
  {
    "name": "getWitherable",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getWitherable<K>(O: Ord<K>): Witherable2C<URI, K> & TraversableWithIndex2C<URI, K, K> {\n  const keysO = keys(O)\n\n  const reduceWithIndex = <A, B>(fa: ReadonlyMap<K, A>, b: B, f: (k: K, b: B, a: A) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = f(k, out, fa.get(k)!)\n    }\n    return out\n  }\n\n  const foldMapWithIndex = <M>(M: Monoid<M>) => <A>(fa: ReadonlyMap<K, A>, f: (k: K, a: A) => M): M => {\n    let out: M = M.empty\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = M.concat(out, f(k, fa.get(k)!))\n    }\n    return out\n  }\n\n  const reduceRightWithIndex = <A, B>(fa: ReadonlyMap<K, A>, b: B, f: (k: K, a: A, b: B) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = len - 1; i >= 0; i--) {\n      const k = ks[i]\n      out = f(k, fa.get(k)!, out)\n    }\n    return out\n  }\n\n  const traverseWithIndex = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ta: ReadonlyMap<K, A>, f: (k: K, a: A) => HKT<F, B>) => HKT<F, ReadonlyMap<K, B>>) => {\n    return <A, B>(ta: ReadonlyMap<K, A>, f: (k: K, a: A) => HKT<F, B>) => {\n      let fm: HKT<F, ReadonlyMap<K, B>> = F.of(empty)\n      const ks = keysO(ta)\n      const len = ks.length\n      for (let i = 0; i < len; i++) {\n        const key = ks[i]\n        const a = ta.get(key)!\n        fm = F.ap(\n          F.map(fm, (m) => (b: B) => new Map(m).set(key, b)),\n          f(key, a)\n        )\n      }\n      return fm\n    }\n  }\n\n  const traverse = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ta: ReadonlyMap<K, A>, f: (a: A) => HKT<F, B>) => HKT<F, ReadonlyMap<K, B>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta, f) => traverseWithIndexF(ta, (_, a) => f(a))\n  }\n\n  const sequence = <F>(F: Applicative<F>): (<A>(ta: ReadonlyMap<K, HKT<F, A>>) => HKT<F, ReadonlyMap<K, A>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta) => traverseWithIndexF(ta, (_, a) => a)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    compact,\n    separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    reduce: (fa, b, f) => reduceWithIndex(fa, b, (_, b, a) => f(b, a)),\n    foldMap: (M) => {\n      const foldMapWithIndexM = foldMapWithIndex(M)\n      return (fa, f) => foldMapWithIndexM(fa, (_, a) => f(a))\n    },\n    reduceRight: (fa, b, f) => reduceRightWithIndex(fa, b, (_, a, b) => f(a, b)),\n    traverse,\n    sequence,\n    mapWithIndex: mapWithIndex_,\n    reduceWithIndex,\n    foldMapWithIndex,\n    reduceRightWithIndex,\n    traverseWithIndex,\n    wilt: <F>(\n      F: Applicative<F>\n    ): (<A, B, C>(\n      wa: ReadonlyMap<K, A>,\n      f: (a: A) => HKT<F, Either<B, C>>\n    ) => HKT<F, Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>>) => {\n      const traverseF = traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), separate)\n    },\n    wither: <F>(\n      F: Applicative<F>\n    ): (<A, B>(wa: ReadonlyMap<K, A>, f: (a: A) => HKT<F, Option<B>>) => HKT<F, ReadonlyMap<K, B>>) => {\n      const traverseF = traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), compact)\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Witherable\").Witherable2C<\"ReadonlyMap\", K> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TraversableWithIndex\").TraversableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 689,
        "to": 795
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <K, A>(fa: ReadonlyMap<K, Option<A>>): ReadonlyMap<K, A> => {\n  const m = new Map<K, A>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, Option<A>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, oa] = e.value\n    if (O.isSome(oa)) {\n      m.set(k, oa.value)\n    }\n  }\n  return m\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 555,
        "to": 567
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>\n  <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, A>\n} = <A>(predicate: Predicate<A>) => <K>(fa: ReadonlyMap<K, A>) => filter_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 573,
        "to": 576
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B> = (f) => (\n  fa\n) => filterMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 582,
        "to": 584
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 593,
        "to": 593
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(\n    fa: ReadonlyMap<K, A>\n  ) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>\n  <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>\n} = <A>(predicate: Predicate<A>) => <K>(fa: ReadonlyMap<K, A>) => partition_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 599,
        "to": 604
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>> = (f) => (fa) => partitionMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 610,
        "to": 612
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <K, A, B>(\n  fa: ReadonlyMap<K, Either<A, B>>\n): Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>> => {\n  const left = new Map<K, A>()\n  const right = new Map<K, B>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, Either<A, B>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, ei] = e.value\n    if (isLeft(ei)) {\n      left.set(k, ei.left)\n    } else {\n      right.set(k, ei.right)\n    }\n  }\n  return {\n    left,\n    right\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 618,
        "to": 638
      }
    }
  },
  {
    "name": "fromReadonlyArray",
    "text": "\n\n/**\n * Builds a `ReadonlyNonEmptyArray` from an array returning `none` if `as` is an empty array\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function fromReadonlyArray<A>(as: ReadonlyArray<A>): Option<ReadonlyNonEmptyArray<A>> {\n  return RA.isNonEmpty(as) ? some(as) : none\n}",
    "docs": "/**\n * Builds a `ReadonlyNonEmptyArray` from an array returning `none` if `as` is an empty array\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\n// tslint:disable-next-line: readonly-array\nexport function fromArray<A>(as: Array<A>): Option<ReadonlyNonEmptyArray<A>> {\n  return fromReadonlyArray(RA.fromArray(as))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 76,
        "to": 78
      }
    }
  },
  {
    "name": "head",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function head<A>(nea: ReadonlyNonEmptyArray<A>): A {\n  return nea[0]\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "tail",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function tail<A>(nea: ReadonlyNonEmptyArray<A>): ReadonlyArray<A> {\n  return nea.slice(1)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 96,
        "to": 98
      }
    }
  },
  {
    "name": "min",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function min<A>(ord: Ord<A>): (nea: ReadonlyNonEmptyArray<A>) => A {\n  const S = getMeetSemigroup(ord)\n  return (nea) => nea.reduce(S.concat)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 109,
        "to": 112
      }
    }
  },
  {
    "name": "max",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function max<A>(ord: Ord<A>): (nea: ReadonlyNonEmptyArray<A>) => A {\n  const S = getJoinSemigroup(ord)\n  return (nea) => nea.reduce(S.concat)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 117,
        "to": 120
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getSemigroup<A = never>(): Semigroup<ReadonlyNonEmptyArray<A>> {\n  return {\n    concat: concat\n  }\n}",
    "docs": "/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 128,
        "to": 132
      }
    }
  },
  {
    "name": "group",
    "text": "\n\n/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { cons, group } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(group(ordNumber)([1, 2, 1, 1]), [\n *   cons(1, []),\n *   cons(2, []),\n *   cons(1, [1])\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function group<A>(\n  E: Eq<A>\n): {\n  (as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n  (as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>\n}",
    "docs": "/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { cons, group } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(group(ordNumber)([1, 2, 1, 1]), [\n *   cons(1, []),\n *   cons(2, []),\n *   cons(1, [1])\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>; (as: readonly A[]): readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 164,
        "to": 169
      }
    }
  },
  {
    "name": "group",
    "text": "\nexport function group<A>(E: Eq<A>): (as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyNonEmptyArray<A>> {\n  return (as) => {\n    const len = as.length\n    if (len === 0) {\n      return RA.empty\n    }\n    // tslint:disable-next-line: readonly-array\n    const r: Array<ReadonlyNonEmptyArray<A>> = []\n    let head: A = as[0]\n    let nea: NonEmptyArray<A> = [head]\n    for (let i = 1; i < len; i++) {\n      const x = as[i]\n      if (E.equals(x, head)) {\n        nea.push(x)\n      } else {\n        r.push(nea)\n        head = x\n        nea = [head]\n      }\n    }\n    r.push(nea)\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 170,
        "to": 193
      }
    }
  },
  {
    "name": "groupSort",
    "text": "\n\n/**\n * Sort and then group the elements of an array into non empty arrays.\n *\n * @example\n * import { cons, groupSort } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(groupSort(ordNumber)([1, 2, 1, 1]), [cons(1, [1, 1]), cons(2, [])])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function groupSort<A>(O: Ord<A>): (as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyNonEmptyArray<A>> {\n  const sortO = RA.sort(O)\n  const groupO = group(O)\n  return (as) => groupO(sortO(as))\n}",
    "docs": "/**\n * Sort and then group the elements of an array into non empty arrays.\n *\n * @example\n * import { cons, groupSort } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(groupSort(ordNumber)([1, 2, 1, 1]), [cons(1, [1, 1]), cons(2, [])])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 207,
        "to": 211
      }
    }
  },
  {
    "name": "groupBy",
    "text": "\n\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { cons, groupBy } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['foo', 'bar', 'foobar']), {\n *   '3': cons('foo', ['bar']),\n *   '6': cons('foobar', [])\n * })\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function groupBy<A>(\n  f: (a: A) => string\n): (as: ReadonlyArray<A>) => ReadonlyRecord<string, ReadonlyNonEmptyArray<A>> {\n  return (as) => {\n    const r: Record<string, NonEmptyArray<A>> = {}\n    for (const a of as) {\n      const k = f(a)\n      if (r.hasOwnProperty(k)) {\n        r[k].push(a)\n      } else {\n        r[k] = [a]\n      }\n    }\n    return r\n  }\n}",
    "docs": "/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { cons, groupBy } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['foo', 'bar', 'foobar']), {\n *   '3': cons('foo', ['bar']),\n *   '6': cons('foobar', [])\n * })\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 228,
        "to": 243
      }
    }
  },
  {
    "name": "last",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function last<A>(nea: ReadonlyNonEmptyArray<A>): A {\n  return nea[nea.length - 1]\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 248,
        "to": 250
      }
    }
  },
  {
    "name": "init",
    "text": "\n\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport function init<A>(nea: ReadonlyNonEmptyArray<A>): ReadonlyArray<A> {\n  return nea.slice(0, -1)\n}",
    "docs": "/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/lib/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 263,
        "to": 265
      }
    }
  },
  {
    "name": "sort",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function sort<A>(O: Ord<A>): (nea: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A> {\n  return RA.sort(O) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 271,
        "to": 273
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function insertAt<A>(i: number, a: A): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  return RA.insertAt(i, a) as any\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 278,
        "to": 280
      }
    }
  },
  {
    "name": "updateAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function updateAt<A>(i: number, a: A): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  return RA.updateAt(i, a) as any\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 285,
        "to": 287
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function modifyAt<A>(\n  i: number,\n  f: (a: A) => A\n): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  return RA.modifyAt(i, f) as any\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 292,
        "to": 297
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function filter<A, B extends A>(\n  refinement: Refinement<A, B>\n): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 302,
        "to": 304
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 305,
        "to": 305
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(\n  predicate: Predicate<A>\n): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  return filterWithIndex((_, a) => predicate(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 306,
        "to": 310
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function filterWithIndex<A>(\n  predicate: (i: number, a: A) => boolean\n): (nea: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  return (nea) => fromReadonlyArray(nea.filter((a, i) => predicate(i, a)))\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(nea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 315,
        "to": 319
      }
    }
  },
  {
    "name": "concat",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function concat<A>(fx: ReadonlyArray<A>, fy: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A>",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 331,
        "to": 331
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(fx: ReadonlyNonEmptyArray<A>, fy: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 332,
        "to": 332
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(fx: ReadonlyArray<A>, fy: ReadonlyArray<A>): ReadonlyArray<A> {\n  return fx.concat(fy)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fx",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "fy",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 333,
        "to": 335
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function fold<A>(S: Semigroup<A>): (fa: ReadonlyNonEmptyArray<A>) => A {\n  return (fa) => fa.reduce(S.concat)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 340,
        "to": 342
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "const foldMapWithIndex = <S>(S: Semigroup<S>) => <A>(f: (i: number, a: A) => S) => (\n  fa: ReadonlyNonEmptyArray<A>\n) => fa.slice(1).reduce((s, a, i) => S.concat(s, f(i + 1, a)), f(0, fa[0]))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (i: number, a: A) => S) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 378,
        "to": 380
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap = <S>(S: Semigroup<S>) => <A>(f: (a: A) => S) => (fa: ReadonlyNonEmptyArray<A>) =>\n  fa.slice(1).reduce((s, a) => S.concat(s, f(a)), f(fa[0]))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => S) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 386,
        "to": 387
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function fromRecord<K extends string, A>(r: Record<K, A>): ReadonlyRecord<K, A> {\n  return Object.assign({}, r)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 33,
        "to": 35
      }
    }
  },
  {
    "name": "toRecord",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toRecord<K extends string, A>(r: ReadonlyRecord<K, A>): Record<K, A> {\n  return Object.assign({}, r)\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 41,
        "to": 43
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<A>(S: Show<A>): Show<ReadonlyRecord<string, A>> {\n  return {\n    show: (r) => {\n      const elements = collect((k, a: A) => `${JSON.stringify(k)}: ${S.show(a)}`)(r).join(', ')\n      return elements === '' ? '{}' : `{ ${elements} }`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 49,
        "to": 56
      }
    }
  },
  {
    "name": "size",
    "text": "\n\n/**\n * Calculate the number of key/value pairs in a record\n *\n * @since 2.5.0\n */\nexport function size(r: ReadonlyRecord<string, unknown>): number {\n  return Object.keys(r).length\n}",
    "docs": "/**\n * Calculate the number of key/value pairs in a record\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 63,
        "to": 65
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "\n\n/**\n * Test whether a record is empty\n *\n * @since 2.5.0\n */\nexport function isEmpty(r: ReadonlyRecord<string, unknown>): boolean {\n  return Object.keys(r).length === 0\n}",
    "docs": "/**\n * Test whether a record is empty\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 72,
        "to": 74
      }
    }
  },
  {
    "name": "keys",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function keys<K extends string>(r: ReadonlyRecord<K, unknown>): ReadonlyArray<K> {\n  return (Object.keys(r) as any).sort()\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly K[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 79,
        "to": 81
      }
    }
  },
  {
    "name": "collect",
    "text": "\n\n/**\n * Map a record into an array\n *\n * @example\n * import {collect} from 'fp-ts/lib/ReadonlyRecord'\n *\n * const x: { a: string, b: boolean } = { a: 'foo', b: false }\n * assert.deepStrictEqual(\n *   collect((key, val) => ({key: key, value: val}))(x),\n *   [{key: 'a', value: 'foo'}, {key: 'b', value: false}]\n * )\n *\n * @since 2.5.0\n */\nexport function collect<K extends string, A, B>(f: (k: K, a: A) => B): (r: ReadonlyRecord<K, A>) => ReadonlyArray<B> {\n  return (r) => {\n    // tslint:disable-next-line: readonly-array\n    const out: Array<B> = []\n    for (const key of keys(r)) {\n      out.push(f(key, r[key]))\n    }\n    return out\n  }\n}",
    "docs": "/**\n * Map a record into an array\n *\n * @example\n * import {collect} from 'fp-ts/lib/ReadonlyRecord'\n *\n * const x: { a: string, b: boolean } = { a: 'foo', b: false }\n * assert.deepStrictEqual(\n *   collect((key, val) => ({key: key, value: val}))(x),\n *   [{key: 'a', value: 'foo'}, {key: 'b', value: false}]\n * )\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<K, A>>) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 97,
        "to": 106
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a record into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function toUnfoldable<F extends URIS>(\n  U: Unfoldable1<F>\n): <K extends string, A>(r: ReadonlyRecord<K, A>) => Kind<F, readonly [K, A]>",
    "docs": "/**\n * Unfolds a record into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(\n  U: Unfoldable<F>\n): <K extends string, A>(r: ReadonlyRecord<K, A>) => HKT<F, readonly [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 125,
        "to": 127
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <A>(r: ReadonlyRecord<string, A>) => HKT<F, readonly [string, A]> {\n  return (r) => {\n    const arr = toReadonlyArray(r)\n    const len = arr.length\n    return U.unfold(0, (b) => (b < len ? optionSome([arr[b], b + 1]) : none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [string, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 128,
        "to": 134
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\n\n/**\n * Insert or replace a key/value pair in a record\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function insertAt<K extends string, A>(\n  k: K,\n  a: A\n): <KS extends string>(r: ReadonlyRecord<KS, A>) => ReadonlyRecord<KS | K, A>",
    "docs": "/**\n * Insert or replace a key/value pair in a record\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string>(r: Readonly<Record<KS, A>>) => Readonly<Record<K | KS, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 142,
        "to": 145
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\nexport function insertAt<A>(k: string, a: A): (r: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A> {\n  return (r) => {\n    if (r[k] === a) {\n      return r\n    }\n    const out: Record<string, A> = Object.assign({}, r)\n    out[k] = a\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 146,
        "to": 155
      }
    }
  },
  {
    "name": "hasOwnProperty",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function hasOwnProperty<K extends string>(k: string, r: ReadonlyRecord<K, unknown>): k is K {\n  return _hasOwnProperty.call(r, k)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 162,
        "to": 164
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete a key and value from a map\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function deleteAt<K extends string>(\n  k: K\n): <KS extends string, A>(r: ReadonlyRecord<KS, A>) => ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>",
    "docs": "/**\n * Delete a key and value from a map\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Readonly<Record<KS, A>>) => Readonly<Record<string extends K ? string : Exclude<KS, K>, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 172,
        "to": 174
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\nexport function deleteAt(k: string): <A>(r: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A> {\n  return <A>(r: ReadonlyRecord<string, A>) => {\n    if (!_hasOwnProperty.call(r, k)) {\n      return r\n    }\n    const out: Record<string, A> = Object.assign({}, r)\n    delete out[k]\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 175,
        "to": 184
      }
    }
  },
  {
    "name": "updateAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function updateAt<A>(\n  k: string,\n  a: A\n): <K extends string>(r: ReadonlyRecord<K, A>) => Option<ReadonlyRecord<K, A>> {\n  return <K extends string>(r: ReadonlyRecord<K, A>) => {\n    if (!hasOwnProperty(k, r)) {\n      return none\n    }\n    if (r[k] === a) {\n      return optionSome(r)\n    }\n    const out: Record<K, A> = Object.assign({}, r)\n    out[k] = a\n    return optionSome(out)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 189,
        "to": 204
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function modifyAt<A>(\n  k: string,\n  f: (a: A) => A\n): <K extends string>(r: ReadonlyRecord<K, A>) => Option<ReadonlyRecord<K, A>> {\n  return <K extends string>(r: ReadonlyRecord<K, A>) => {\n    if (!hasOwnProperty(k, r)) {\n      return none\n    }\n    const out: Record<K, A> = Object.assign({}, r)\n    out[k] = f(r[k])\n    return optionSome(out)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 209,
        "to": 221
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */\nexport function pop<K extends string>(\n  k: K\n): <KS extends string, A>(\n  r: ReadonlyRecord<KS, A>\n) => Option<readonly [A, ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>]>",
    "docs": "/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Readonly<Record<KS, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, Readonly<Record<string extends K ? string : Exclude<KS, K>, A>>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 228,
        "to": 232
      }
    }
  },
  {
    "name": "pop",
    "text": "\nexport function pop(k: string): <A>(r: ReadonlyRecord<string, A>) => Option<readonly [A, ReadonlyRecord<string, A>]> {\n  const deleteAtk = deleteAt(k)\n  return (r) => {\n    const oa = lookup(k, r)\n    return isNone(oa) ? none : optionSome([oa.value, deleteAtk(r)])\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, Readonly<Record<string, A>>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 233,
        "to": 239
      }
    }
  },
  {
    "name": "isSubrecord",
    "text": "\n\n/**\n * Test whether one record contains all of the keys and values contained in another record\n *\n * @since 2.5.0\n */\nexport function isSubrecord<A>(E: Eq<A>): (x: ReadonlyRecord<string, A>, y: ReadonlyRecord<string, A>) => boolean {\n  return (x, y) => {\n    for (const k in x) {\n      if (!_hasOwnProperty.call(y, k) || !E.equals(x[k], y[k])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "/**\n * Test whether one record contains all of the keys and values contained in another record\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: Readonly<Record<string, A>>, y: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 246,
        "to": 255
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<K extends string, A>(E: Eq<A>): Eq<ReadonlyRecord<K, A>>",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 261,
        "to": 261
      }
    }
  },
  {
    "name": "getEq",
    "text": "\nexport function getEq<A>(E: Eq<A>): Eq<ReadonlyRecord<string, A>> {\n  const isSubrecordE = isSubrecord(E)\n  return fromEquals((x, y) => isSubrecordE(x, y) && isSubrecordE(y, x))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 262,
        "to": 265
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Returns a `Semigroup` instance for records given a `Semigroup` instance for their values\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { getMonoid } from 'fp-ts/lib/ReadonlyRecord'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid<K extends string, A>(S: Semigroup<A>): Monoid<ReadonlyRecord<K, A>>",
    "docs": "/**\n * Returns a `Semigroup` instance for records given a `Semigroup` instance for their values\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { getMonoid } from 'fp-ts/lib/ReadonlyRecord'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 280,
        "to": 280
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\nexport function getMonoid<A>(S: Semigroup<A>): Monoid<ReadonlyRecord<string, A>> {\n  return {\n    concat: (x, y) => {\n      if (x === empty) {\n        return y\n      }\n      if (y === empty) {\n        return x\n      }\n      const keys = Object.keys(y)\n      const len = keys.length\n      if (len === 0) {\n        return x\n      }\n      const r: Record<string, A> = { ...x }\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        r[k] = _hasOwnProperty.call(x, k) ? S.concat(x[k], y[k]) : y[k]\n      }\n      return r\n    },\n    empty\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 281,
        "to": 304
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n/**\n * Lookup the value for a key in a record\n *\n * @since 2.5.0\n */\nexport function lookup<A>(k: string, r: ReadonlyRecord<string, A>): Option<A> {\n  return _hasOwnProperty.call(r, k) ? optionSome(r[k]) : none\n}",
    "docs": "/**\n * Lookup the value for a key in a record\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 311,
        "to": 313
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\n\n/**\n * Map a record passing the keys to the iterating function\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function mapWithIndex<K extends string, A, B>(\n  f: (k: K, a: A) => B\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>",
    "docs": "/**\n * Map a record passing the keys to the iterating function\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 326,
        "to": 328
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\nexport function mapWithIndex<A, B>(\n  f: (k: string, a: A) => B\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return (fa) => mapWithIndex_(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 329,
        "to": 333
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * Map a record passing the values to the iterating function\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function map<A, B>(f: (a: A) => B): <K extends string>(fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>",
    "docs": "/**\n * Map a record passing the values to the iterating function\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fa: Readonly<Record<K, A>>) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 341,
        "to": 341
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<A, B>(f: (a: A) => B): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return mapWithIndex((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 342,
        "to": 344
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduceWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, b: B, a: A) => B\n): (fa: ReadonlyRecord<K, A>) => B",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 349,
        "to": 352
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\nexport function reduceWithIndex<A, B>(b: B, f: (k: string, b: B, a: A) => B): (fa: ReadonlyRecord<string, A>) => B {\n  return (fa) => reduceWithIndex_(fa, b, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 353,
        "to": 355
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <K extends string, A>(f: (k: K, a: A) => M) => (fa: ReadonlyRecord<K, A>) => M",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(f: (k: K, a: A) => M) => (fa: Readonly<Record<K, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 360,
        "to": 362
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\nexport function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <A>(f: (k: string, a: A) => M) => (fa: ReadonlyRecord<string, A>) => M {\n  const foldMapWithIndexM = foldMapWithIndex_(M)\n  return (f) => (fa) => foldMapWithIndexM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (k: string, a: A) => M) => (fa: Readonly<Record<string, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 363,
        "to": 368
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduceRightWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, a: A, b: B) => B\n): (fa: ReadonlyRecord<K, A>) => B",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 373,
        "to": 376
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\nexport function reduceRightWithIndex<A, B>(\n  b: B,\n  f: (k: string, a: A, b: B) => B\n): (fa: ReadonlyRecord<string, A>) => B {\n  return (fa) => reduceRightWithIndex_(fa, b, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 377,
        "to": 382
      }
    }
  },
  {
    "name": "singleton",
    "text": "\n\n/**\n * Create a record with one key/value pair\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function singleton<K extends string, A>(k: K, a: A): ReadonlyRecord<K, A> {\n  return { [k]: a } as any\n}",
    "docs": "/**\n * Create a record with one key/value pair\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 390,
        "to": 392
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function traverseWithIndex<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 397,
        "to": 401
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 402,
        "to": 406
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A, B>(\n  f: (k: K, a: A) => Kind2<F, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 407,
        "to": 411
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A, B>(\n  f: (k: K, a: A) => Kind2<F, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 412,
        "to": 416
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A, B>(\n  f: (k: K, a: A) => Kind<F, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 417,
        "to": 421
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 422,
        "to": 424
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <A, B>(f: (k: string, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>> {\n  const traverseWithIndexF = traverseWithIndex_(F)\n  return (f) => (ta) => traverseWithIndexF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 425,
        "to": 430
      }
    }
  },
  {
    "name": "traverse",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function traverse<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A, B>(\n  f: (a: A) => Kind3<F, R, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 435,
        "to": 439
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <R, A, B>(\n  f: (a: A) => Kind3<F, R, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 440,
        "to": 444
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A, B>(\n  f: (a: A) => Kind2<F, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 445,
        "to": 449
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A, B>(\n  f: (a: A) => Kind2<F, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 450,
        "to": 454
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS>(\n  F: Applicative1<F>\n): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 455,
        "to": 457
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 458,
        "to": 460
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => (ta: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>> {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 461,
        "to": 466
      }
    }
  },
  {
    "name": "sequence",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function sequence<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 471,
        "to": 473
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 474,
        "to": 476
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 477,
        "to": 479
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 480,
        "to": 482
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A>(ta: ReadonlyRecord<K, Kind<F, A>>) => Kind<F, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 483,
        "to": 485
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(\n  F: Applicative<F>\n): <K extends string, A>(ta: ReadonlyRecord<K, HKT<F, A>>) => HKT<F, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 486,
        "to": 488
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(\n  F: Applicative<F>\n): <A>(ta: ReadonlyRecord<string, HKT<F, A>>) => HKT<F, ReadonlyRecord<string, A>> {\n  return traverseWithIndex(F)((_, a) => a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 489,
        "to": 493
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionMapWithIndex<K extends string, A, B, C>(\n  f: (key: K, a: A) => Either<B, C>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 522,
        "to": 524
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\nexport function partitionMapWithIndex<A, B, C>(\n  f: (key: string, a: A) => Either<B, C>\n): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>> {\n  return (fa) => partitionMapWithIndex_(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 525,
        "to": 529
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 534,
        "to": 536
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 537,
        "to": 539
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>> {\n  return (fa) => partitionWithIndex_(fa, predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 540,
        "to": 544
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filterMapWithIndex<K extends string, A, B>(\n  f: (key: K, a: A) => Option<B>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 550,
        "to": 552
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\nexport function filterMapWithIndex<A, B>(\n  f: (key: string, a: A) => Option<B>\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return (fa) => filterMapWithIndex_(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 553,
        "to": 557
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function filterWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 562,
        "to": 564
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 565,
        "to": 567
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A> {\n  return (fa) => filterWithIndex_(fa, predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 568,
        "to": 572
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a record from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.5.0\n */\nexport function fromFoldable<F extends URIS3, A>(\n  M: Magma<A>,\n  F: Foldable3<F>\n): <K extends string, R, E>(fka: Kind3<F, R, E, readonly [K, A]>) => ReadonlyRecord<K, A>",
    "docs": "/**\n * Create a record from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, readonly [K, A]>) => Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 580,
        "to": 583
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, A>(\n  M: Magma<A>,\n  F: Foldable2<F>\n): <K extends string, E>(fka: Kind2<F, E, readonly [K, A]>) => ReadonlyRecord<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, readonly [K, A]>) => Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 584,
        "to": 587
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, A>(\n  M: Magma<A>,\n  F: Foldable1<F>\n): <K extends string>(fka: Kind<F, readonly [K, A]>) => ReadonlyRecord<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>) => Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 588,
        "to": 591
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(\n  M: Magma<A>,\n  F: Foldable<F>\n): <K extends string>(fka: HKT<F, readonly [K, A]>) => ReadonlyRecord<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>) => Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 592,
        "to": 595
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [string, A]>) => ReadonlyRecord<string, A> {\n  const fromFoldableMapM = fromFoldableMap(M, F)\n  return (fka) => fromFoldableMapM(fka, identity)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 596,
        "to": 602
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\n\n/**\n * Create a record from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { getLastSemigroup } from 'fp-ts/lib/Semigroup'\n * import { readonlyArray, zip } from 'fp-ts/lib/ReadonlyArray'\n * import { identity } from 'fp-ts/lib/function'\n * import { ReadonlyRecord, fromFoldableMap } from 'fp-ts/lib/ReadonlyRecord'\n *\n * // like lodash `zipObject` or ramda `zipObj`\n * export const zipObject = <K extends string, A>(keys: ReadonlyArray<K>, values: ReadonlyArray<A>): ReadonlyRecord<K, A> =>\n *   fromFoldableMap(getLastSemigroup<A>(), readonlyArray)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * // build a record from a field\n * interface User {\n *   id: string\n *   name: string\n * }\n *\n * const users: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(getLastSemigroup<User>(), readonlyArray)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.5.0\n */\nexport function fromFoldableMap<F extends URIS3, B>(\n  M: Magma<B>,\n  F: Foldable3<F>\n): <R, E, A, K extends string>(fa: Kind3<F, R, E, A>, f: (a: A) => readonly [K, B]) => ReadonlyRecord<K, B>",
    "docs": "/**\n * Create a record from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { getLastSemigroup } from 'fp-ts/lib/Semigroup'\n * import { readonlyArray, zip } from 'fp-ts/lib/ReadonlyArray'\n * import { identity } from 'fp-ts/lib/function'\n * import { ReadonlyRecord, fromFoldableMap } from 'fp-ts/lib/ReadonlyRecord'\n *\n * // like lodash `zipObject` or ramda `zipObj`\n * export const zipObject = <K extends string, A>(keys: ReadonlyArray<K>, values: ReadonlyArray<A>): ReadonlyRecord<K, A> =>\n *   fromFoldableMap(getLastSemigroup<A>(), readonlyArray)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * // build a record from a field\n * interface User {\n *   id: string\n *   name: string\n * }\n *\n * const users: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(getLastSemigroup<User>(), readonlyArray)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>, f: (a: A) => readonly [K, B]) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 641,
        "to": 644
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS2, B>(\n  M: Magma<B>,\n  F: Foldable2<F>\n): <E, A, K extends string>(fa: Kind2<F, E, A>, f: (a: A) => readonly [K, B]) => ReadonlyRecord<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>, f: (a: A) => readonly [K, B]) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 645,
        "to": 648
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS, B>(\n  M: Magma<B>,\n  F: Foldable1<F>\n): <A, K extends string>(fa: Kind<F, A>, f: (a: A) => readonly [K, B]) => ReadonlyRecord<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => readonly [K, B]) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 649,
        "to": 652
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: Foldable<F>\n): <A, K extends string>(fa: HKT<F, A>, f: (a: A) => readonly [K, B]) => ReadonlyRecord<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => readonly [K, B]) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 653,
        "to": 656
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: Foldable<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B> {\n  return <A>(ta: HKT<F, A>, f: (a: A) => readonly [string, B]) => {\n    return F.reduce<A, Record<string, B>>(ta, {}, (r, a) => {\n      const [k, b] = f(a)\n      r[k] = _hasOwnProperty.call(r, k) ? M.concat(r[k], b) : b\n      return r\n    })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 657,
        "to": 668
      }
    }
  },
  {
    "name": "every",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function every<A>(predicate: Predicate<A>): (r: ReadonlyRecord<string, A>) => boolean {\n  return (r) => {\n    for (const k in r) {\n      if (!predicate(r[k])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 673,
        "to": 682
      }
    }
  },
  {
    "name": "some",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function some<A>(predicate: (a: A) => boolean): (r: ReadonlyRecord<string, A>) => boolean {\n  return (r) => {\n    for (const k in r) {\n      if (predicate(r[k])) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 687,
        "to": 696
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, fa: ReadonlyRecord<string, A>) => boolean {\n  return (a, fa) => {\n    for (const k in fa) {\n      if (E.equals(fa[k], a)) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, fa: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 701,
        "to": 710
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (ta: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>>) => {\n  const witherF = wither_(F)\n  return (f) => (ta) => witherF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ta: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 499,
        "to": 504
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B, C>(\n  f: (a: A) => HKT<F, Either<B, C>>\n) => (wa: ReadonlyRecord<string, A>) => HKT<F, Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>>) => {\n  const wiltF = wilt_(F)\n  return (f) => (ta) => wiltF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (wa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 510,
        "to": 517
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>\n  <A>(predicate: Predicate<A>): (fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>\n} = <A>(predicate: Predicate<A>) => (fa: Readonly<Record<string, A>>) => filter_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 926,
        "to": 929
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(\n  f: (a: A) => Option<B>\n) => (fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>> = (f) => (fa) => filterMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 935,
        "to": 937
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Readonly<Record<string, A>>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: Readonly<Record<string, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 943,
        "to": 946
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (\n    fa: Readonly<Record<string, A>>\n  ) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>\n  <A>(predicate: Predicate<A>): (\n    fa: Readonly<Record<string, A>>\n  ) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>\n} = <A>(predicate: Predicate<A>) => (fa: Readonly<Record<string, A>>) => partition_(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 952,
        "to": 959
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Readonly<Record<string, A>>) => Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>> = (f) => (\n  fa\n) => partitionMap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 965,
        "to": 969
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Readonly<Record<string, A>>) => B = (b, f) => (fa) =>\n  reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 975,
        "to": 976
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Readonly<Record<string, A>>) => B = (b, f) => (\n  fa\n) => reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 982,
        "to": 984
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <A>(fa: Readonly<Record<string, Option<A>>>): Readonly<Record<string, A>> => {\n  const r: Record<string, A> = {}\n  const keys = Object.keys(fa)\n  for (const key of keys) {\n    const optionA = fa[key]\n    if (isSome(optionA)) {\n      r[key] = optionA.value\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 990,
        "to": 1000
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <A, B>(\n  fa: Readonly<Record<string, Either<A, B>>>\n): Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>> => {\n  const left: Record<string, A> = {}\n  const right: Record<string, B> = {}\n  const keys = Object.keys(fa)\n  for (const key of keys) {\n    const e = fa[key]\n    switch (e._tag) {\n      case 'Left':\n        left[key] = e.left\n        break\n      case 'Right':\n        right[key] = e.right\n        break\n    }\n  }\n  return {\n    left,\n    right\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1006,
        "to": 1027
      }
    }
  },
  {
    "name": "fromSet",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function fromSet<A>(s: Set<A>): ReadonlySet<A> {\n  return new Set(s)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "Set<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 18,
        "to": 20
      }
    }
  },
  {
    "name": "toSet",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toSet<A>(s: ReadonlySet<A>): Set<A> {\n  return new Set(s)\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "ReadonlySet<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 26,
        "to": 28
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<A>(S: Show<A>): Show<ReadonlySet<A>> {\n  return {\n    show: (s) => {\n      let elements = ''\n      s.forEach((a) => {\n        elements += S.show(a) + ', '\n      })\n      if (elements !== '') {\n        elements = elements.substring(0, elements.length - 2)\n      }\n      return `new Set([${elements}])`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 34,
        "to": 47
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toReadonlyArray<A>(O: Ord<A>): (set: ReadonlySet<A>) => ReadonlyArray<A> {\n  return (x) => {\n    // tslint:disable-next-line: readonly-array\n    const r: Array<A> = []\n    x.forEach((e) => r.push(e))\n    return r.sort(O.compare)\n  }\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 58,
        "to": 65
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<ReadonlySet<A>> {\n  const subsetE = isSubset(E)\n  return fromEquals((x, y) => subsetE(x, y) && subsetE(y, x))\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 71,
        "to": 74
      }
    }
  },
  {
    "name": "some",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function some<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => boolean {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    let found = false\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!found && !(e = values.next()).done) {\n      found = predicate(e.value)\n    }\n    return found\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 84,
        "to": 95
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * Projects a Set through a function\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function map<B>(E: Eq<B>): <A>(f: (x: A) => B) => (set: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      const v = f(e)\n      if (!elemE(v, r)) {\n        r.add(v)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * Projects a Set through a function\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => B) => (set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 103,
        "to": 115
      }
    }
  },
  {
    "name": "every",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function every<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => boolean {\n  return not(some(not(predicate)))\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 120,
        "to": 122
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function chain<B>(E: Eq<B>): <A>(f: (x: A) => ReadonlySet<B>) => (set: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      f(e).forEach((e) => {\n        if (!elemE(e, r)) {\n          r.add(e)\n        }\n      })\n    })\n    return r\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => ReadonlySet<B>) => (set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 128,
        "to": 141
      }
    }
  },
  {
    "name": "isSubset",
    "text": "\n\n/**\n * `true` if and only if every element in the first set is an element of the second set\n *\n * @since 2.5.0\n */\nexport function isSubset<A>(E: Eq<A>): (x: ReadonlySet<A>, y: ReadonlySet<A>) => boolean {\n  const elemE = elem(E)\n  return (x, y) => every((a: A) => elemE(a, y))(x)\n}",
    "docs": "/**\n * `true` if and only if every element in the first set is an element of the second set\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: ReadonlySet<A>, y: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 148,
        "to": 151
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filter<A, B extends A>(refinement: Refinement<A, B>): (set: ReadonlySet<A>) => ReadonlySet<B>",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 157,
        "to": 157
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => ReadonlySet<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 158,
        "to": 158
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => ReadonlySet<A> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const r = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        r.add(value)\n      }\n    }\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 159,
        "to": 173
      }
    }
  },
  {
    "name": "partition",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partition<A, B extends A>(\n  refinement: Refinement<A, B>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlySet<A>, ReadonlySet<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 178,
        "to": 180
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(\n  predicate: Predicate<A>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlySet<A>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 181,
        "to": 183
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(\n  predicate: Predicate<A>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<A>> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const right = new Set<A>()\n    const left = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        right.add(value)\n      } else {\n        left.add(value)\n      }\n    }\n    return { left, right }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlySet<A>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 184,
        "to": 203
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * Test if a value is a member of a set\n *\n * @since 2.5.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, set: ReadonlySet<A>) => boolean {\n  return (a, set) => {\n    const values = set.values()\n    let e: Next<A>\n    let found = false\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!found && !(e = values.next()).done) {\n      found = E.equals(a, e.value)\n    }\n    return found\n  }\n}",
    "docs": "/**\n * Test if a value is a member of a set\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, set: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 210,
        "to": 221
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function union<A>(E: Eq<A>): (set: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A> {\n  const elemE = elem(E)\n  return (x, y) => {\n    if (x === empty) {\n      return y\n    }\n    if (y === empty) {\n      return x\n    }\n    const r = new Set(x)\n    y.forEach((e) => {\n      if (!elemE(e, r)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 229,
        "to": 246
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function intersection<A>(E: Eq<A>): (set: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A> {\n  const elemE = elem(E)\n  return (x, y) => {\n    if (x === empty || y === empty) {\n      return empty\n    }\n    const r = new Set<A>()\n    x.forEach((e) => {\n      if (elemE(e, y)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 254,
        "to": 268
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionMap<B, C>(\n  EB: Eq<B>,\n  EC: Eq<C>\n): <A>(f: (a: A) => Either<B, C>) => (set: ReadonlySet<A>) => Separated<ReadonlySet<B>, ReadonlySet<C>> {\n  return <A>(f: (a: A) => Either<B, C>) => (set: ReadonlySet<A>) => {\n    const values = set.values()\n    let e: Next<A>\n    const left = new Set<B>()\n    const right = new Set<C>()\n    const hasB = elem(EB)\n    const hasC = elem(EC)\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const v = f(e.value)\n      switch (v._tag) {\n        case 'Left':\n          if (!hasB(v.left, left)) {\n            left.add(v.left)\n          }\n          break\n        case 'Right':\n          if (!hasC(v.right, right)) {\n            right.add(v.right)\n          }\n          break\n      }\n    }\n    return { left, right }\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EB",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        },
        {
          "name": "EC",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlySet<B>, ReadonlySet<C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 273,
        "to": 302
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/lib/ReadonlySet'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(difference(eqNumber)(new Set([1, 2]), new Set([1, 3])), new Set([2]))\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function difference<A>(E: Eq<A>): (x: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A> {\n  const elemE = elem(E)\n  return (x, y) => filter((a: A) => !elemE(a, y))(x)\n}",
    "docs": "/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/lib/ReadonlySet'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.deepStrictEqual(difference(eqNumber)(new Set([1, 2]), new Set([1, 3])), new Set([2]))\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: ReadonlySet<A>, y: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 316,
        "to": 319
      }
    }
  },
  {
    "name": "getUnionMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getUnionMonoid<A>(E: Eq<A>): Monoid<ReadonlySet<A>> {\n  return {\n    concat: union(E),\n    empty\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 325,
        "to": 330
      }
    }
  },
  {
    "name": "getIntersectionSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getIntersectionSemigroup<A>(E: Eq<A>): Semigroup<ReadonlySet<A>> {\n  return {\n    concat: intersection(E)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 336,
        "to": 340
      }
    }
  },
  {
    "name": "reduce",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduce<A>(O: Ord<A>): <B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlySet<A>) => B {\n  const toArrayO = toReadonlyArray(O)\n  return (b, f) => (fa) => toArrayO(fa).reduce(f, b)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlySet<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 345,
        "to": 348
      }
    }
  },
  {
    "name": "foldMap",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function foldMap<A, M>(O: Ord<A>, M: Monoid<M>): (f: (a: A) => M) => (fa: ReadonlySet<A>) => M {\n  const toArrayO = toReadonlyArray(O)\n  return (f) => (fa) => toArrayO(fa).reduce((b, a) => M.concat(b, f(a)), M.empty)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(f: (a: A) => M) => (fa: ReadonlySet<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 353,
        "to": 356
      }
    }
  },
  {
    "name": "singleton",
    "text": "\n\n/**\n * Create a set with one element\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function singleton<A>(a: A): ReadonlySet<A> {\n  return new Set([a])\n}",
    "docs": "/**\n * Create a set with one element\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 364,
        "to": 366
      }
    }
  },
  {
    "name": "insert",
    "text": "\n\n/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function insert<A>(E: Eq<A>): (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A> {\n  const elemE = elem(E)\n  return (a) => (set) => {\n    if (!elemE(a, set)) {\n      const r = new Set(set)\n      r.add(a)\n      return r\n    } else {\n      return set\n    }\n  }\n}",
    "docs": "/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 374,
        "to": 385
      }
    }
  },
  {
    "name": "remove",
    "text": "\n\n/**\n * Delete a value from a set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function remove<A>(E: Eq<A>): (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A> {\n  return (a) => (set) => filter((ax: A) => !E.equals(a, ax))(set)\n}",
    "docs": "/**\n * Delete a value from a set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 393,
        "to": 395
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * Create a set from an array\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function fromArray<A>(E: Eq<A>): (as: ReadonlyArray<A>) => ReadonlySet<A> {\n  return (as) => {\n    const len = as.length\n    const r = new Set<A>()\n    const has = elem(E)\n    for (let i = 0; i < len; i++) {\n      const a = as[i]\n      if (!has(a, r)) {\n        r.add(a)\n      }\n    }\n    return r\n  }\n}",
    "docs": "/**\n * Create a set from an array\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 403,
        "to": 416
      }
    }
  },
  {
    "name": "compact",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function compact<A>(E: Eq<A>): (fa: ReadonlySet<Option<A>>) => ReadonlySet<A> {\n  return filterMap(E)(identity)\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlySet<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 422,
        "to": 424
      }
    }
  },
  {
    "name": "separate",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function separate<E, A>(\n  EE: Eq<E>,\n  EA: Eq<A>\n): (fa: ReadonlySet<Either<E, A>>) => Separated<ReadonlySet<E>, ReadonlySet<A>> {\n  return (fa) => {\n    const elemEE = elem(EE)\n    const elemEA = elem(EA)\n    const left: Set<E> = new Set()\n    const right: Set<A> = new Set()\n    fa.forEach((e) => {\n      switch (e._tag) {\n        case 'Left':\n          if (!elemEE(e.left, left)) {\n            left.add(e.left)\n          }\n          break\n        case 'Right':\n          if (!elemEA(e.right, right)) {\n            right.add(e.right)\n          }\n          break\n      }\n    })\n    return { left, right }\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlySet<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<ReadonlySet<E>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 429,
        "to": 454
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filterMap<B>(E: Eq<B>): <A>(f: (a: A) => Option<B>) => (fa: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (fa) => {\n    const r: Set<B> = new Set()\n    fa.forEach((a) => {\n      const ob = f(a)\n      if (ob._tag === 'Some' && !elemE(ob.value, r)) {\n        r.add(ob.value)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fa: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 460,
        "to": 472
      }
    }
  },
  {
    "name": "fst",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function fst<A, S>(sa: readonly [A, S]): A {\n  return sa[0]\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "sa",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, S]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 28,
        "to": 30
      }
    }
  },
  {
    "name": "snd",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function snd<A, S>(sa: readonly [A, S]): S {\n  return sa[1]\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "sa",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, S]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 36,
        "to": 38
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function swap<A, S>(sa: readonly [A, S]): readonly [S, A] {\n  return [snd(sa), fst(sa)]\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "sa",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, S]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [S, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 44,
        "to": 46
      }
    }
  },
  {
    "name": "getApply",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getApply<S>(S: Semigroup<S>): Apply2C<URI, S> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: (fab, fa) => [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))]\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 52,
        "to": 59
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getApplicative<S>(M: Monoid<S>): Applicative2C<URI, S> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 69,
        "to": 78
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getChain<S>(S: Semigroup<S>): Chain2C<URI, S> {\n  const A = getApply(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    chain: (fa, f) => {\n      const [b, s] = f(fst(fa))\n      return [b, S.concat(snd(fa), s)]\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 84,
        "to": 96
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getMonad<S>(M: Monoid<S>): Monad2C<URI, S> {\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 102,
        "to": 112
      }
    }
  },
  {
    "name": "getChainRec",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getChainRec<S>(M: Monoid<S>): ChainRec2C<URI, S> {\n  const chainRec = <A, B>(a: A, f: (a: A) => readonly [Either<A, B>, S]): readonly [B, S] => {\n    let result: readonly [Either<A, B>, S] = f(a)\n    let acc: S = M.empty\n    let s: Either<A, B> = fst(result)\n    while (s._tag === 'Left') {\n      acc = M.concat(acc, snd(result))\n      result = f(s.left)\n      s = fst(result)\n    }\n    return [s.right, M.concat(acc, snd(result))]\n  }\n\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    chainRec\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ChainRec\").ChainRec2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 118,
        "to": 140
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: readonly [A, E]) => readonly [B, G] = (\n  f,\n  g\n) => (fa) => bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly [A, E]) => readonly [B, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 174,
        "to": 177
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G] = (f) => (fa) =>\n  mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: readonly [A, E]) => readonly [A, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 185,
        "to": 186
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <E, A>(la: readonly [A, E]) => <B>(ab: readonly [B, A]) => readonly [B, E] = (la) => (ab) =>\n  compose_(ab, la)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "la",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(ab: readonly [B, A]) => readonly [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 192,
        "to": 193
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <E, A>(ma: readonly [A, E]) => readonly [readonly [A, E], E] = (ma) => extend_(ma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [readonly [A, E], E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 199,
        "to": 199
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (fa: readonly [A, E]) => B) => (wa: readonly [A, E]) => readonly [B, E] = (f) => (\n  ma\n) => extend_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(fa: readonly [A, E]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly [A, E]) => readonly [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 205,
        "to": 207
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 219,
        "to": 222
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E] = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => readonly [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 231,
        "to": 231
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: readonly [A, E]) => B = (b, f) => (fa) =>\n  reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 237,
        "to": 238
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: readonly [A, E]) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 244,
        "to": 245
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <S>(as: readonly [A, S]) => HKT<F, readonly [B, S]>) => {\n  return (f) => (ta) => traverse_(F)(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <S>(as: readonly [A, S]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [B, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 279,
        "to": 283
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <A, S>(\n  fas: readonly [HKT<F, A>, S]\n): HKT<F, readonly [A, S]> => {\n  return F.map(fst(fas), (a) => [a, snd(fas)])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(fas: readonly [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, S]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 288,
        "to": 292
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a record into a list of key/value pairs\n *\n * @since 2.0.0\n */\nexport function toUnfoldable<F extends URIS>(\n  U: Unfoldable1<F>\n): <K extends string, A>(r: Record<K, A>) => Kind<F, [K, A]>",
    "docs": "/**\n * Unfolds a record into a list of key/value pairs\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <K extends string, A>(r: Record<K, A>) => HKT<F, [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 85,
        "to": 85
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <A>(r: Record<string, A>) => HKT<F, [string, A]> {\n  return RR.toUnfoldable(U) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [string, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\n\n/**\n * Insert or replace a key/value pair in a record\n *\n * @since 2.0.0\n */\nexport function insertAt<K extends string, A>(k: K, a: A): <KS extends string>(r: Record<KS, A>) => Record<KS | K, A>",
    "docs": "/**\n * Insert or replace a key/value pair in a record\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string>(r: Record<KS, A>) => Record<K | KS, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 95,
        "to": 95
      }
    }
  },
  {
    "name": "insertAt",
    "text": "\nexport function insertAt<A>(k: string, a: A): (r: Record<string, A>) => Record<string, A> {\n  return RR.insertAt(k, a) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Record<string, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 96,
        "to": 98
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete a key and value from a map\n *\n * @since 2.0.0\n */\nexport function deleteAt<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>",
    "docs": "/**\n * Delete a key and value from a map\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\nexport function deleteAt(k: string): <A>(r: Record<string, A>) => Record<string, A> {\n  return RR.deleteAt(k) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 113,
        "to": 115
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.0.0\n */\nexport function pop<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Option<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>",
    "docs": "/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Record<KS, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 133,
        "to": 135
      }
    }
  },
  {
    "name": "pop",
    "text": "\nexport function pop(k: string): <A>(r: Record<string, A>) => Option<[A, Record<string, A>]> {\n  return RR.pop(k) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[A, Record<string, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 136,
        "to": 138
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getEq<K extends string, A>(E: Eq<A>): Eq<Record<K, A>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 150,
        "to": 150
      }
    }
  },
  {
    "name": "getEq",
    "text": "\nexport function getEq<A>(E: Eq<A>): Eq<Record<string, A>> {\n  return RR.getEq(E)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Returns a `Semigroup` instance for records given a `Semigroup` instance for their values\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { getMonoid } from 'fp-ts/lib/Record'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @since 2.0.0\n */\nexport function getMonoid<K extends string, A>(S: Semigroup<A>): Monoid<Record<K, A>>",
    "docs": "/**\n * Returns a `Semigroup` instance for records given a `Semigroup` instance for their values\n *\n * @example\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n * import { getMonoid } from 'fp-ts/lib/Record'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\nexport function getMonoid<A>(S: Semigroup<A>): Monoid<Record<string, A>> {\n  return RR.getMonoid(S)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 168,
        "to": 170
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\n\n/**\n * Map a record passing the keys to the iterating function\n *\n * @since 2.0.0\n */\nexport function mapWithIndex<K extends string, A, B>(f: (k: K, a: A) => B): (fa: Record<K, A>) => Record<K, B>",
    "docs": "/**\n * Map a record passing the keys to the iterating function\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 189,
        "to": 189
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\nexport function mapWithIndex<A, B>(f: (k: string, a: A) => B): (fa: Record<string, A>) => Record<string, B> {\n  return RR.mapWithIndex(f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 190,
        "to": 192
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * Map a record passing the values to the iterating function\n *\n * @since 2.0.0\n */\nexport function map<A, B>(f: (a: A) => B): <K extends string>(fa: Record<K, A>) => Record<K, B>",
    "docs": "/**\n * Map a record passing the values to the iterating function\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fa: Record<K, A>) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 199,
        "to": 199
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<A, B>(f: (a: A) => B): (fa: Record<string, A>) => Record<string, B> {\n  return RR.map(f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 200,
        "to": 202
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function reduceWithIndex<K extends string, A, B>(b: B, f: (k: K, b: B, a: A) => B): (fa: Record<K, A>) => B",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 207,
        "to": 207
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\nexport function reduceWithIndex<A, B>(b: B, f: (k: string, b: B, a: A) => B): (fa: Record<string, A>) => B {\n  return RR.reduceWithIndex(b, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 208,
        "to": 210
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(f: (k: K, a: A) => M) => (fa: Record<K, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 215,
        "to": 217
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\nexport function foldMapWithIndex<M>(M: Monoid<M>): <A>(f: (k: string, a: A) => M) => (fa: Record<string, A>) => M {\n  return RR.foldMapWithIndex(M)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (k: string, a: A) => M) => (fa: Record<string, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 218,
        "to": 220
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function reduceRightWithIndex<K extends string, A, B>(b: B, f: (k: K, a: A, b: B) => B): (fa: Record<K, A>) => B",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 225,
        "to": 225
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\nexport function reduceRightWithIndex<A, B>(b: B, f: (k: string, a: A, b: B) => B): (fa: Record<string, A>) => B {\n  return RR.reduceRightWithIndex(b, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 226,
        "to": 228
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function traverseWithIndex<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 240,
        "to": 244
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 245,
        "to": 249
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 250,
        "to": 252
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 253,
        "to": 255
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind<F, B>) => (ta: Record<K, A>) => Kind<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 256,
        "to": 258
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: Record<K, A>) => HKT<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 259,
        "to": 261
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <A, B>(f: (k: string, a: A) => HKT<F, B>) => (ta: Record<string, A>) => HKT<F, Record<string, B>> {\n  return RR.traverseWithIndex(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 262,
        "to": 266
      }
    }
  },
  {
    "name": "traverse",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function traverse<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 271,
        "to": 273
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 274,
        "to": 276
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 277,
        "to": 279
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 280,
        "to": 282
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS>(\n  F: Applicative1<F>\n): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: Record<K, A>) => Kind<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 283,
        "to": 285
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: Record<K, A>) => HKT<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 286,
        "to": 288
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => (ta: Record<string, A>) => HKT<F, Record<string, B>> {\n  return RR.traverse(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 289,
        "to": 293
      }
    }
  },
  {
    "name": "sequence",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function sequence<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 298,
        "to": 300
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 301,
        "to": 303
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 304,
        "to": 306
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 307,
        "to": 309
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A>(ta: Record<K, Kind<F, A>>) => Kind<F, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 310,
        "to": 312
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(F: Applicative<F>): <K extends string, A>(ta: Record<K, HKT<F, A>>) => HKT<F, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 313,
        "to": 313
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(F: Applicative<F>): <A>(ta: Record<string, HKT<F, A>>) => HKT<F, Record<string, A>> {\n  return RR.sequence(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 314,
        "to": 316
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partitionMapWithIndex<K extends string, A, B, C>(\n  f: (key: K, a: A) => Either<B, C>\n): (fa: Record<K, A>) => Separated<Record<string, B>, Record<string, C>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Record<string, B>, Record<string, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 333,
        "to": 335
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\nexport function partitionMapWithIndex<A, B, C>(\n  f: (key: string, a: A) => Either<B, C>\n): (fa: Record<string, A>) => Separated<Record<string, B>, Record<string, C>> {\n  return RR.partitionMapWithIndex(f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Record<string, B>, Record<string, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 336,
        "to": 340
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partitionWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Record<string, A>, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 345,
        "to": 347
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Record<string, A>, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 348,
        "to": 350
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: Record<string, A>) => Separated<Record<string, A>, Record<string, A>> {\n  return RR.partitionWithIndex(predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Record<string, A>, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 351,
        "to": 355
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function filterMapWithIndex<K extends string, A, B>(\n  f: (key: K, a: A) => Option<B>\n): (fa: Record<K, A>) => Record<string, B>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 360,
        "to": 362
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\nexport function filterMapWithIndex<A, B>(\n  f: (key: string, a: A) => Option<B>\n): (fa: Record<string, A>) => Record<string, B> {\n  return RR.filterMapWithIndex(f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 363,
        "to": 367
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function filterWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Record<string, B>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 372,
        "to": 374
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Record<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 375,
        "to": 377
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: Record<string, A>) => Record<string, A> {\n  return RR.filterWithIndex(predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 378,
        "to": 382
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a record from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.0.0\n */\nexport function fromFoldable<F extends URIS3, A>(\n  M: Magma<A>,\n  F: Foldable3<F>\n): <K extends string, R, E>(fka: Kind3<F, R, E, [K, A]>) => Record<K, A>",
    "docs": "/**\n * Create a record from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, [K, A]>) => Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 390,
        "to": 393
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, A>(\n  M: Magma<A>,\n  F: Foldable2<F>\n): <K extends string, E>(fka: Kind2<F, E, [K, A]>) => Record<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, [K, A]>) => Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 394,
        "to": 397
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, A>(\n  M: Magma<A>,\n  F: Foldable1<F>\n): <K extends string>(fka: Kind<F, [K, A]>) => Record<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>) => Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 398,
        "to": 401
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(M: Magma<A>, F: Foldable<F>): <K extends string>(fka: HKT<F, [K, A]>) => Record<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>) => Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 402,
        "to": 402
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [string, A]>) => Record<string, A> {\n  return RR.fromFoldable(M, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 403,
        "to": 405
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\n\n/**\n * Create a record from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { getLastSemigroup } from 'fp-ts/lib/Semigroup'\n * import { array, zip } from 'fp-ts/lib/Array'\n * import { identity } from 'fp-ts/lib/function'\n * import { fromFoldableMap } from 'fp-ts/lib/Record'\n *\n * // like lodash `zipObject` or ramda `zipObj`\n * export const zipObject = <K extends string, A>(keys: Array<K>, values: Array<A>): Record<K, A> =>\n *   fromFoldableMap(getLastSemigroup<A>(), array)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * // build a record from a field\n * interface User {\n *   id: string\n *   name: string\n * }\n *\n * const users: Array<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(getLastSemigroup<User>(), array)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.0.0\n */\nexport function fromFoldableMap<F extends URIS3, B>(\n  M: Magma<B>,\n  F: Foldable3<F>\n): <R, E, A, K extends string>(fa: Kind3<F, R, E, A>, f: (a: A) => [K, B]) => Record<K, B>",
    "docs": "/**\n * Create a record from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { getLastSemigroup } from 'fp-ts/lib/Semigroup'\n * import { array, zip } from 'fp-ts/lib/Array'\n * import { identity } from 'fp-ts/lib/function'\n * import { fromFoldableMap } from 'fp-ts/lib/Record'\n *\n * // like lodash `zipObject` or ramda `zipObj`\n * export const zipObject = <K extends string, A>(keys: Array<K>, values: Array<A>): Record<K, A> =>\n *   fromFoldableMap(getLastSemigroup<A>(), array)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * // build a record from a field\n * interface User {\n *   id: string\n *   name: string\n * }\n *\n * const users: Array<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(getLastSemigroup<User>(), array)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>, f: (a: A) => [K, B]) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 444,
        "to": 447
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS2, B>(\n  M: Magma<B>,\n  F: Foldable2<F>\n): <E, A, K extends string>(fa: Kind2<F, E, A>, f: (a: A) => [K, B]) => Record<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>, f: (a: A) => [K, B]) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 448,
        "to": 451
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS, B>(\n  M: Magma<B>,\n  F: Foldable1<F>\n): <A, K extends string>(fa: Kind<F, A>, f: (a: A) => [K, B]) => Record<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => [K, B]) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 452,
        "to": 455
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: Foldable<F>\n): <A, K extends string>(fa: HKT<F, A>, f: (a: A) => [K, B]) => Record<K, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, K extends string>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => [K, B]) => Record<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 456,
        "to": 459
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: Foldable<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B> {\n  return RR.fromFoldableMap(M, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 460,
        "to": 465
      }
    }
  },
  {
    "name": "getFunctionRing",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionRing<A, B>(ring: Ring<B>): Ring<(a: A) => B> {\n  const S = getFunctionSemiring<A, B>(ring)\n  return {\n    add: S.add,\n    mul: S.mul,\n    one: S.one,\n    zero: S.zero,\n    sub: (f, g) => (x) => ring.sub(f(x), g(x))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ring",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ring.ts",
      "lines": {
        "from": 26,
        "to": 35
      }
    }
  },
  {
    "name": "negate",
    "text": "\n\n/**\n * `negate x` can be used as a shorthand for `zero - x`\n *\n * @since 2.0.0\n */\nexport function negate<A>(ring: Ring<A>): (a: A) => A {\n  return (a) => ring.sub(ring.zero, a)\n}",
    "docs": "/**\n * `negate x` can be used as a shorthand for `zero - x`\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ring",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ring.ts",
      "lines": {
        "from": 42,
        "to": 44
      }
    }
  },
  {
    "name": "getTupleRing",
    "text": "\n\n/**\n * Given a tuple of `Ring`s returns a `Ring` for the tuple\n *\n * @example\n * import { getTupleRing } from 'fp-ts/lib/Ring'\n * import { fieldNumber } from 'fp-ts/lib/Field'\n *\n * const R = getTupleRing(fieldNumber, fieldNumber, fieldNumber)\n * assert.deepStrictEqual(R.add([1, 2, 3], [4, 5, 6]), [5, 7, 9])\n * assert.deepStrictEqual(R.mul([1, 2, 3], [4, 5, 6]), [4, 10, 18])\n * assert.deepStrictEqual(R.one, [1, 1, 1])\n * assert.deepStrictEqual(R.sub([1, 2, 3], [4, 5, 6]), [-3, -3, -3])\n * assert.deepStrictEqual(R.zero, [0, 0, 0])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleRing<T extends ReadonlyArray<Ring<any>>>(\n  ...rings: T\n): Ring<{ [K in keyof T]: T[K] extends Ring<infer A> ? A : never }> {\n  return {\n    add: (x: any, y: any) => rings.map((R, i) => R.add(x[i], y[i])),\n    zero: rings.map((R) => R.zero),\n    mul: (x: any, y: any) => rings.map((R, i) => R.mul(x[i], y[i])),\n    one: rings.map((R) => R.one),\n    sub: (x: any, y: any) => rings.map((R, i) => R.sub(x[i], y[i]))\n  } as any\n}",
    "docs": "/**\n * Given a tuple of `Ring`s returns a `Ring` for the tuple\n *\n * @example\n * import { getTupleRing } from 'fp-ts/lib/Ring'\n * import { fieldNumber } from 'fp-ts/lib/Field'\n *\n * const R = getTupleRing(fieldNumber, fieldNumber, fieldNumber)\n * assert.deepStrictEqual(R.add([1, 2, 3], [4, 5, 6]), [5, 7, 9])\n * assert.deepStrictEqual(R.mul([1, 2, 3], [4, 5, 6]), [4, 10, 18])\n * assert.deepStrictEqual(R.one, [1, 1, 1])\n * assert.deepStrictEqual(R.sub([1, 2, 3], [4, 5, 6]), [-3, -3, -3])\n * assert.deepStrictEqual(R.zero, [0, 0, 0])\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "rings",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ring.ts",
      "lines": {
        "from": 63,
        "to": 73
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function fold<A>(S: Semigroup<A>): (a: A, as: ReadonlyArray<A>) => A {\n  return (a, as) => as.reduce(S.concat, a)\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, as: readonly A[]) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 22,
        "to": 24
      }
    }
  },
  {
    "name": "getFirstSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstSemigroup<A = never>(): Semigroup<A> {\n  return { concat: identity }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 30,
        "to": 32
      }
    }
  },
  {
    "name": "getLastSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getLastSemigroup<A = never>(): Semigroup<A> {\n  return { concat: (_, y) => y }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 38,
        "to": 40
      }
    }
  },
  {
    "name": "getTupleSemigroup",
    "text": "\n\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple\n *\n * @example\n * import { getTupleSemigroup, semigroupString, semigroupSum, semigroupAll } from 'fp-ts/lib/Semigroup'\n *\n * const S1 = getTupleSemigroup(semigroupString, semigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = getTupleSemigroup(semigroupString, semigroupSum, semigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleSemigroup<T extends ReadonlyArray<Semigroup<any>>>(\n  ...semigroups: T\n): Semigroup<{ [K in keyof T]: T[K] extends Semigroup<infer A> ? A : never }> {\n  return {\n    concat: (x, y) => semigroups.map((s, i) => s.concat(x[i], y[i])) as any\n  }\n}",
    "docs": "/**\n * Given a tuple of semigroups returns a semigroup for the tuple\n *\n * @example\n * import { getTupleSemigroup, semigroupString, semigroupSum, semigroupAll } from 'fp-ts/lib/Semigroup'\n *\n * const S1 = getTupleSemigroup(semigroupString, semigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = getTupleSemigroup(semigroupString, semigroupSum, semigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "semigroups",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 57,
        "to": 63
      }
    }
  },
  {
    "name": "getDualSemigroup",
    "text": "\n\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualSemigroup, semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * assert.deepStrictEqual(getDualSemigroup(semigroupString).concat('a', 'b'), 'ba')\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getDualSemigroup<A>(S: Semigroup<A>): Semigroup<A> {\n  return {\n    concat: (x, y) => S.concat(y, x)\n  }\n}",
    "docs": "/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualSemigroup, semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * assert.deepStrictEqual(getDualSemigroup(semigroupString).concat('a', 'b'), 'ba')\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 76,
        "to": 80
      }
    }
  },
  {
    "name": "getFunctionSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionSemigroup<S>(S: Semigroup<S>): <A = never>() => Semigroup<(a: A) => S> {\n  return () => ({\n    concat: (f, g) => (a) => S.concat(f(a), g(a))\n  })\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<(a: A) => S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 86,
        "to": 90
      }
    }
  },
  {
    "name": "getStructSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getStructSemigroup<O extends ReadonlyRecord<string, any>>(\n  semigroups: { [K in keyof O]: Semigroup<O[K]> }\n): Semigroup<O> {\n  return {\n    concat: (x, y) => {\n      const r: any = {}\n      for (const key of Object.keys(semigroups)) {\n        r[key] = semigroups[key].concat(x[key], y[key])\n      }\n      return r\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "semigroups",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof O]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<O[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<O>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 96,
        "to": 108
      }
    }
  },
  {
    "name": "getMeetSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMeetSemigroup<A>(O: Ord<A>): Semigroup<A> {\n  return {\n    concat: min(O)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 114,
        "to": 118
      }
    }
  },
  {
    "name": "getJoinSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getJoinSemigroup<A>(O: Ord<A>): Semigroup<A> {\n  return {\n    concat: max(O)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 124,
        "to": 128
      }
    }
  },
  {
    "name": "getObjectSemigroup",
    "text": "\n\n/**\n * Returns a `Semigroup` instance for objects preserving their type\n *\n * @example\n * import { getObjectSemigroup } from 'fp-ts/lib/Semigroup'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const S = getObjectSemigroup<Person>()\n * assert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getObjectSemigroup<A extends object = never>(): Semigroup<A> {\n  return {\n    concat: (x, y) => Object.assign({}, x, y)\n  }\n}",
    "docs": "/**\n * Returns a `Semigroup` instance for objects preserving their type\n *\n * @example\n * import { getObjectSemigroup } from 'fp-ts/lib/Semigroup'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const S = getObjectSemigroup<Person>()\n * assert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 147,
        "to": 151
      }
    }
  },
  {
    "name": "getIntercalateSemigroup",
    "text": "\n\n/**\n * You can glue items between and stay associative\n *\n * @example\n * import { getIntercalateSemigroup, semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * const S = getIntercalateSemigroup(' ')(semigroupString)\n *\n * assert.strictEqual(S.concat('a', 'b'), 'a b')\n * assert.strictEqual(S.concat(S.concat('a', 'b'), 'c'), S.concat('a', S.concat('b', 'c')))\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getIntercalateSemigroup<A>(a: A): (S: Semigroup<A>) => Semigroup<A> {\n  return (S) => ({\n    concat: (x, y) => S.concat(x, S.concat(a, y))\n  })\n}",
    "docs": "/**\n * You can glue items between and stay associative\n *\n * @example\n * import { getIntercalateSemigroup, semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * const S = getIntercalateSemigroup(' ')(semigroupString)\n *\n * assert.strictEqual(S.concat('a', 'b'), 'a b')\n * assert.strictEqual(S.concat(S.concat('a', 'b'), 'c'), S.concat('a', S.concat('b', 'c')))\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 223,
        "to": 227
      }
    }
  },
  {
    "name": "getFunctionSemiring",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionSemiring<A, B>(S: Semiring<B>): Semiring<(a: A) => B> {\n  return {\n    add: (f, g) => (x) => S.add(f(x), g(x)),\n    zero: () => S.zero,\n    mul: (f, g) => (x) => S.mul(f(x), g(x)),\n    one: () => S.one\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semiring\").Semiring<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semiring\").Semiring<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semiring.ts",
      "lines": {
        "from": 40,
        "to": 47
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function filter<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Set<B>",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 75,
        "to": 75
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: Set<A>) => Set<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 76,
        "to": 76
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: Set<A>) => Set<A> {\n  return RS.filter(predicate) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 77,
        "to": 79
      }
    }
  },
  {
    "name": "partition",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partition<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Separated<Set<A>, Set<B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Set<A>, Set<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 84,
        "to": 84
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(predicate: Predicate<A>): (set: Set<A>) => Separated<Set<A>, Set<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Set<A>, Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 85,
        "to": 85
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(predicate: Predicate<A>): (set: Set<A>) => Separated<Set<A>, Set<A>> {\n  return RS.partition(predicate) as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Separated<Set<A>, Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "toggle",
    "text": "\n\n/**\n * Checks an element is a member of a set;\n * If yes, removes the value from the set\n * If no, inserts the value to the set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function toggle<A>(E: Eq<A>): (a: A) => (set: Set<A>) => Set<A> {\n  const elemE = elem(E)\n  const removeE = remove(E)\n  const insertE = insert(E)\n  return (a) => (set) => (elemE(a, set) ? removeE : insertE)(a)(set)\n}",
    "docs": "/**\n * Checks an element is a member of a set;\n * If yes, removes the value from the set\n * If no, inserts the value to the set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 189,
        "to": 194
      }
    }
  },
  {
    "name": "getStructShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getStructShow<O extends ReadonlyRecord<string, any>>(shows: { [K in keyof O]: Show<O[K]> }): Show<O> {\n  return {\n    show: (s) =>\n      `{ ${Object.keys(shows)\n        .map((k) => `${k}: ${shows[k].show(s[k])}`)\n        .join(', ')} }`\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "shows",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof O]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<O[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<O>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Show.ts",
      "lines": {
        "from": 49,
        "to": 56
      }
    }
  },
  {
    "name": "getTupleShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleShow<T extends ReadonlyArray<Show<any>>>(\n  ...shows: T\n): Show<{ [K in keyof T]: T[K] extends Show<infer A> ? A : never }> {\n  return {\n    show: (t) => `[${t.map((a, i) => shows[i].show(a)).join(', ')}]`\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "shows",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<{ [K in keyof T]: T[K] extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<infer A> ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Show.ts",
      "lines": {
        "from": 62,
        "to": 68
      }
    }
  },
  {
    "name": "get",
    "text": "const get: <S>() => State<S, S> = () => (s) => [s, s]",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [S, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 31,
        "to": 31
      }
    }
  },
  {
    "name": "put",
    "text": "const put: <S>(s: S) => State<S, void> = (s) => () => [undefined, s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [any, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 39,
        "to": 39
      }
    }
  },
  {
    "name": "modify",
    "text": "const modify: <S>(f: (s: S) => S) => State<S, void> = (f) => (s) => [undefined, f(s)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [any, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "gets",
    "text": "const gets: <S, A>(f: (s: S) => A) => State<S, A> = (f) => (s) => [f(s), s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [A, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 55,
        "to": 55
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: State<E, A>) => State<E, B> = (f) => (fa) => (s1) => {\n  const [a, s2] = fa(s1)\n  return [f(a), s2]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 68,
        "to": 71
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <E, A>(fa: State<E, A>) => <B>(fab: State<E, (a: A) => B>) => State<E, B> = (fa) => (fab) => (s1) => {\n  const [f, s2] = fab(s1)\n  const [a, s3] = fa(s2)\n  return [f(a), s3]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, (a: A) => B>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 79,
        "to": 83
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <E, B>(fb: State<E, B>) => <A>(fa: State<E, A>): State<E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 91,
        "to": 96
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: State<E, B>) => <A>(fa: State<E, A>): State<E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 104,
        "to": 109
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <S, A>(a: A) => State<S, A> = (a) => (s) => [a, s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [A, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 115,
        "to": 115
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <E, A, B>(f: (a: A) => State<E, B>) => (ma: State<E, A>) => State<E, B> = (f) => (ma) => (s1) => {\n  const [a, s2] = ma(s1)\n  return f(a)(s2)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 123,
        "to": 126
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => State<E, B>) => (ma: State<E, A>) => State<E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 135,
        "to": 141
      }
    }
  },
  {
    "name": "evalState",
    "text": "const evalState: <S, A>(ma: State<S, A>, s: S) => A = (ma, s) => ma(s)[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 201,
        "to": 201
      }
    }
  },
  {
    "name": "execState",
    "text": "const execState: <S, A>(ma: State<S, A>, s: S) => S = (ma, s) => ma(s)[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 208,
        "to": 208
      }
    }
  },
  {
    "name": "left",
    "text": "\n/* tslint:enable:readonly-array */\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function left<S, R, E = never, A = never>(e: E): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.left(e))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 45,
        "to": 47
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightTask<S, R, E = never, A = never>(ma: Task<A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightTask(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftTask<S, R, E = never, A = never>(me: Task<E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftTask(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 68,
        "to": 70
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromTaskEither<S, R, E, A>(ma: TaskEither<E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromTaskEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 76,
        "to": 78
      }
    }
  },
  {
    "name": "rightReader",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightReader<S, R, E = never, A = never>(ma: Reader<R, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightReader(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 84,
        "to": 86
      }
    }
  },
  {
    "name": "leftReader",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftReader<S, R, E = never, A = never>(me: Reader<R, E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftReader(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromIOEither<S, R, E, A>(ma: IOEither<E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromIOEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 100,
        "to": 102
      }
    }
  },
  {
    "name": "fromReaderEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromReaderEither<S, R, E, A>(ma: ReaderEither<R, E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromReaderEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 108,
        "to": 110
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightIO<S, R, E = never, A = never>(ma: IO<A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightIO(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftIO<S, R, E = never, A = never>(me: IO<E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftIO(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 124,
        "to": 126
      }
    }
  },
  {
    "name": "leftState",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftState<S, R, E = never, A = never>(me: State<S, E>): StateReaderTaskEither<S, R, E, A> {\n  return (s) => RTE.left(me(s)[0])\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 140,
        "to": 142
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): <S, R>(...a: A) => StateReaderTaskEither<S, R, E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 226,
        "to": 230
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromIOEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): <S, R>(...a: A) => StateReaderTaskEither<S, R, E, B> {\n  return (...a) => fromIOEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 254,
        "to": 258
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromTaskEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n): <S, R>(...a: A) => StateReaderTaskEither<S, R, E, B> {\n  return (...a) => fromTaskEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 282,
        "to": 286
      }
    }
  },
  {
    "name": "fromReaderTaskEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromReaderTaskEitherK<R, E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => ReaderTaskEither<R, E, B>\n): <S>(...a: A) => StateReaderTaskEither<S, R, E, B> {\n  return (...a) => fromReaderTaskEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 310,
        "to": 314
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/* tslint:disable:readonly-array */\n/**\n * @since 2.0.0\n */\nexport function run<S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S, r: R): Promise<Either<E, [A, S]>> {\n  return ma(s)(r)()\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, [A, S]>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 610,
        "to": 612
      }
    }
  },
  {
    "name": "right",
    "text": "const right: <S, R, E = never, A = never>(a: A) => StateReaderTaskEither<S, R, E, A> = (a) => (s) =>\n  RTE.right([a, s])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 53,
        "to": 54
      }
    }
  },
  {
    "name": "rightState",
    "text": "const rightState: <S, R, E = never, A = never>(ma: State<S, A>) => StateReaderTaskEither<S, R, E, A> = (sa) => (\n  s\n) => RTE.right(sa(s))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "sa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 132,
        "to": 134
      }
    }
  },
  {
    "name": "fromReaderTaskEither",
    "text": "const fromReaderTaskEither: <S, R, E, A>(ma: ReaderTaskEither<R, E, A>) => StateReaderTaskEither<S, R, E, A> = (\n  fa\n) => (s) =>\n  pipe(\n    fa,\n    RTE.map((a) => [a, s])\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 148,
        "to": 154
      }
    }
  },
  {
    "name": "get",
    "text": "const get: <S, R, E = never>() => StateReaderTaskEither<S, R, E, S> = () => (s) => RTE.right([s, s])",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [S, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 162,
        "to": 162
      }
    }
  },
  {
    "name": "put",
    "text": "const put: <S, R, E = never>(s: S) => StateReaderTaskEither<S, R, E, void> = (s) => () =>\n  RTE.right([undefined, s])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [any, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 170,
        "to": 171
      }
    }
  },
  {
    "name": "modify",
    "text": "const modify: <S, R, E = never>(f: (s: S) => S) => StateReaderTaskEither<S, R, E, void> = (f) => (s) =>\n  RTE.right([undefined, f(s)])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [any, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 179,
        "to": 180
      }
    }
  },
  {
    "name": "gets",
    "text": "const gets: <S, R, E = never, A = never>(f: (s: S) => A) => StateReaderTaskEither<S, R, E, A> = (f) => (s) =>\n  RTE.right([f(s), s])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 188,
        "to": 189
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <S, R, E, A>(ma: Either<E, A>) => StateReaderTaskEither<S, R, E, A> = (ma) =>\n  ma._tag === 'Left' ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 195,
        "to": 196
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <S, R, A>(ma: Option<A>) => StateReaderTaskEither<S, R, E, A> = (\n  onNone\n) => (ma) => (ma._tag === 'None' ? left(onNone()) : right(ma.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 202,
        "to": 204
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(\n    a: A\n  ) => StateReaderTaskEither<S, R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => StateReaderTaskEither<S, R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <S, R>(a: A): StateReaderTaskEither<S, R, E, A> =>\n  predicate(a) ? right(a) : left(onFalse(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 210,
        "to": 216
      }
    }
  },
  {
    "name": "chainEitherKW",
    "text": "const chainEitherKW = <E, A, B>(f: (a: A) => Either<E, B>) => <S, R, D>(\n  ma: StateReaderTaskEither<S, R, D, A>\n): StateReaderTaskEither<S, R, D | E, B> => pipe(ma, chainW<S, R, E, A, B>(fromEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 238,
        "to": 240
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW = <E, A, B>(f: (a: A) => IOEither<E, B>) => <S, R, D>(\n  ma: StateReaderTaskEither<S, R, D, A>\n): StateReaderTaskEither<S, R, D | E, B> => pipe(ma, chainW<S, R, E, A, B>(fromIOEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 266,
        "to": 268
      }
    }
  },
  {
    "name": "chainTaskEitherKW",
    "text": "const chainTaskEitherKW = <E, A, B>(f: (a: A) => TaskEither<E, B>) => <S, R, D>(\n  ma: StateReaderTaskEither<S, R, D, A>\n): StateReaderTaskEither<S, R, D | E, B> => pipe(ma, chainW<S, R, E, A, B>(fromTaskEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 294,
        "to": 296
      }
    }
  },
  {
    "name": "chainReaderTaskEitherKW",
    "text": "const chainReaderTaskEitherKW = <R, E, A, B>(f: (a: A) => ReaderTaskEither<R, E, B>) => <S, D>(\n  ma: StateReaderTaskEither<S, R, D, A>\n): StateReaderTaskEither<S, R, D | E, B> => pipe(ma, chainW<S, R, E, A, B>(fromReaderTaskEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 322,
        "to": 324
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(\n    ma: StateReaderTaskEither<S, R, E, A>\n  ) => StateReaderTaskEither<S, R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(\n    ma: StateReaderTaskEither<S, R, E, A>\n  ) => StateReaderTaskEither<S, R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <S, R>(\n  ma: StateReaderTaskEither<S, R, E, A>\n): StateReaderTaskEither<S, R, E, A> =>\n  pipe(\n    ma,\n    chain((a) => (predicate(a) ? right(a) : left(onFalse(a))))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 338,
        "to": 351
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(\n  f: (a: A) => B\n) => <S, R, E>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B> = (f) => (fa) => (s1) =>\n  pipe(\n    fa(s1),\n    RTE.map(([a, s2]) => [f(a), s2])\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => (s1: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [B, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 361,
        "to": 367
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <S, R>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, B> = (f, g) => (fa) =>\n  bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 375,
        "to": 379
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(\n  f: (e: E) => G\n) => <S, R, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, A> = (f) => (fa) =>\n  mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 387,
        "to": 390
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <S, R, E, A>(\n  fa: StateReaderTaskEither<S, R, E, A>\n) => <B>(fab: StateReaderTaskEither<S, R, E, (a: A) => B>) => StateReaderTaskEither<S, R, E, B> = (fa) => (fab) => (\n  s1\n) =>\n  pipe(\n    fab(s1),\n    RTE.chain(([f, s2]) =>\n      pipe(\n        fa(s2),\n        RTE.map(([a, s3]) => [f(a), s3])\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, (a: A) => B>) => (s1: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [B, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 398,
        "to": 411
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <S, R, E, B>(fb: StateReaderTaskEither<S, R, E, B>) => <A>(\n  fa: StateReaderTaskEither<S, R, E, A>\n): StateReaderTaskEither<S, R, E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 419,
        "to": 426
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <S, R, E, B>(fb: StateReaderTaskEither<S, R, E, B>) => <A>(\n  fa: StateReaderTaskEither<S, R, E, A>\n): StateReaderTaskEither<S, R, E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 434,
        "to": 441
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW: <S, R, E, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R, E, B>\n) => <Q, D>(ma: StateReaderTaskEither<S, Q, D, A>) => StateReaderTaskEither<S, Q & R, D | E, B> = (f) => (ma) => (s1) =>\n  pipe(\n    ma(s1),\n    RTE.chainW(([a, s2]) => f(a)(s2))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<Q, D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, Q, D, A>) => (s1: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<Q & R, E | D, [B, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 449,
        "to": 455
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <S, R, E, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R, E, B>\n) => (ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 474,
        "to": 482
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <S, R, E, A>(\n  that: () => StateReaderTaskEither<S, R, E, A>\n) => (fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A> = (that) => (fa) => (s) =>\n  pipe(\n    fa(s),\n    RTE.alt(() => that()(s))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 501,
        "to": 507
      }
    }
  },
  {
    "name": "evalState",
    "text": "const evalState: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, A> = (\n  fsa,\n  s\n) =>\n  pipe(\n    fsa(s),\n    RTE.map(([a]) => a)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fsa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 620,
        "to": 627
      }
    }
  },
  {
    "name": "execState",
    "text": "const execState: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, S> = (\n  fsa,\n  s\n) =>\n  pipe(\n    fsa(s),\n    RTE.map(([_, s]) => s)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fsa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 634,
        "to": 641
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getStateM<M extends URIS3>(M: Monad3<M>): StateM3<M>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M extends URIS3, E>(M: Monad3C<M, E>): StateM3C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM3C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 168,
        "to": 168
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M extends URIS2>(M: Monad2<M>): StateM2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 169,
        "to": 169
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M extends URIS2, E>(M: Monad2C<M, E>): StateM2C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 170,
        "to": 170
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M extends URIS>(M: Monad1<M>): StateM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 171,
        "to": 171
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M>(M: Monad<M>): StateM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 172,
        "to": 172
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\nexport function getStateM<M>(M: Monad<M>): StateM<M> {\n  return {\n    map: (fa, f) => (s) => M.map(fa(s), ([a, s1]) => [f(a), s1]),\n    of: (a) => (s) => M.of([a, s]),\n    ap: (fab, fa) => (s) => M.chain(fab(s), ([f, s]) => M.map(fa(s), ([a, s]) => [f(a), s])),\n    chain: (fa, f) => (s) => M.chain(fa(s), ([a, s1]) => f(a)(s1)),\n    get: () => (s) => M.of([s, s]),\n    put: (s) => () => M.of([undefined, s]),\n    modify: (f) => (s) => M.of([undefined, f(s)]),\n    gets: (f) => (s) => M.of([f(s), s]),\n    fromState: (sa) => (s) => M.of(sa(s)),\n    fromM: (ma) => (s) => M.map(ma, (a) => [a, s]),\n    evalState: (ma, s) => M.map(ma(s), ([a]) => a),\n    execState: (ma, s) => M.map(ma(s), ([_, s]) => s)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 173,
        "to": 188
      }
    }
  },
  {
    "name": "seek",
    "text": "\n\n/**\n * Reposition the focus at the specified position\n *\n * @since 2.0.0\n */\nexport function seek<S>(s: S): <A>(wa: Store<S, A>) => Store<S, A> {\n  return (wa) => ({ peek: wa.peek, pos: s })\n}",
    "docs": "/**\n * Reposition the focus at the specified position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 27,
        "to": 29
      }
    }
  },
  {
    "name": "seeks",
    "text": "\n\n/**\n * Reposition the focus at the specified position, which depends on the current position\n *\n * @since 2.0.0\n */\nexport function seeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => Store<S, A> {\n  return (wa) => ({ peek: wa.peek, pos: f(wa.pos) })\n}",
    "docs": "/**\n * Reposition the focus at the specified position, which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 36,
        "to": 38
      }
    }
  },
  {
    "name": "peeks",
    "text": "\n\n/**\n * Extract a value from a position which depends on the current position\n *\n * @since 2.0.0\n */\nexport function peeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => A {\n  return (wa) => wa.peek(f(wa.pos))\n}",
    "docs": "/**\n * Extract a value from a position which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 45,
        "to": 47
      }
    }
  },
  {
    "name": "experiment",
    "text": "\n\n/**\n * Extract a collection of values from positions which depend on the current position\n *\n * @since 2.0.0\n */\nexport function experiment<F extends URIS3>(\n  F: Functor3<F>\n): <R, E, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>",
    "docs": "/**\n * Extract a collection of values from positions which depend on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 54,
        "to": 56
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <R, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 57,
        "to": 59
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS2>(\n  F: Functor2<F>\n): <E, S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 63,
        "to": 65
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS>(\n  F: Functor1<F>\n): <S>(f: (s: S) => Kind<F, S>) => <A>(wa: Store<S, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F>(F: Functor<F>): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 69,
        "to": 69
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F>(F: Functor<F>): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A> {\n  return (f) => (wa) => F.map(f(wa.pos), (s) => wa.peek(s))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 70,
        "to": 72
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <E, A>(wa: Store<E, A>) => Store<E, Store<E, A>> = (wa) => extend_(wa, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: <E, A>(wa: Store<E, A>) => A = (wa) => wa.peek(wa.pos)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 98,
        "to": 98
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: Store<E, A>) => B) => (wa: Store<E, A>) => Store<E, B> = (f) => (wa) =>\n  extend_(wa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 104,
        "to": 105
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Store<E, A>) => Store<E, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 114,
        "to": 114
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\n\n/**\n * Compose a value acting on a tuple from two values, each acting on one of the components of the tuple.\n *\n * Specializing `(***)` to function application would look like this:\n *\n * ```purescript\n * (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which takes a tuple and maps `f`\n * over the first element and `g` over the second.  Just like `bi-map` would do for the `bi-functor` instance of tuple.\n *\n * @since 2.0.0\n */\nexport function splitStrong<F extends URIS4>(\n  F: Category4<F> & Strong4<F>\n): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>",
    "docs": "/**\n * Compose a value acting on a tuple from two values, each acting on one of the components of the tuple.\n *\n * Specializing `(***)` to function application would look like this:\n *\n * ```purescript\n * (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which takes a tuple and maps `f`\n * over the first element and `g` over the second.  Just like `bi-map` would do for the `bi-functor` instance of tuple.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\nexport function splitStrong<F extends URIS3>(\n  F: Category3<F> & Strong3<F>\n): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 90,
        "to": 92
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\nexport function splitStrong<F extends URIS2>(\n  F: Category2<F> & Strong2<F>\n): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\nexport function splitStrong<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 96,
        "to": 98
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\nexport function splitStrong<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]> {\n  return (pab, pcd) => F.compose(F.first(pab), F.second(pcd))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 99,
        "to": 103
      }
    }
  },
  {
    "name": "fanout",
    "text": "\n\n/**\n * Compose a value which introduces a tuple from two values, each introducing one side of the tuple.\n *\n * This combinator is useful when assembling values from smaller components, because it provides a way to support two\n * different types of output.\n *\n * Specializing `(&&&)` to function application would look like this:\n *\n * ```purescript\n * (&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n * ```\n *\n * We take two functions, `f` and `g`, with the same parameter type and we transform them into a single function which\n * takes one parameter and returns a tuple of the results of running `f` and `g` on the parameter, respectively.  This\n * allows us to run two parallel computations on the same input and return both results in a tuple.\n *\n * @since 2.0.0\n */\nexport function fanout<F extends URIS4>(\n  F: Category4<F> & Strong4<F>\n): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>",
    "docs": "/**\n * Compose a value which introduces a tuple from two values, each introducing one side of the tuple.\n *\n * This combinator is useful when assembling values from smaller components, because it provides a way to support two\n * different types of output.\n *\n * Specializing `(&&&)` to function application would look like this:\n *\n * ```purescript\n * (&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n * ```\n *\n * We take two functions, `f` and `g`, with the same parameter type and we transform them into a single function which\n * takes one parameter and returns a tuple of the results of running `f` and `g` on the parameter, respectively.  This\n * allows us to run two parallel computations on the same input and return both results in a tuple.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 123,
        "to": 125
      }
    }
  },
  {
    "name": "fanout",
    "text": "\nexport function fanout<F extends URIS3>(\n  F: Category3<F> & Strong3<F>\n): <R, A, B, C>(pab: Kind3<F, R, A, B>, pac: Kind3<F, R, A, C>) => Kind3<F, R, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 126,
        "to": 128
      }
    }
  },
  {
    "name": "fanout",
    "text": "\nexport function fanout<F extends URIS2>(\n  F: Category2<F> & Strong2<F>\n): <A, B, C>(pab: Kind2<F, A, B>, pac: Kind2<F, A, C>) => Kind2<F, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 129,
        "to": 131
      }
    }
  },
  {
    "name": "fanout",
    "text": "\nexport function fanout<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 132,
        "to": 134
      }
    }
  },
  {
    "name": "fanout",
    "text": "\nexport function fanout<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]> {\n  const splitStrongF = splitStrong(F)\n  return <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>): HKT2<F, A, [B, C]> => {\n    const split: HKT2<F, A, [A, A]> = F.promap(F.id<A>(), identity, (a) => [a, a])\n    return F.compose(splitStrongF(pab, pac), split)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 135,
        "to": 143
      }
    }
  },
  {
    "name": "delay",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/lib/Apply'\n * import * as T from 'fp-ts/lib/Task'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = append('b')\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.task)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(log, ['a', 'b', 'd', 'c'])\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function delay(millis: number): <A>(ma: Task<A>) => Task<A> {\n  return (ma) => () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        // tslint:disable-next-line: no-floating-promises\n        ma().then(resolve)\n      }, millis)\n    })\n}",
    "docs": "/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/lib/Apply'\n * import * as T from 'fp-ts/lib/Task'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = append('b')\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.task)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(log, ['a', 'b', 'd', 'c'])\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "millis",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 73,
        "to": 81
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromIOK<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>): (...a: A) => Task<B> {\n  return (...a) => fromIO(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function chainIOK<A, B>(f: (a: A) => IO<B>): (ma: Task<A>) => Task<B> {\n  return chain(fromIOK(f))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Lift a semigroup into 'Task', the inner values are concatenated using the provided `Semigroup`.\n *\n * @example\n * import * as T from 'fp-ts/lib/Task'\n * import { semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * async function test() {\n *   const S = T.getSemigroup(semigroupString)\n *   const fa = T.of('a')\n *   const fb = T.of('b')\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'ab')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<A>(S: Semigroup<A>): Semigroup<Task<A>> {\n  return {\n    concat: (x, y) => () => x().then((rx) => y().then((ry) => S.concat(rx, ry)))\n  }\n}",
    "docs": "/**\n * Lift a semigroup into 'Task', the inner values are concatenated using the provided `Semigroup`.\n *\n * @example\n * import * as T from 'fp-ts/lib/Task'\n * import { semigroupString } from 'fp-ts/lib/Semigroup'\n *\n * async function test() {\n *   const S = T.getSemigroup(semigroupString)\n *   const fa = T.of('a')\n *   const fb = T.of('b')\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'ab')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 240,
        "to": 244
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<A>(M: Monoid<A>): Monoid<Task<A>> {\n  return {\n    concat: getSemigroup(M).concat,\n    empty: of(M.empty)\n  }\n}",
    "docs": "/**\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 252,
        "to": 257
      }
    }
  },
  {
    "name": "getRaceMonoid",
    "text": "\n\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/lib/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid<A = never>(): Monoid<Task<A>> {\n  return {\n    concat: (x, y) => () => Promise.race([x(), y()]),\n    empty: never\n  }\n}",
    "docs": "/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/lib/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 279,
        "to": 284
      }
    }
  },
  {
    "name": "fromIO",
    "text": "const fromIO: <A>(ma: IO<A>) => Task<A> = (ma) => () => Promise.resolve(ma())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 41,
        "to": 41
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Task<A>) => Task<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 115,
        "to": 115
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>) => Task<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 123,
        "to": 123
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: Task<B>) => <A>(fa: Task<A>) => Task<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 131,
        "to": 135
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond: <B>(fb: Task<B>) => <A>(fa: Task<A>) => Task<B> = (fb) => (fa) =>\n  ap_(\n    map_(fa, () => (b) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 143,
        "to": 147
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <A>(a: A) => Task<A> = (a) => () => Promise.resolve(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 153,
        "to": 153
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Task<B>) => (ma: Task<A>) => Task<B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 161,
        "to": 161
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => Task<B>) => (ma: Task<A>) => Task<A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 170,
        "to": 171
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: Task<Task<A>>) => Task<A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 177,
        "to": 177
      }
    }
  },
  {
    "name": "never",
    "text": "const never: Task<never> = () => new Promise((_) => undefined)",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 325,
        "to": 325
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * Note: `f` should never `throw` errors, they are not caught.\n *\n * @example\n * import { left, right } from 'fp-ts/lib/Either'\n * import { tryCatch } from 'fp-ts/lib/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch<E, A>(f: Lazy<Promise<A>>, onRejected: (reason: unknown) => E): TaskEither<E, A> {\n  return () => f().then(E.right, (reason) => E.left(onRejected(reason)))\n}",
    "docs": "/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * Note: `f` should never `throw` errors, they are not caught.\n *\n * @example\n * import { left, right } from 'fp-ts/lib/Either'\n * import { tryCatch } from 'fp-ts/lib/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<Promise<A>>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 133,
        "to": 135
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "\n\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function tryCatchK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Promise<B>,\n  onRejected: (reason: unknown) => E\n): (...a: A) => TaskEither<E, B> {\n  return (...a) => tryCatch(() => f(...a), onRejected)\n}",
    "docs": "/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => Promise<B>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 223,
        "to": 228
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n): (...a: A) => TaskEither<E, B> {\n  return (...a) => fromEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 234,
        "to": 238
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromIOEitherK<E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): (...a: A) => TaskEither<E, B> {\n  return (...a) => fromIOEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 244,
        "to": 248
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(S: Semigroup<A>): Semigroup<TaskEither<E, A>> {\n  return T.getSemigroup(E.getSemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 511,
        "to": 513
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup<E, A>(S: Semigroup<A>): Semigroup<TaskEither<E, A>> {\n  return T.getSemigroup(E.getApplySemigroup<E, A>(S))\n}",
    "docs": "/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 522,
        "to": 524
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid<E, A>(M: Monoid<A>): Monoid<TaskEither<E, A>> {\n  return {\n    concat: getApplySemigroup<E, A>(M).concat,\n    empty: right(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 530,
        "to": 535
      }
    }
  },
  {
    "name": "getTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getTaskValidation<E>(\n  S: Semigroup<E>\n): Monad2C<URI, E> & Bifunctor2<URI> & Alt2C<URI, E> & MonadTask2C<URI, E> & MonadThrow2C<URI, E> {\n  const V = getValidationM(S, T.monadTask)\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: V.ap,\n    of,\n    chain: chain_,\n    bimap: bimap_,\n    mapLeft: mapLeft_,\n    alt: V.alt,\n    fromIO: fromIO_,\n    fromTask: fromTask_,\n    throwError: throwError_\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"TaskEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 541,
        "to": 559
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.1.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E> {\n  const W = E.getWitherable(M)\n  const F = getFilterableComposition(T.monadTask, W)\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    compact: F.compact,\n    separate: F.separate,\n    filter: F.filter,\n    filterMap: F.filterMap,\n    partition: F.partition,\n    partitionMap: F.partitionMap\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 565,
        "to": 580
      }
    }
  },
  {
    "name": "taskify",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Convert a node style callback function to one returning a `TaskEither`\n *\n * **Note**. If the function `f` admits multiple overloadings, `taskify` will pick last one. If you want a different\n * behaviour, add an explicit type annotation\n *\n * ```ts\n * // readFile admits multiple overloadings\n *\n * // const readFile: (a: string) => TaskEither<NodeJS.ErrnoException, Buffer>\n * const readFile = taskify(fs.readFile)\n *\n * const readFile2: (filename: string, encoding: string) => TaskEither<NodeJS.ErrnoException, Buffer> = taskify(\n *   fs.readFile\n * )\n * ```\n *\n * @example\n * import { taskify } from 'fp-ts/lib/TaskEither'\n * import * as fs from 'fs'\n *\n * // const stat: (a: string | Buffer) => TaskEither<NodeJS.ErrnoException, fs.Stats>\n * const stat = taskify(fs.stat)\n * assert.strictEqual(stat.length, 0)\n *\n * @since 2.0.0\n */\nexport function taskify<L, R>(f: (cb: (e: L | null | undefined, r?: R) => void) => void): () => TaskEither<L, R>",
    "docs": "/**\n * Convert a node style callback function to one returning a `TaskEither`\n *\n * **Note**. If the function `f` admits multiple overloadings, `taskify` will pick last one. If you want a different\n * behaviour, add an explicit type annotation\n *\n * ```ts\n * // readFile admits multiple overloadings\n *\n * // const readFile: (a: string) => TaskEither<NodeJS.ErrnoException, Buffer>\n * const readFile = taskify(fs.readFile)\n *\n * const readFile2: (filename: string, encoding: string) => TaskEither<NodeJS.ErrnoException, Buffer> = taskify(\n *   fs.readFile\n * )\n * ```\n *\n * @example\n * import { taskify } from 'fp-ts/lib/TaskEither'\n * import * as fs from 'fs'\n *\n * // const stat: (a: string | Buffer) => TaskEither<NodeJS.ErrnoException, fs.Stats>\n * const stat = taskify(fs.stat)\n * assert.strictEqual(stat.length, 0)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 651,
        "to": 651
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, L, R>(\n  f: (a: A, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 652,
        "to": 654
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, L, R>(\n  f: (a: A, b: B, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 655,
        "to": 657
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, L, R>(\n  f: (a: A, b: B, c: C, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 658,
        "to": 660
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, D, L, R>(\n  f: (a: A, b: B, c: C, d: D, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C, d: D) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 661,
        "to": 663
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, D, E, L, R>(\n  f: (a: A, b: B, c: C, d: D, e: E, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D, e: E) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D, e: E, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C, d: D, e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 664,
        "to": 666
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<L, R>(f: Function): () => TaskEither<L, R> {\n  return function () {\n    const args = Array.prototype.slice.call(arguments)\n    return () =>\n      new Promise((resolve) => {\n        const cbResolver = (e: L, r: R) => (e != null ? resolve(E.left(e)) : resolve(E.right(r)))\n        f.apply(null, args.concat(cbResolver))\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 667,
        "to": 676
      }
    }
  },
  {
    "name": "rightIO",
    "text": "const rightIO = <E = never, A = never>(ma: IO<A>): TaskEither<E, A> => rightTask(T.fromIO(ma))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 61,
        "to": 61
      }
    }
  },
  {
    "name": "leftIO",
    "text": "const leftIO = <E = never, A = never>(me: IO<E>): TaskEither<E, A> => leftTask(T.fromIO(me))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 67,
        "to": 67
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <E, A>(ma: E.Either<E, A>) => TaskEither<E, A> = (ma) =>\n  E.isLeft(ma) ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 95,
        "to": 96
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <A>(ma: Option<A>) => TaskEither<E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 102,
        "to": 103
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => TaskEither<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<never, A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 109,
        "to": 112
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <E, B>(onLeft: (e: E) => Task<B>) => <A>(ma: TaskEither<E, A>): Task<A | B> =>\n  pipe(ma, T.chain(E.fold<E, A, T.Task<A | B>>(onLeft, T.of)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 158,
        "to": 159
      }
    }
  },
  {
    "name": "orElse",
    "text": "const orElse: <E, A, M>(onLeft: (e: E) => TaskEither<M, A>) => (ma: TaskEither<E, A>) => TaskEither<M, A> = (\n  f\n) => T.chain(E.fold(f, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<M, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 192,
        "to": 194
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: TaskEither<E, A>) => TaskEither<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (ma: TaskEither<E, A>) =>\n  pipe(\n    ma,\n    chain((a) => (predicate(a) ? right(a) : left(onFalse(a))))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 208,
        "to": 215
      }
    }
  },
  {
    "name": "chainEitherKW",
    "text": "const chainEitherKW: <E, A, B>(\n  f: (a: A) => Either<E, B>\n) => <D>(ma: TaskEither<D, A>) => TaskEither<D | E, B> = (f) => chainW(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 256,
        "to": 258
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW: <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n) => <D>(ma: TaskEither<D, A>) => TaskEither<D | E, B> = (f) => chainW(fromIOEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 274,
        "to": 276
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: TaskEither<E, A>) => TaskEither<E, B> = (f) => T.map(E.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 297,
        "to": 297
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: TaskEither<E, A>) => TaskEither<G, A> = (f) =>\n  T.map(E.mapLeft(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 315,
        "to": 316
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <E, B>(fb: TaskEither<E, B>) => <A>(fa: TaskEither<E, A>) => TaskEither<E, A> = (fb) => (fa) =>\n  pipe(\n    fa,\n    map((a) => () => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 334,
        "to": 339
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: TaskEither<E, B>) => <A>(fa: TaskEither<E, A>): TaskEither<E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 347,
        "to": 352
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW = <E, A, B>(f: (a: A) => TaskEither<E, B>) => <D>(ma: TaskEither<D, A>): TaskEither<D | E, B> =>\n  pipe(ma, T.chain(E.fold<D, A, TaskEither<D | E, B>>(left, f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<D>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<D, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E | D, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 360,
        "to": 361
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (ma: TaskEither<E, A>) => TaskEither<E, A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 378,
        "to": 384
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <E, A>(that: () => TaskEither<E, A>) => (fa: TaskEither<E, A>) => TaskEither<E, A> = (that) =>\n  T.chain(E.fold(that, right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 436,
        "to": 437
      }
    }
  },
  {
    "name": "bracket",
    "text": "const bracket = <E, A, B>(\n  acquire: TaskEither<E, A>,\n  use: (a: A) => TaskEither<E, B>,\n  release: (a: A, e: Either<E, B>) => TaskEither<E, void>\n): TaskEither<E, B> =>\n  pipe(\n    acquire,\n    chain((a) =>\n      pipe(\n        pipe(use(a), T.map(E.right)),\n        chain((e) =>\n          pipe(\n            release(a, e),\n            chain(() => (E.isLeft(e) ? left(e.left) : of(e.right)))\n          )\n        )\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "acquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 448,
        "to": 466
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.4.0\n */\nexport function getSemigroup<E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<TaskThese<E, A>> {\n  return T.getSemigroup(TH.getSemigroup<E, A>(SE, SA))\n}",
    "docs": "/**\n * @category instances\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskThese\").TaskThese<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 194,
        "to": 196
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.4.0\n */\nexport function getMonad<E>(S: Semigroup<E>): Monad2C<URI, E> & MonadTask2C<URI, E> {\n  const ap = apComposition(T.applyTask, TH.getMonad(S))\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of: right,\n    chain: (ma, f) =>\n      pipe(\n        ma,\n        T.chain(\n          TH.fold(left, f, (e1, a) =>\n            pipe(\n              f(a),\n              T.map(\n                TH.fold(\n                  (e2) => TH.left(S.concat(e1, e2)),\n                  TH.right,\n                  (e2, b) => TH.both(S.concat(e1, e2), b)\n                )\n              )\n            )\n          )\n        )\n      ),\n    fromIO: rightIO,\n    fromTask: rightTask\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"TaskThese\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask2C<\"TaskThese\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 202,
        "to": 231
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: TaskThese<E, A>) => TaskThese<E, B> = (f) => T.map(TH.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 142,
        "to": 142
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: TaskThese<E, A>) => TaskThese<G, B> = (f, g) =>\n  T.map(TH.bimap(f, g))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 150,
        "to": 151
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: TaskThese<E, A>) => TaskThese<G, A> = (f) =>\n  T.map(TH.mapLeft(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 159,
        "to": 160
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function left<E = never, A = never>(left: E): These<E, A> {\n  return { _tag: 'Left', left }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function right<E = never, A = never>(right: A): These<E, A> {\n  return { _tag: 'Right', right }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 69,
        "to": 71
      }
    }
  },
  {
    "name": "both",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function both<E, A>(left: E, right: A): These<E, A> {\n  return { _tag: 'Both', left, right }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 77,
        "to": 79
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * @category destructors\n * @since 2.0.0\n */\nexport function fold<E, A, B>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n): (fa: These<E, A>) => B {\n  return (fa) => {\n    switch (fa._tag) {\n      case 'Left':\n        return onLeft(fa.left)\n      case 'Right':\n        return onRight(fa.right)\n      case 'Both':\n        return onBoth(fa.left, fa.right)\n    }\n  }\n}",
    "docs": "/**\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        },
        {
          "name": "onRight",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "onBoth",
          "type": {
            "__tag": "Other",
            "values": "(e: E, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 85,
        "to": 100
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(SE: Show<E>, SA: Show<A>): Show<These<E, A>> {\n  return {\n    show: fold(\n      (l) => `left(${SE.show(l)})`,\n      (a) => `right(${SA.show(a)})`,\n      (l, a) => `both(${SE.show(l)}, ${SA.show(a)})`\n    )\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 112,
        "to": 120
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<E, A>(EE: Eq<E>, EA: Eq<A>): Eq<These<E, A>> {\n  return fromEquals((x, y) =>\n    isLeft(x)\n      ? isLeft(y) && EE.equals(x.left, y.left)\n      : isRight(x)\n      ? isRight(y) && EA.equals(x.right, y.right)\n      : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right)\n  )\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 126,
        "to": 134
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<These<E, A>> {\n  return {\n    concat: (x, y) =>\n      isLeft(x)\n        ? isLeft(y)\n          ? left(SE.concat(x.left, y.left))\n          : isRight(y)\n          ? both(x.left, y.right)\n          : both(SE.concat(x.left, y.left), y.right)\n        : isRight(x)\n        ? isLeft(y)\n          ? both(y.left, x.right)\n          : isRight(y)\n          ? right(SA.concat(x.right, y.right))\n          : both(y.left, SA.concat(x.right, y.right))\n        : isLeft(y)\n        ? both(SE.concat(x.left, y.left), x.right)\n        : isRight(y)\n        ? both(x.left, SA.concat(x.right, y.right))\n        : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 140,
        "to": 161
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonad<E>(S: Semigroup<E>): Monad2C<URI, E> & MonadThrow2C<URI, E> {\n  const chain = <A, B>(ma: These<E, A>, f: (a: A) => These<E, B>): These<E, B> => {\n    if (isLeft(ma)) {\n      return ma\n    }\n    if (isRight(ma)) {\n      return f(ma.right)\n    }\n    const fb = f(ma.right)\n    return isLeft(fb)\n      ? left(S.concat(ma.left, fb.left))\n      : isRight(fb)\n      ? both(ma.left, fb.right)\n      : both(S.concat(ma.left, fb.left), fb.right)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    of: right,\n    ap: (mab, ma) => chain(mab, (f) => map_(ma, f)),\n    chain,\n    throwError: left\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"These\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"These\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 167,
        "to": 192
      }
    }
  },
  {
    "name": "toTuple",
    "text": "\n\n/* tslint:disable:readonly-array */\n/**\n * @example\n * import { toTuple, left, right, both } from 'fp-ts/lib/These'\n *\n * assert.deepStrictEqual(toTuple('a', 1)(left('b')), ['b', 1])\n * assert.deepStrictEqual(toTuple('a', 1)(right(2)), ['a', 2])\n * assert.deepStrictEqual(toTuple('a', 1)(both('b', 2)), ['b', 2])\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toTuple<E, A>(e: E, a: A): (fa: These<E, A>) => [E, A] {\n  return (fa) => (isLeft(fa) ? [fa.left, a] : isRight(fa) ? [e, fa.right] : [fa.left, fa.right])\n}",
    "docs": "/**\n * @example\n * import { toTuple, left, right, both } from 'fp-ts/lib/These'\n *\n * assert.deepStrictEqual(toTuple('a', 1)(left('b')), ['b', 1])\n * assert.deepStrictEqual(toTuple('a', 1)(right(2)), ['a', 2])\n * assert.deepStrictEqual(toTuple('a', 1)(both('b', 2)), ['b', 2])\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => [E, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 206,
        "to": 208
      }
    }
  },
  {
    "name": "getLeft",
    "text": "\n/* tslint:enable:readonly-array */\n\n/**\n * Returns an `E` value if possible\n *\n * @example\n * import { getLeft, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getLeft<E, A>(fa: These<E, A>): Option<E> {\n  return isLeft(fa) ? some(fa.left) : isRight(fa) ? none : some(fa.left)\n}",
    "docs": "/**\n * Returns an `E` value if possible\n *\n * @example\n * import { getLeft, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 225,
        "to": 227
      }
    }
  },
  {
    "name": "getRight",
    "text": "\n\n/**\n * Returns an `A` value if possible\n *\n * @example\n * import { getRight, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getRight(left('a')), none)\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(both('a', 1)), some(1))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getRight<E, A>(fa: These<E, A>): Option<A> {\n  return isLeft(fa) ? none : isRight(fa) ? some(fa.right) : some(fa.right)\n}",
    "docs": "/**\n * Returns an `A` value if possible\n *\n * @example\n * import { getRight, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getRight(left('a')), none)\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(both('a', 1)), some(1))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 243,
        "to": 245
      }
    }
  },
  {
    "name": "isLeft",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isLeft<E, A>(fa: These<E, A>): fa is Left<E> {\n  return fa._tag === 'Left'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 253,
        "to": 255
      }
    }
  },
  {
    "name": "isRight",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isRight<E, A>(fa: These<E, A>): fa is Right<A> {\n  return fa._tag === 'Right'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 263,
        "to": 265
      }
    }
  },
  {
    "name": "isBoth",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Both`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isBoth<E, A>(fa: These<E, A>): fa is Both<E, A> {\n  return fa._tag === 'Both'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Both`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 273,
        "to": 275
      }
    }
  },
  {
    "name": "leftOrBoth",
    "text": "\n\n/**\n * @example\n * import { leftOrBoth, left, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))\n * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function leftOrBoth<E>(e: E): <A>(ma: Option<A>) => These<E, A> {\n  return (ma) => (isNone(ma) ? left(e) : both(e, ma.value))\n}",
    "docs": "/**\n * @example\n * import { leftOrBoth, left, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))\n * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 288,
        "to": 290
      }
    }
  },
  {
    "name": "rightOrBoth",
    "text": "\n\n/**\n * @example\n * import { rightOrBoth, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))\n * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function rightOrBoth<A>(a: A): <E>(me: Option<E>) => These<E, A> {\n  return (me) => (isNone(me) ? right(a) : both(me.value, a))\n}",
    "docs": "/**\n * @example\n * import { rightOrBoth, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))\n * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(me: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 303,
        "to": 305
      }
    }
  },
  {
    "name": "getLeftOnly",
    "text": "\n\n/**\n * Returns the `E` value if and only if the value is constructed with `Left`\n *\n * @example\n * import { getLeftOnly, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))\n * assert.deepStrictEqual(getLeftOnly(right(1)), none)\n * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getLeftOnly<E, A>(fa: These<E, A>): Option<E> {\n  return isLeft(fa) ? some(fa.left) : none\n}",
    "docs": "/**\n * Returns the `E` value if and only if the value is constructed with `Left`\n *\n * @example\n * import { getLeftOnly, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))\n * assert.deepStrictEqual(getLeftOnly(right(1)), none)\n * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 321,
        "to": 323
      }
    }
  },
  {
    "name": "getRightOnly",
    "text": "\n\n/**\n * Returns the `A` value if and only if the value is constructed with `Right`\n *\n * @example\n * import { getRightOnly, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getRightOnly(left('a')), none)\n * assert.deepStrictEqual(getRightOnly(right(1)), some(1))\n * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getRightOnly<E, A>(fa: These<E, A>): Option<A> {\n  return isRight(fa) ? some(fa.right) : none\n}",
    "docs": "/**\n * Returns the `A` value if and only if the value is constructed with `Right`\n *\n * @example\n * import { getRightOnly, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(getRightOnly(left('a')), none)\n * assert.deepStrictEqual(getRightOnly(right(1)), some(1))\n * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 339,
        "to": 341
      }
    }
  },
  {
    "name": "fromOptions",
    "text": "\n\n/**\n * Takes a pair of `Option`s and attempts to create a `These` from them\n *\n * @example\n * import { fromOptions, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromOptions(none, none), none)\n * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))\n * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))\n * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromOptions<E, A>(fe: Option<E>, fa: Option<A>): Option<These<E, A>> {\n  return isNone(fe)\n    ? isNone(fa)\n      ? none\n      : some(right(fa.value))\n    : isNone(fa)\n    ? some(left(fe.value))\n    : some(both(fe.value, fa.value))\n}",
    "docs": "/**\n * Takes a pair of `Option`s and attempts to create a `These` from them\n *\n * @example\n * import { fromOptions, left, right, both } from 'fp-ts/lib/These'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromOptions(none, none), none)\n * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))\n * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))\n * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fe",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 358,
        "to": 366
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: These<E, A>) => These<G, B> = (f, g) => (fa) =>\n  bimap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 396,
        "to": 397
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: These<E, A>) => These<G, A> = (f) => (fa) => mapLeft_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 405,
        "to": 405
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: These<E, A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 411,
        "to": 414
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: These<E, A>) => These<E, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 423,
        "to": 423
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: These<E, A>) => B = (b, f) => (fa) =>\n  reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 429,
        "to": 430
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: These<E, A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 436,
        "to": 437
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <E>(ta: These<E, A>) => HKT<F, These<E, B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (ta) => traverseF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 468,
        "to": 473
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <E, A>(\n  ta: These<E, HKT<F, A>>\n): HKT<F, These<E, A>> => {\n  return isLeft(ta) ? F.of(ta) : isRight(ta) ? F.map(ta.right, right) : F.map(ta.right, (b) => both(ta.left, b))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 478,
        "to": 482
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\n\n/**\n * @since 2.4.0\n */\nexport function getTheseM<M extends URIS2>(M: Monad2<M>): TheseM2<M>",
    "docs": "/**\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 126,
        "to": 126
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\nexport function getTheseM<M extends URIS>(M: Monad1<M>): TheseM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 127,
        "to": 127
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\nexport function getTheseM<M>(M: Monad<M>): TheseM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 128,
        "to": 128
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\nexport function getTheseM<M>(M: Monad<M>): TheseM<M> {\n  function mapT<E, A, B>(fa: TheseT<M, E, A>, f: (a: A) => B): TheseT<M, E, B> {\n    return M.map(fa, map(f))\n  }\n\n  function of<E, A>(a: A): TheseT<M, E, A> {\n    return M.of(right(a))\n  }\n\n  function leftT<E = never, A = never>(e: E): TheseT<M, E, A> {\n    return M.of(left(e))\n  }\n\n  return {\n    map: mapT,\n    bimap: (fa, f, g) => M.map(fa, bimap(f, g)),\n    mapLeft: (fa, f) => M.map(fa, mapLeft(f)),\n    fold: (fa, onLeft, onRight, onBoth) => M.chain(fa, fold(onLeft, onRight, onBoth)),\n    swap: (fa) => M.map(fa, swap),\n    rightM: (ma) => M.map(ma, right),\n    leftM: (me) => M.map(me, left),\n    left: leftT,\n    right: of,\n    both: (e, a) => M.of(both(e, a)),\n    toTuple: (fa, e, a) => M.map(fa, toTuple(e, a)),\n    getMonad: <E>(E: Semigroup<E>) => {\n      function chain<A, B>(fa: TheseT<M, E, A>, f: (a: A) => TheseT<M, E, B>): TheseT<M, E, B> {\n        return M.chain(\n          fa,\n          fold(leftT, f, (e1, a) =>\n            M.map(\n              f(a),\n              fold(\n                (e2) => left(E.concat(e1, e2)),\n                right,\n                (e2, b) => both(E.concat(e1, e2), b)\n              )\n            )\n          )\n        )\n      }\n\n      return {\n        _E: undefined as any,\n        map: mapT,\n        of,\n        ap: <A, B>(mab: TheseT<M, E, (a: A) => B>, ma: TheseT<M, E, A>): TheseT<M, E, B> =>\n          chain(mab, (f) => mapT(ma, f)),\n        chain\n      }\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 129,
        "to": 181
      }
    }
  },
  {
    "name": "tracks",
    "text": "\n\n/**\n * Extracts a value at a relative position which depends on the current value.\n *\n * @since 2.0.0\n */\nexport function tracks<P, A>(M: Monoid<P>, f: (a: A) => P): (wa: Traced<P, A>) => A {\n  return (wa) => wa(f(wa(M.empty)))\n}",
    "docs": "/**\n * Extracts a value at a relative position which depends on the current value.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<P>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "listen",
    "text": "\n\n// tslint:disable:readonly-array\n/**\n * Get the current position\n *\n * @since 2.0.0\n */\nexport function listen<P, A>(wa: Traced<P, A>): Traced<P, [A, P]> {\n  return (e) => [wa(e), e]\n}",
    "docs": "/**\n * Get the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, [A, P]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 35,
        "to": 37
      }
    }
  },
  {
    "name": "listens",
    "text": "\n// tslint:enable:readonly-array\n\n// tslint:disable:readonly-array\n/**\n * Get a value which depends on the current position\n *\n * @since 2.0.0\n */\nexport function listens<P, B>(f: (p: P) => B): <A>(wa: Traced<P, A>) => Traced<P, [A, B]> {\n  return (wa) => (e) => [wa(e), f(e)]\n}",
    "docs": "/**\n * Get a value which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, [A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 46,
        "to": 48
      }
    }
  },
  {
    "name": "censor",
    "text": "\n// tslint:enable:readonly-array\n\n/**\n * Apply a function to the current position\n *\n * @since 2.0.0\n */\nexport function censor<P>(f: (p: P) => P): <A>(wa: Traced<P, A>) => Traced<P, A> {\n  return (wa) => (e) => wa(f(e))\n}",
    "docs": "/**\n * Apply a function to the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 56,
        "to": 58
      }
    }
  },
  {
    "name": "getComonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getComonad<P>(monoid: Monoid<P>): Comonad2C<URI, P> {\n  function extend<A, B>(wa: Traced<P, A>, f: (wa: Traced<P, A>) => B): Traced<P, B> {\n    return (p1) => f((p2) => wa(monoid.concat(p1, p2)))\n  }\n\n  function extract<A>(wa: Traced<P, A>): A {\n    return wa(monoid.empty)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    extend,\n    extract\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "monoid",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Comonad\").Comonad2C<\"Traced\", P>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 64,
        "to": 80
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Traced<E, A>) => Traced<E, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 95,
        "to": 95
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\n\n/**\n * Returns the composition of two traversables\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import { io } from 'fp-ts/lib/IO'\n * import { none, option, some } from 'fp-ts/lib/Option'\n * import { getTraversableComposition } from 'fp-ts/lib/Traversable'\n *\n * const T = getTraversableComposition(array, option)\n * const state: Record<string, number | undefined> = {\n *   a: 1,\n *   b: 2\n * }\n * const read = (s: string) => () => state[s]\n * const x = T.sequence(io)([some(read('a')), none, some(read('b')), some(read('c'))])\n * assert.deepStrictEqual(x(), [some(1), none, some(2), some(undefined)])\n *\n * @since 2.0.0\n */\nexport function getTraversableComposition<F extends URIS, G extends URIS>(\n  F: Traversable1<F>,\n  G: Traversable1<G>\n): TraversableComposition11<F, G>",
    "docs": "/**\n * Returns the composition of two traversables\n *\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import { io } from 'fp-ts/lib/IO'\n * import { none, option, some } from 'fp-ts/lib/Option'\n * import { getTraversableComposition } from 'fp-ts/lib/Traversable'\n *\n * const T = getTraversableComposition(array, option)\n * const state: Record<string, number | undefined> = {\n *   a: 1,\n *   b: 2\n * }\n * const read = (s: string) => () => state[s]\n * const x = T.sequence(io)([some(read('a')), none, some(read('b')), some(read('c'))])\n * assert.deepStrictEqual(x(), [some(1), none, some(2), some(undefined)])\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 360,
        "to": 363
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\nexport function getTraversableComposition<F, G>(F: Traversable<F>, G: Traversable<G>): TraversableComposition<F, G>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 364,
        "to": 364
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\nexport function getTraversableComposition<F, G>(F: Traversable<F>, G: Traversable<G>): TraversableComposition<F, G> {\n  const FC = getFoldableComposition(F, G)\n  return {\n    map: getFunctorComposition(F, G).map,\n    reduce: FC.reduce,\n    foldMap: FC.foldMap,\n    reduceRight: FC.reduceRight,\n    traverse: (H) => {\n      const traverseF = F.traverse(H)\n      const traverseG = G.traverse(H)\n      return (fga, f) => traverseF(fga, (ga) => traverseG(ga, f))\n    },\n    sequence: (H) => {\n      const sequenceF = F.sequence(H)\n      const sequenceG = G.sequence(H)\n      return (fgha) => sequenceF(F.map(fgha, sequenceG))\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 365,
        "to": 383
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function make<A>(value: A, forest: Forest<A> = A.empty): Tree<A> {\n  return {\n    value,\n    forest\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "forest",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 47,
        "to": 52
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<A>(S: Show<A>): Show<Tree<A>> {\n  const show = (t: Tree<A>): string => {\n    return t.forest === A.empty || t.forest.length === 0\n      ? `make(${S.show(t.value)})`\n      : `make(${S.show(t.value)}, [${t.forest.map(show).join(', ')}])`\n  }\n  return {\n    show\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 58,
        "to": 67
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<Tree<A>> {\n  let SA: Eq<Array<Tree<A>>>\n  const R: Eq<Tree<A>> = fromEquals((x, y) => E.equals(x.value, y.value) && SA.equals(x.forest, y.forest))\n  SA = A.getEq(R)\n  return R\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 73,
        "to": 78
      }
    }
  },
  {
    "name": "drawForest",
    "text": "\n\n/**\n * Neat 2-dimensional drawing of a forest\n *\n * @since 2.0.0\n */\nexport function drawForest(forest: Forest<string>): string {\n  return draw('\\n', forest)\n}",
    "docs": "/**\n * Neat 2-dimensional drawing of a forest\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "forest",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<string>"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "drawTree",
    "text": "\n\n/**\n * Neat 2-dimensional drawing of a tree\n *\n * @example\n * import { make, drawTree, tree } from 'fp-ts/lib/Tree'\n *\n * const fa = make('a', [\n *   tree.of('b'),\n *   tree.of('c'),\n *   make('d', [tree.of('e'), tree.of('f')])\n * ])\n *\n * assert.strictEqual(drawTree(fa), `a\n *  b\n *  c\n *  d\n *     e\n *     f`)\n *\n *\n * @since 2.0.0\n */\nexport function drawTree(tree: Tree<string>): string {\n  return tree.value + drawForest(tree.forest)\n}",
    "docs": "/**\n * Neat 2-dimensional drawing of a tree\n *\n * @example\n * import { make, drawTree, tree } from 'fp-ts/lib/Tree'\n *\n * const fa = make('a', [\n *   tree.of('b'),\n *   tree.of('c'),\n *   make('d', [tree.of('e'), tree.of('f')])\n * ])\n *\n * assert.strictEqual(drawTree(fa), `a\n *  b\n *  c\n *  d\n *     e\n *     f`)\n *\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "tree",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<string>"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 124,
        "to": 126
      }
    }
  },
  {
    "name": "unfoldTree",
    "text": "\n\n/**\n * Build a tree from a seed value\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldTree<A, B>(b: B, f: (b: B) => [A, Array<B>]): Tree<A> {\n  const [a, bs] = f(b)\n  return { value: a, forest: unfoldForest(bs, f) }\n}",
    "docs": "/**\n * Build a tree from a seed value\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => [A, B[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 134,
        "to": 137
      }
    }
  },
  {
    "name": "unfoldForest",
    "text": "\n\n/**\n * Build a tree from a seed value\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldForest<A, B>(bs: Array<B>, f: (b: B) => [A, Array<B>]): Forest<A> {\n  return bs.map((b) => unfoldTree(b, f))\n}",
    "docs": "/**\n * Build a tree from a seed value\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => [A, B[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 145,
        "to": 147
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\n\n/**\n * Monadic tree builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldTreeM<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>",
    "docs": "/**\n * Monadic tree builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 155,
        "to": 157
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 158,
        "to": 160
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS2>(\n  M: Monad2<M>\n): <E, A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 161,
        "to": 163
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 164,
        "to": 166
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(b: B, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 167,
        "to": 169
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M>(M: Monad<M>): <A, B>(b: B, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 170,
        "to": 170
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M>(M: Monad<M>): <A, B>(b: B, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Tree<A>> {\n  const unfoldForestMM = unfoldForestM(M)\n  return (b, f) => M.chain(f(b), ([a, bs]) => M.chain(unfoldForestMM(bs, f), (ts) => M.of({ value: a, forest: ts })))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 171,
        "to": 174
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\n\n/**\n * Monadic forest builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldForestM<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>",
    "docs": "/**\n * Monadic forest builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 182,
        "to": 184
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 185,
        "to": 187
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS2>(\n  M: Monad2<M>\n): <R, E, B>(bs: Array<B>, f: (b: B) => Kind2<M, R, [E, Array<B>]>) => Kind2<M, R, Forest<E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, [E, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 188,
        "to": 190
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(bs: Array<B>, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 191,
        "to": 193
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(bs: Array<B>, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 194,
        "to": 196
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M>(\n  M: Monad<M>\n): <A, B>(bs: Array<B>, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 197,
        "to": 199
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M>(\n  M: Monad<M>\n): <A, B>(bs: Array<B>, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Forest<A>> {\n  const traverseM = A.traverse(M)\n  return (bs, f) =>\n    pipe(\n      bs,\n      traverseM((b) => unfoldTreeM(M)(b, f))\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 200,
        "to": 209
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, fa: Tree<A>) => boolean {\n  const go = (a: A, fa: Tree<A>): boolean => {\n    if (E.equals(a, fa.value)) {\n      return true\n    }\n    return fa.forest.some((tree) => go(a, tree))\n  }\n  return go\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 214,
        "to": 222
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * Fold a tree into a \"summary\" value in depth-first order.\n *\n * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.\n *\n * This is also known as the catamorphism on trees.\n *\n * @example\n * import { fold, make } from 'fp-ts/lib/Tree'\n *\n * const t = make(1, [make(2), make(3)])\n *\n * const sum = (as: Array<number>) => as.reduce((a, acc) => a + acc, 0)\n *\n * // Sum the values in a tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)\n *\n * // Find the maximum value in the tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)\n *\n * // Count the number of leaves in the tree:\n * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)\n *\n * @category destructors\n * @since 2.6.0\n */\nexport function fold<A, B>(f: (a: A, bs: Array<B>) => B): (tree: Tree<A>) => B {\n  const go = (tree: Tree<A>): B => f(tree.value, tree.forest.map(go))\n  return go\n}",
    "docs": "/**\n * Fold a tree into a \"summary\" value in depth-first order.\n *\n * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.\n *\n * This is also known as the catamorphism on trees.\n *\n * @example\n * import { fold, make } from 'fp-ts/lib/Tree'\n *\n * const t = make(1, [make(2), make(3)])\n *\n * const sum = (as: Array<number>) => as.reduce((a, acc) => a + acc, 0)\n *\n * // Sum the values in a tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)\n *\n * // Find the maximum value in the tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)\n *\n * // Count the number of leaves in the tree:\n * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)\n *\n * @category destructors\n * @since 2.6.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, bs: B[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tree: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 250,
        "to": 253
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Tree<A>) => <B>(fab: Tree<(a: A) => B>) => Tree<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 310,
        "to": 310
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: Tree<B>) => <A>(fa: Tree<A>) => Tree<A> = (fb) => (fa) =>\n  ap_(\n    map_(fa, (a) => () => a),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 318,
        "to": 322
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: Tree<B>) => <A>(fa: Tree<A>): Tree<B> =>\n  ap_(\n    map_(fa, () => (b: B) => b),\n    fb\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 330,
        "to": 334
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Tree<B>) => (ma: Tree<A>) => Tree<B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 342,
        "to": 342
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => Tree<B>) => (ma: Tree<A>) => Tree<A> = (f) => (ma) =>\n  chain_(ma, (a) => map_(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 351,
        "to": 352
      }
    }
  },
  {
    "name": "duplicate",
    "text": "const duplicate: <A>(wa: Tree<A>) => Tree<Tree<A>> = (wa) => extend_(wa, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 358,
        "to": 358
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Tree<A>) => B) => (wa: Tree<A>) => Tree<B> = (f) => (wa) => extend_(wa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 364,
        "to": 364
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: Tree<Tree<A>>) => Tree<A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 370,
        "to": 370
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Tree<A>) => M = (M) => {\n  const foldMapM = foldMap_(M)\n  return (f) => (fa) => foldMapM(fa, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 376,
        "to": 379
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Tree<A>) => Tree<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 388,
        "to": 388
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Tree<A>) => B = (b, f) => (fa) => reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 394,
        "to": 394
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Tree<A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 400,
        "to": 401
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: <A>(wa: Tree<A>) => A = (wa) => wa.value",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 407,
        "to": 407
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Tree<A>) => HKT<F, Tree<B>>) => {\n  const traverseF = traverse_(F)\n  return (f) => (ta) => traverseF(ta, f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 450,
        "to": 455
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: Applicative<F>\n): (<A>(ta: Tree<HKT<F, A>>) => HKT<F, Tree<A>>) => {\n  const traverseF = traverse_(F)\n  return (ta) => traverseF(ta, identity)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 460,
        "to": 465
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function getValidationM<E, M extends URIS2>(S: Semigroup<E>, M: Monad2<M>): ValidationM2<M, E>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM2<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 60,
        "to": 60
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\nexport function getValidationM<E, M extends URIS>(S: Semigroup<E>, M: Monad1<M>): ValidationM1<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM1<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 61,
        "to": 61
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\nexport function getValidationM<E, M>(S: Semigroup<E>, M: Monad<M>): ValidationM<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 62,
        "to": 62
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\nexport function getValidationM<E, M>(S: Semigroup<E>, M: Monad<M>): ValidationM<M, E> {\n  const A = getApplicativeComposition(M, getValidation(S))\n\n  return {\n    map: A.map,\n    ap: A.ap,\n    of: A.of,\n    chain: /* istanbul ignore next */ (ma, f) => M.chain(ma, (e) => (isLeft(e) ? M.of(left(e.left)) : f(e.right))),\n    alt: (fx, f) =>\n      M.chain(fx, (e1) =>\n        isRight(e1) ? A.of(e1.right) : M.map(f(), (e2) => (isLeft(e2) ? left(S.concat(e1.left, e2.left)) : e2))\n      )\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 63,
        "to": 76
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonad<W>(M: Monoid<W>): Monad2C<URI, W> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: map_,\n    ap: (fab, fa) => () => {\n      const [f, w1] = fab()\n      const [a, w2] = fa()\n      return [f(a), M.concat(w1, w2)]\n    },\n    of: (a) => () => [a, M.empty],\n    chain: (fa, f) => () => {\n      const [a, w1] = fa()\n      const [b, w2] = f(a)()\n      return [b, M.concat(w1, w2)]\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 131,
        "to": 148
      }
    }
  },
  {
    "name": "tell",
    "text": "const tell: <W>(w: W) => Writer<W, void> = (w) => () => [undefined, w]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "w",
          "type": {
            "__tag": "Other",
            "values": "W"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [any, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 33,
        "to": 33
      }
    }
  },
  {
    "name": "listen",
    "text": "const listen: <W, A>(fa: Writer<W, A>) => Writer<W, [A, W]> = (fa) => () => {\n  const [a, w] = fa()\n  return [[a, w], w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [[A, W], W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 42,
        "to": 45
      }
    }
  },
  {
    "name": "pass",
    "text": "const pass: <W, A>(fa: Writer<W, [A, (w: W) => W]>) => Writer<W, A> = (fa) => () => {\n  const [[a, f], w] = fa()\n  return [a, f(w)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, [A, (w: W) => W]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [A, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 56,
        "to": 59
      }
    }
  },
  {
    "name": "listens",
    "text": "const listens: <W, B>(f: (w: W) => B) => <A>(fa: Writer<W, A>) => Writer<W, [A, B]> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [[a, f(w)], w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(w: W) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>) => () => [[A, B], W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 69,
        "to": 72
      }
    }
  },
  {
    "name": "censor",
    "text": "const censor: <W>(f: (w: W) => W) => <A>(fa: Writer<W, A>) => Writer<W, A> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [a, f(w)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(w: W) => W"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>) => () => [A, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 81,
        "to": 84
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Writer<E, A>) => Writer<E, B> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [f(a), w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<E, A>) => () => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 97,
        "to": 100
      }
    }
  },
  {
    "name": "evalWriter",
    "text": "const evalWriter: <W, A>(fa: Writer<W, A>) => A = (fa) => fa()[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 166,
        "to": 166
      }
    }
  },
  {
    "name": "execWriter",
    "text": "const execWriter: <W, A>(fa: Writer<W, A>) => W = (fa) => fa()[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "W"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 171,
        "to": 171
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\n\n/**\n * @since 2.4.0\n */\nexport function getWriterM<M extends URIS3>(M: Monad3<M>): WriterM3<M>",
    "docs": "/**\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 165,
        "to": 165
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS2>(M: Monad2<M>): WriterM2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 166,
        "to": 166
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS2, E>(M: Monad2C<M, E>): WriterM2C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS>(M: Monad1<M>): WriterM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 168,
        "to": 168
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M>(M: Monad<M>): WriterM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 169,
        "to": 169
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M>(M: Monad<M>): WriterM<M> {\n  const map = <W, A, B>(fa: WriterT<M, W, A>, f: (a: A) => B): WriterT<M, W, B> => () =>\n    M.map(fa(), ([a, w]) => [f(a), w])\n  return {\n    map,\n    evalWriter: (fa) => M.map(fa(), ([a]) => a),\n    execWriter: (fa) => M.map(fa(), ([_, w]) => w),\n    tell: (w) => () => M.of([undefined, w]),\n    listen: (fa) => () => M.map(fa(), ([a, w]) => [[a, w], w]),\n    pass: (fa) => () => M.map(fa(), ([[a, f], w]) => [a, f(w)]),\n    listens: (fa, f) => () => M.map(fa(), ([a, w]) => [[a, f(w)], w]),\n    censor: (fa, f) => () => M.map(fa(), ([a, w]) => [a, f(w)]),\n    getMonad: (W) => {\n      return {\n        _E: undefined as any,\n        map,\n        of: (a) => () => M.of([a, W.empty]),\n        ap: (mab, ma) => () => M.chain(mab(), ([f, w1]) => M.map(ma(), ([a, w2]) => [f(a), W.concat(w1, w2)])),\n        chain: (ma, f) => () => M.chain(ma(), ([a, w1]) => M.map(f(a)(), ([b, w2]) => [b, W.concat(w1, w2)]))\n      }\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 170,
        "to": 192
      }
    }
  },
  {
    "name": "factoryS",
    "text": "\n\nexport function factoryS<F extends URIS>(\n  F: _.Apply1<F>,\n  a1: Kind<F, string>,\n  a2: Kind<F, number>,\n  a3: Kind<F, boolean>,\n  a4: Kind<F, string>,\n  a5: Kind<F, number>,\n  a6: Kind<F, boolean>,\n  a7: Kind<F, string>,\n  a8: Kind<F, number>,\n  a9: Kind<F, boolean>\n): Kind<F, boolean> {\n  return F.map(_.sequenceS(F)({ a1, a2, a3, a4, a5, a6, a7, a8, a9 }), ({ a1, a2, a3, a4, a5, a6, a7, a8, a9 }) =>\n    functionForfactoryS(a1, a2, a3, a4, a5, a6, a7, a8, a9)\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "a1",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "a2",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "a3",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        },
        {
          "name": "a4",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "a5",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "a6",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        },
        {
          "name": "a7",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "a8",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "a9",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "dtslint/ts3.5/Apply.ts",
      "lines": {
        "from": 22,
        "to": 37
      }
    }
  },
  {
    "name": "factoryT",
    "text": " // $ExpectType ReaderTaskEither<{ a: number; }, string, { sequenceS5: number; sequenceS6: string; sequenceS7: boolean; }>\n\n//\n// sequenceT\n//\n\nexport function factoryT<F extends URIS>(\n  F: _.Apply1<F>,\n  f1: Kind<F, string>,\n  f2: Kind<F, number>,\n  f3: Kind<F, boolean>,\n  f4: Kind<F, string>,\n  f5: Kind<F, number>,\n  f6: Kind<F, boolean>,\n  f7: Kind<F, string>,\n  f8: Kind<F, number>,\n  f9: Kind<F, boolean>\n): Kind<F, boolean> {\n  return F.map(_.sequenceT(F)(f1, f2, f3, f4, f5, f6, f7, f8, f9), ([a1, a2, a3, a4, a5, a6, a7, a8, a9]) =>\n    functionForfactoryS(a1, a2, a3, a4, a5, a6, a7, a8, a9)\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "f1",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "f2",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "f3",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        },
        {
          "name": "f4",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "f5",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "f6",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        },
        {
          "name": "f7",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>"
          }
        },
        {
          "name": "f8",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>"
          }
        },
        {
          "name": "f9",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, boolean>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "dtslint/ts3.5/Apply.ts",
      "lines": {
        "from": 71,
        "to": 86
      }
    }
  },
  {
    "name": "isOutOfBound1",
    "text": "\n\nexport function isOutOfBound1<A>(i: number, as: Array<A>): boolean {\n  return i < 0 || i >= as.length\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/Array/isOutOfBound.ts",
      "lines": {
        "from": 5,
        "to": 7
      }
    }
  },
  {
    "name": "isOutOfBound2",
    "text": "\n\nexport function isOutOfBound2<A>(i: number): (as: Array<A>) => boolean {\n  return as => i < 0 || i >= as.length\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/Array/isOutOfBound.ts",
      "lines": {
        "from": 9,
        "to": 11
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\n\nexport function flowWithoutSwitch<A extends Array<unknown>, B>(ab: (...a: A) => B): (...a: A) => B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 6,
        "to": 6
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 7,
        "to": 7
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): (...a: A) => D",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 8,
        "to": 12
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 13,
        "to": 18
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E, F>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => F"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 19,
        "to": 25
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E, F, G>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => G"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 26,
        "to": 33
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E, F, G, H>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => H"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 34,
        "to": 42
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E, F, G, H, I>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => I"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 43,
        "to": 52
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch<A extends Array<unknown>, B, C, D, E, F, G, H, I, J>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => J"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 53,
        "to": 63
      }
    }
  },
  {
    "name": "flowWithoutSwitch",
    "text": "\nexport function flowWithoutSwitch(...fns: Array<Function>): Function {\n  const len = fns.length - 1\n  return function(this: any, ...x: Array<any>) {\n    let y = fns[0].apply(this, x)\n    for (let i = 1; i <= len; i++) {\n      y = fns[i].call(this, y)\n    }\n    return y\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fns",
          "type": {
            "__tag": "Other",
            "values": "Function[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Function"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 64,
        "to": 73
      }
    }
  },
  {
    "name": "nonEmptyArray",
    "text": "\n\n/**\n * Returns an `Arbitrary` that yelds a non empty array\n */\nexport function nonEmptyArray<A>(arb: fc.Arbitrary<A>): fc.Arbitrary<NonEmptyArray<A>> {\n  return fc.array(arb, 1, 100) as any\n}",
    "docs": "/**\n * Returns an `Arbitrary` that yelds a non empty array\n */",
    "signature": {
      "parameters": [
        {
          "name": "arb",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/property-test/NonEmptyArray.ts",
      "lines": {
        "from": 7,
        "to": 9
      }
    }
  },
  {
    "name": "getSome",
    "text": "\n\n/**\n * Returns an `Arbitrary` that yelds only `some`s\n * @since 0.0.2\n */\nexport function getSome<A>(arb: fc.Arbitrary<A>): fc.Arbitrary<Option<A>> {\n  return arb.map(some)\n}",
    "docs": "/**\n * Returns an `Arbitrary` that yelds only `some`s\n * @since 0.0.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "arb",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/property-test/Option.ts",
      "lines": {
        "from": 8,
        "to": 10
      }
    }
  },
  {
    "name": "getNone",
    "text": "\n\n/**\n * Returns an `Arbitrary` that yelds only `none`s\n * @since 0.0.2\n */\nexport function getNone<A>(): fc.Arbitrary<Option<A>> {\n  return fc.constant(none)\n}",
    "docs": "/**\n * Returns an `Arbitrary` that yelds only `none`s\n * @since 0.0.2\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/property-test/Option.ts",
      "lines": {
        "from": 16,
        "to": 18
      }
    }
  },
  {
    "name": "getOption",
    "text": "\n\n/**\n * Returns an `Arbitrary` that yelds both `some`s and `none`s\n * @since 0.0.2\n */\nexport function getOption<A>(arb: fc.Arbitrary<A>): fc.Arbitrary<Option<A>> {\n  return fc.oneof(getNone<A>(), getSome(arb))\n}",
    "docs": "/**\n * Returns an `Arbitrary` that yelds both `some`s and `none`s\n * @since 0.0.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "arb",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/property-test/Option.ts",
      "lines": {
        "from": 24,
        "to": 26
      }
    }
  }
]
