[
  {
    "name": "copyPackageJson",
    "text": "const copyPackageJson: Build<void> = (C) =>\n  pipe(\n    C.readFile(PKG),\n    TE.chain((s) => TE.fromEither(E.parseJSON(s, E.toError))),\n    TE.map((v) => {\n      const clone = Object.assign({}, v as any)\n\n      delete clone.scripts\n      delete clone.files\n      delete clone.devDependencies\n\n      return clone\n    }),\n    TE.chain((json) => C.writeFile(path.join(OUTPUT_FOLDER, PKG), JSON.stringify(json, null, 2)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 15,
        "to": 29
      }
    }
  },
  {
    "name": "copyFiles",
    "text": "const copyFiles: Build<ReadonlyArray<void>> = (C) =>\n  pipe(\n    FILES,\n    A.traverse(TE.taskEither)((from) => C.copyFile(from, path.resolve(OUTPUT_FOLDER, from)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 33,
        "to": 37
      }
    }
  },
  {
    "name": "makeModules",
    "text": "const makeModules: Build<void> = (C) =>\n  pipe(\n    C.glob(`${OUTPUT_FOLDER}/lib/*.js`),\n    TE.map(getModules),\n    TE.chain(traverse(makeSingleModule(C))),\n    TE.map(() => undefined)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 41,
        "to": 47
      }
    }
  },
  {
    "name": "run",
    "text": "\n\nexport function run<A>(eff: TaskEither<Error, A>): void {\n  eff()\n    .then(\n      fold(\n        (e) => {\n          throw e\n        },\n        (_) => {\n          process.exitCode = 0\n        }\n      )\n    )\n    .catch((e) => {\n      console.error(e) // tslint:disable-line no-console\n\n      process.exitCode = 1\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eff",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "scripts/run.ts",
      "lines": {
        "from": 4,
        "to": 21
      }
    }
  },
  {
    "name": "clone",
    "text": "\n\n/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */\nexport function clone<C extends t.Any>(t: C): C {\n  const r = Object.create(Object.getPrototypeOf(t))\n  Object.assign(r, t)\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "t",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/clone.ts",
      "lines": {
        "from": 17,
        "to": 21
      }
    }
  },
  {
    "name": "either",
    "text": "\n\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either<L extends t.Mixed, R extends t.Mixed>(\n  leftCodec: L,\n  rightCodec: R,\n  name: string = `Either<${leftCodec.name}, ${rightCodec.name}>`\n): EitherC<L, R> {\n  return t.union(\n    [\n      t.strict(\n        {\n          _tag: leftLiteral,\n          left: leftCodec\n        },\n        `Left<${leftCodec.name}>`\n      ),\n      t.strict(\n        {\n          _tag: rightLiteral,\n          right: rightCodec\n        },\n        `Right<${leftCodec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "leftCodec",
          "type": {
            "__tag": "Other",
            "values": "L"
          }
        },
        {
          "name": "rightCodec",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/either\").EitherC<L, R>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/either.ts",
      "lines": {
        "from": 35,
        "to": 59
      }
    }
  },
  {
    "name": "fromNewtype",
    "text": "\n\n/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */\nexport function fromNewtype<N extends AnyNewtype = never>(\n  codec: t.Type<CarrierOf<N>, t.OutputOf<CarrierOf<N>>>,\n  name = `fromNewtype(${codec.name})`\n): t.Type<N, CarrierOf<N>, unknown> {\n  const i = iso<N>()\n  return new t.Type(\n    name,\n    (u): u is N => codec.is(u),\n    (u, c) =>\n      pipe(\n        codec.validate(u, c),\n        map(i.wrap)\n      ),\n    a => codec.encode(i.unwrap(a))\n  )\n}",
    "docs": "/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromNewtype.ts",
      "lines": {
        "from": 28,
        "to": 43
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */\nexport function fromNullable<C extends t.Mixed>(codec: C, a: t.TypeOf<C>, name = `fromNullable(${codec.name})`): C {\n  return withValidate(codec, (u, c) => (u == null ? t.success(a) : codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromNullable.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "\n\n/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */\nexport function fromRefinement<A>(name: string, is: (u: unknown) => u is A): t.Type<A, A, unknown> {\n  return new t.Type(name, is, (u, c) => (is(u) ? t.success(u) : t.failure(u, c)), t.identity)\n}",
    "docs": "/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "is",
          "type": {
            "__tag": "Other",
            "values": "(u: unknown) => u is A"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/fromRefinement.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "getLenses",
    "text": "\n\n/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */\nexport function getLenses<C extends HasLenses>(\n  codec: C\n): { [K in keyof t.TypeOf<C>]: Lens<t.TypeOf<C>, t.TypeOf<C>[K]> } {\n  const r: any = {}\n  for (const k in getProps(codec)) {\n    r[k] = fromProp(k)\n  }\n  return r\n}",
    "docs": "/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ [x: string]: any; }"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/getLenses.ts",
      "lines": {
        "from": 45,
        "to": 53
      }
    }
  },
  {
    "name": "mapOutput",
    "text": "\n\n/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */\nexport function mapOutput<A, O, I, P>(\n  codec: t.Type<A, O, I>,\n  f: (p: O) => P,\n  name: string = codec.name\n): t.Type<A, P, I> {\n  return new t.Type(name, codec.is, codec.validate, a => f(codec.encode(a)))\n}",
    "docs": "/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: O) => P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 28,
        "to": 34
      }
    }
  },
  {
    "name": "nonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function nonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `NonEmptyArray<${codec.name}>`\n): NonEmptyArrayC<C> {\n  const arr = t.array(codec)\n  return new t.Type(\n    name,\n    (u): u is NonEmptyArray<t.TypeOf<C>> => arr.is(u) && isNonEmpty(u),\n    (u, c) =>\n      pipe(\n        arr.validate(u, c),\n        chain(as => {\n          const onea = fromArray(as)\n          return isNone(onea) ? t.failure(u, c) : t.success(onea.value)\n        })\n      ),\n    nea => arr.encode(nea)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/nonEmptyArray\").NonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 20,
        "to": 38
      }
    }
  },
  {
    "name": "readonlySetFromArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlySetFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `ReadonlySet<${codec.name}>`\n): ReadonlySetFromArrayC<C> {\n  return setFromArray(codec, O, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlySetFromArray\").ReadonlySetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 17,
        "to": 23
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "\n\n/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */\nexport function fromRefinement<A>(name: string, is: (u: unknown) => u is A): t.Type<A, A, unknown> {\n  return new t.Type(name, is, (u, c) => (is(u) ? t.success(u) : t.failure(u, c)), t.identity)\n}",
    "docs": "/**\n * Returns a codec from a refinement\n *\n * @since 0.4.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "is",
          "type": {
            "__tag": "Other",
            "values": "(u: unknown) => u is A"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "fromNewtype",
    "text": "\n\n/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */\nexport function fromNewtype<N extends AnyNewtype = never>(\n  codec: t.Type<CarrierOf<N>, t.OutputOf<CarrierOf<N>>>,\n  name = `fromNewtype(${codec.name})`\n): t.Type<N, CarrierOf<N>, unknown> {\n  const i = iso<N>()\n  return new t.Type(\n    name,\n    (u): u is N => codec.is(u),\n    (u, c) =>\n      pipe(\n        codec.validate(u, c),\n        map(i.wrap)\n      ),\n    a => codec.encode(i.unwrap(a))\n  )\n}",
    "docs": "/**\n * Returns a codec from a newtype\n *\n * @example\n * import { fromNewtype } from 'io-ts-types/lib/fromNewtype'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { Newtype, iso } from 'newtype-ts'\n *\n * interface Token extends Newtype<{ readonly Token: unique symbol }, string> {}\n *\n * const T = fromNewtype<Token>(t.string)\n *\n * assert.deepStrictEqual(T.decode('sometoken'), right(iso<Token>().wrap('sometoken')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(42)), ['Invalid value 42 supplied to : fromNewtype(string)'])\n *\n * @since 0.5.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 28,
        "to": 43
      }
    }
  },
  {
    "name": "optionFromNullable",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function optionFromNullable<C extends t.Mixed>(\n  codec: C,\n  name: string = `Option<${codec.name}>`\n): OptionFromNullableC<C> {\n  return new t.Type(\n    name,\n    option(codec).is,\n    (u, c) =>\n      u == null\n        ? t.success(O.none)\n        : pipe(\n            codec.validate(u, c),\n            map(O.some)\n          ),\n    a =>\n      O.toNullable(\n        pipe(\n          a,\n          O.map(codec.encode)\n        )\n      )\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/optionFromNullable\").OptionFromNullableC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 19,
        "to": 41
      }
    }
  },
  {
    "name": "readonlyNonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlyNonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `ReadonlyNonEmptyArray<${codec.name}>`\n): ReadonlyNonEmptyArrayC<C> {\n  return nonEmptyArray(codec, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlyNonEmptyArray\").ReadonlyNonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 23,
        "to": 28
      }
    }
  },
  {
    "name": "clone",
    "text": "\n\n/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */\nexport function clone<C extends t.Any>(t: C): C {\n  const r = Object.create(Object.getPrototypeOf(t))\n  Object.assign(r, t)\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec\n *\n * @example\n * import { clone } from 'io-ts-types/lib/clone'\n * import * as t from 'io-ts'\n *\n * assert.deepStrictEqual(clone(t.string), t.string)\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "t",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 17,
        "to": 21
      }
    }
  },
  {
    "name": "withFallback",
    "text": "\n\n/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */\nexport function withFallback<C extends t.Any>(codec: C, a: t.TypeOf<C>, name = `withFallback(${codec.name})`): C {\n  return withValidate(codec, (u, c) => orElse(() => t.success(a))(codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */\nexport function fromNullable<C extends t.Mixed>(codec: C, a: t.TypeOf<C>, name = `fromNullable(${codec.name})`): C {\n  return withValidate(codec, (u, c) => (u == null ? t.success(a) : codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that replace a nullable input with the given value `a`\n *\n * @example\n * import { fromNullable } from 'io-ts-types/lib/fromNullable'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = fromNullable(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode(null), right(-1))\n * assert.deepStrictEqual(T.decode(undefined), right(-1))\n * assert.deepStrictEqual(PathReporter.report(T.decode('a')), ['Invalid value \"a\" supplied to : fromNullable(number)'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "withMessage",
    "text": "\n\n/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */\nexport function withMessage<C extends t.Any>(codec: C, message: (i: t.InputOf<C>, c: t.Context) => string): C {\n  return withValidate(codec, (i, c) =>\n    mapLeft(() => [\n      {\n        value: i,\n        context: c,\n        message: message(i, c),\n        actual: i\n      }\n    ])(codec.validate(i, c))\n  )\n}",
    "docs": "/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "Other",
            "values": "(i: any, c: any) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 24,
        "to": 35
      }
    }
  },
  {
    "name": "withValidate",
    "text": "\n\n/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */\nexport function withValidate<C extends t.Any>(codec: C, validate: C['validate'], name: string = codec.name): C {\n  const r: any = clone(codec)\n  r.validate = validate\n  // tslint:disable-next-line: deprecation\n  r.decode = (i: any) => validate(i, t.getDefaultContext(r))\n  r.name = name\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "validate",
          "type": {
            "__tag": "Other",
            "values": "C[\"validate\"]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 23,
        "to": 30
      }
    }
  },
  {
    "name": "getLenses",
    "text": "\n\n/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */\nexport function getLenses<C extends HasLenses>(\n  codec: C\n): { [K in keyof t.TypeOf<C>]: Lens<t.TypeOf<C>, t.TypeOf<C>[K]> } {\n  const r: any = {}\n  for (const k in getProps(codec)) {\n    r[k] = fromProp(k)\n  }\n  return r\n}",
    "docs": "/**\n * Return a `Lens` for each prop\n *\n * @example\n * import * as t from 'io-ts'\n * import { getLenses } from 'io-ts-types/lib/getLenses'\n *\n * const Person = t.type({\n *   name: t.string,\n *   age: t.number\n * })\n *\n * const lenses = getLenses(Person)\n * assert.strictEqual(lenses.age.get({ name: 'Giulio', age: 44 }), 44)\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ [x: string]: any; }"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 45,
        "to": 53
      }
    }
  },
  {
    "name": "option",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function option<C extends t.Mixed>(codec: C, name: string = `Option<${codec.name}>`): OptionC<C> {\n  return t.union(\n    [\n      None,\n      t.strict(\n        {\n          _tag: someLiteral,\n          value: codec\n        },\n        `Some<${codec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/option\").OptionC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 37,
        "to": 51
      }
    }
  },
  {
    "name": "setFromArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function setFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `Set<${codec.name}>`\n): SetFromArrayC<C> {\n  const arr = t.array(codec)\n  const toArrayO = toArray(O)\n  const fromArrayO = fromArray(O)\n  return new t.Type(\n    name,\n    (u): u is Set<t.TypeOf<C>> => u instanceof Set && every(codec.is)(u),\n    (u, c) =>\n      pipe(\n        arr.validate(u, c),\n        chain(as => {\n          const set = fromArrayO(as)\n          return set.size !== as.length ? t.failure(u, c) : t.success(set)\n        })\n      ),\n    set => arr.encode(toArrayO(set))\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/setFromArray\").SetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 18,
        "to": 39
      }
    }
  },
  {
    "name": "either",
    "text": "\n\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either<L extends t.Mixed, R extends t.Mixed>(\n  leftCodec: L,\n  rightCodec: R,\n  name: string = `Either<${leftCodec.name}, ${rightCodec.name}>`\n): EitherC<L, R> {\n  return t.union(\n    [\n      t.strict(\n        {\n          _tag: leftLiteral,\n          left: leftCodec\n        },\n        `Left<${leftCodec.name}>`\n      ),\n      t.strict(\n        {\n          _tag: rightLiteral,\n          right: rightCodec\n        },\n        `Right<${leftCodec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/lib/either'\n * import { left, right } from 'fp-ts/lib/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "leftCodec",
          "type": {
            "__tag": "Other",
            "values": "L"
          }
        },
        {
          "name": "rightCodec",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/either\").EitherC<L, R>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 35,
        "to": 59
      }
    }
  },
  {
    "name": "withEncode",
    "text": "\n\n/**\n * Returns a clone of the given codec which uses the given `encode` function\n *\n * @example\n * import { withEncode } from 'io-ts-types/lib/withEncode'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withEncode(t.number, String)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.encode(1), '1')\n * assert.deepStrictEqual(PathReporter.report(T.decode('str')), ['Invalid value \"str\" supplied to : number'])\n *\n * @since 0.5.12\n */\nexport function withEncode<A, O, I, P>(\n  codec: t.Type<A, O, I>,\n  encode: (a: A) => P,\n  name: string = codec.name\n): t.Type<A, P, I> {\n  return new t.Type(name, codec.is, codec.validate, encode)\n}",
    "docs": "/**\n * Returns a clone of the given codec which uses the given `encode` function\n *\n * @example\n * import { withEncode } from 'io-ts-types/lib/withEncode'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withEncode(t.number, String)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.encode(1), '1')\n * assert.deepStrictEqual(PathReporter.report(T.decode('str')), ['Invalid value \"str\" supplied to : number'])\n *\n * @since 0.5.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "encode",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 23,
        "to": 29
      }
    }
  },
  {
    "name": "mapOutput",
    "text": "\n\n/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */\nexport function mapOutput<A, O, I, P>(\n  codec: t.Type<A, O, I>,\n  f: (p: O) => P,\n  name: string = codec.name\n): t.Type<A, P, I> {\n  return new t.Type(name, codec.is, codec.validate, a => f(codec.encode(a)))\n}",
    "docs": "/**\n * Changes the output type of the given runtime type\n *\n * @example\n * import * as t from 'io-ts'\n * import { mapOutput } from 'io-ts-types/lib/mapOutput'\n * import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'\n * import { none, some } from 'fp-ts/lib/Option'\n *\n * // Input: t.Type<Option<number>, number | null, t.mixed>\n * const Input = optionFromNullable(t.number)\n *\n * const toUndefined = <A>(x: A | null): A | undefined => (x === null ? undefined : x)\n *\n * // Output: t.Type<Option<number>, number | undefined, t.mixed>\n * const Output = mapOutput(Input, toUndefined)\n *\n * assert.strictEqual(Output.encode(none), undefined)\n * assert.strictEqual(Output.encode(some(1)), 1)\n *\n * @since 0.3.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: O) => P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/mapOutput.ts",
      "lines": {
        "from": 28,
        "to": 34
      }
    }
  },
  {
    "name": "nonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function nonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `NonEmptyArray<${codec.name}>`\n): NonEmptyArrayC<C> {\n  const arr = t.array(codec)\n  return new t.Type(\n    name,\n    (u): u is NonEmptyArray<t.TypeOf<C>> => arr.is(u) && isNonEmpty(u),\n    (u, c) =>\n      pipe(\n        arr.validate(u, c),\n        chain(as => {\n          const onea = fromArray(as)\n          return isNone(onea) ? t.failure(u, c) : t.success(onea.value)\n        })\n      ),\n    nea => arr.encode(nea)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/nonEmptyArray\").NonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/nonEmptyArray.ts",
      "lines": {
        "from": 20,
        "to": 38
      }
    }
  },
  {
    "name": "option",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function option<C extends t.Mixed>(codec: C, name: string = `Option<${codec.name}>`): OptionC<C> {\n  return t.union(\n    [\n      None,\n      t.strict(\n        {\n          _tag: someLiteral,\n          value: codec\n        },\n        `Some<${codec.name}>`\n      )\n    ],\n    name\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/option\").OptionC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/option.ts",
      "lines": {
        "from": 37,
        "to": 51
      }
    }
  },
  {
    "name": "optionFromNullable",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function optionFromNullable<C extends t.Mixed>(\n  codec: C,\n  name: string = `Option<${codec.name}>`\n): OptionFromNullableC<C> {\n  return new t.Type(\n    name,\n    option(codec).is,\n    (u, c) =>\n      u == null\n        ? t.success(O.none)\n        : pipe(\n            codec.validate(u, c),\n            map(O.some)\n          ),\n    a =>\n      O.toNullable(\n        pipe(\n          a,\n          O.map(codec.encode)\n        )\n      )\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/optionFromNullable\").OptionFromNullableC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/optionFromNullable.ts",
      "lines": {
        "from": 19,
        "to": 41
      }
    }
  },
  {
    "name": "readonlyNonEmptyArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlyNonEmptyArray<C extends t.Mixed>(\n  codec: C,\n  name: string = `ReadonlyNonEmptyArray<${codec.name}>`\n): ReadonlyNonEmptyArrayC<C> {\n  return nonEmptyArray(codec, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlyNonEmptyArray\").ReadonlyNonEmptyArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/readonlyNonEmptyArray.ts",
      "lines": {
        "from": 23,
        "to": 28
      }
    }
  },
  {
    "name": "readonlySetFromArray",
    "text": "\n\n/**\n * @since 0.5.7\n */\nexport function readonlySetFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `ReadonlySet<${codec.name}>`\n): ReadonlySetFromArrayC<C> {\n  return setFromArray(codec, O, name) as any\n}",
    "docs": "/**\n * @since 0.5.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/readonlySetFromArray\").ReadonlySetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/readonlySetFromArray.ts",
      "lines": {
        "from": 17,
        "to": 23
      }
    }
  },
  {
    "name": "setFromArray",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function setFromArray<C extends t.Mixed>(\n  codec: C,\n  O: Ord<t.TypeOf<C>>,\n  name: string = `Set<${codec.name}>`\n): SetFromArrayC<C> {\n  const arr = t.array(codec)\n  const toArrayO = toArray(O)\n  const fromArrayO = fromArray(O)\n  return new t.Type(\n    name,\n    (u): u is Set<t.TypeOf<C>> => u instanceof Set && every(codec.is)(u),\n    (u, c) =>\n      pipe(\n        arr.validate(u, c),\n        chain(as => {\n          const set = fromArrayO(as)\n          return set.size !== as.length ? t.failure(u, c) : t.success(set)\n        })\n      ),\n    set => arr.encode(toArrayO(set))\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "O",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts-types/src/setFromArray\").SetFromArrayC<C>"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/setFromArray.ts",
      "lines": {
        "from": 18,
        "to": 39
      }
    }
  },
  {
    "name": "withEncode",
    "text": "\n\n/**\n * Returns a clone of the given codec which uses the given `encode` function\n *\n * @example\n * import { withEncode } from 'io-ts-types/lib/withEncode'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withEncode(t.number, String)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.encode(1), '1')\n * assert.deepStrictEqual(PathReporter.report(T.decode('str')), ['Invalid value \"str\" supplied to : number'])\n *\n * @since 0.5.12\n */\nexport function withEncode<A, O, I, P>(\n  codec: t.Type<A, O, I>,\n  encode: (a: A) => P,\n  name: string = codec.name\n): t.Type<A, P, I> {\n  return new t.Type(name, codec.is, codec.validate, encode)\n}",
    "docs": "/**\n * Returns a clone of the given codec which uses the given `encode` function\n *\n * @example\n * import { withEncode } from 'io-ts-types/lib/withEncode'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withEncode(t.number, String)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.encode(1), '1')\n * assert.deepStrictEqual(PathReporter.report(T.decode('str')), ['Invalid value \"str\" supplied to : number'])\n *\n * @since 0.5.12\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "encode",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withEncode.ts",
      "lines": {
        "from": 23,
        "to": 29
      }
    }
  },
  {
    "name": "withFallback",
    "text": "\n\n/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */\nexport function withFallback<C extends t.Any>(codec: C, a: t.TypeOf<C>, name = `withFallback(${codec.name})`): C {\n  return withValidate(codec, (u, c) => orElse(() => t.success(a))(codec.validate(u, c)), name)\n}",
    "docs": "/**\n * Returns a clone of the given codec that always succeed using the given value `a` if the original codec fails\n *\n * @example\n * import { withFallback } from 'io-ts-types/lib/withFallback'\n * import * as t from 'io-ts'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withFallback(t.number, -1)\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(T.decode('a'), right(-1))\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withFallback.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "withMessage",
    "text": "\n\n/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */\nexport function withMessage<C extends t.Any>(codec: C, message: (i: t.InputOf<C>, c: t.Context) => string): C {\n  return withValidate(codec, (i, c) =>\n    mapLeft(() => [\n      {\n        value: i,\n        context: c,\n        message: message(i, c),\n        actual: i\n      }\n    ])(codec.validate(i, c))\n  )\n}",
    "docs": "/**\n * Returns a clone of the given codec that sets the given string as error messsage\n *\n * @example\n * import { withMessage } from 'io-ts-types/lib/withMessage'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { right } from 'fp-ts/lib/Either'\n *\n * const T = withMessage(t.number, () => 'Invalid number')\n *\n * assert.deepStrictEqual(T.decode(1), right(1))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "Other",
            "values": "(i: any, c: any) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withMessage.ts",
      "lines": {
        "from": 24,
        "to": 35
      }
    }
  },
  {
    "name": "withValidate",
    "text": "\n\n/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */\nexport function withValidate<C extends t.Any>(codec: C, validate: C['validate'], name: string = codec.name): C {\n  const r: any = clone(codec)\n  r.validate = validate\n  // tslint:disable-next-line: deprecation\n  r.decode = (i: any) => validate(i, t.getDefaultContext(r))\n  r.name = name\n  return r\n}",
    "docs": "/**\n * Returns a clone of the given codec which uses the given `validate` function\n *\n * @example\n * import { withValidate } from 'io-ts-types/lib/withValidate'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/lib/PathReporter'\n * import { either, right } from 'fp-ts/lib/Either'\n *\n * const T = withValidate(t.number, (u, c) => either.map(t.number.validate(u, c), n => n * 2))\n *\n * assert.deepStrictEqual(T.decode(1), right(2))\n * assert.deepStrictEqual(PathReporter.report(T.decode(null)), ['Invalid value null supplied to : number'])\n *\n * @since 0.4.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "validate",
          "type": {
            "__tag": "Other",
            "values": "C[\"validate\"]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "src/withValidate.ts",
      "lines": {
        "from": 23,
        "to": 30
      }
    }
  },
  {
    "name": "assertStrictEqual",
    "text": "\n\nexport function assertStrictEqual<T>(result: t.Validation<T>, expected: any): void {\n  if (isRight(result)) {\n    assert.deepStrictEqual(result.right, expected)\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 6,
        "to": 12
      }
    }
  },
  {
    "name": "assertSuccess",
    "text": "\n\nexport function assertSuccess<T>(result: t.Validation<T>, expected?: T): void {\n  if (isRight(result)) {\n    if (expected !== undefined) {\n      assert.deepStrictEqual(result.right, expected)\n    }\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 14,
        "to": 22
      }
    }
  },
  {
    "name": "assertStrictSuccess",
    "text": "\n\nexport function assertStrictSuccess<T>(result: t.Validation<T>, expected: T): void {\n  if (isRight(result)) {\n    if (expected !== undefined) {\n      assert.strictEqual(result.right, expected)\n    }\n  } else {\n    throw new Error(`${result} is not a right`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 24,
        "to": 32
      }
    }
  },
  {
    "name": "assertFailure",
    "text": "\n\nexport function assertFailure(codec: t.Any, value: unknown, errors: Array<string>): void {\n  const result = codec.decode(value)\n  if (isLeft(result)) {\n    assert.deepStrictEqual(PathReporter.report(result), errors)\n  } else {\n    throw new Error(`${result} is not a left`)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "string[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts-types",
    "location": {
      "path": "test/helpers.ts",
      "lines": {
        "from": 34,
        "to": 41
      }
    }
  },
  {
    "name": "_right",
    "text": "const _right = <E, A>(): Prism<Either<E, A>, A> => r",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Prism<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 14,
        "to": 14
      }
    }
  },
  {
    "name": "_left",
    "text": "const _left = <E, A>(): Prism<Either<E, A>, E> => l",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Prism<any, E>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 25,
        "to": 25
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\n\n/**\n * Create a `Traversal` from a `Traversable`\n *\n * @example\n * import { Lens, fromTraversable } from 'monocle-ts'\n * import { array } from 'fp-ts/lib/Array'\n *\n * interface Tweet {\n *   text: string\n * }\n *\n * interface Tweets {\n *   tweets: Tweet[]\n * }\n *\n * const tweetsLens = Lens.fromProp<Tweets>()('tweets')\n * const tweetTextLens = Lens.fromProp<Tweet>()('text')\n * const tweetTraversal = fromTraversable(array)<Tweet>()\n * const composedTraversal = tweetsLens.composeTraversal(tweetTraversal).composeLens(tweetTextLens)\n *\n * const tweet1: Tweet = { text: 'hello world' }\n * const tweet2: Tweet = { text: 'foobar' }\n * const model: Tweets = { tweets: [tweet1, tweet2] }\n *\n * const actual = composedTraversal.modify(text =>\n *   text\n *     .split('')\n *     .reverse()\n *     .join('')\n * )(model)\n *\n * assert.deepStrictEqual(actual, { tweets: [ { text: 'dlrow olleh' }, { text: 'raboof' } ] })\n *\n * @category constructor\n * @since 1.0.0\n */\nexport function fromTraversable<T extends URIS3>(T: Traversable3<T>): <U, L, A>() => Traversal<Kind3<T, U, L, A>, A>",
    "docs": "/**\n * Create a `Traversal` from a `Traversable`\n *\n * @example\n * import { Lens, fromTraversable } from 'monocle-ts'\n * import { array } from 'fp-ts/lib/Array'\n *\n * interface Tweet {\n *   text: string\n * }\n *\n * interface Tweets {\n *   tweets: Tweet[]\n * }\n *\n * const tweetsLens = Lens.fromProp<Tweets>()('tweets')\n * const tweetTextLens = Lens.fromProp<Tweet>()('text')\n * const tweetTraversal = fromTraversable(array)<Tweet>()\n * const composedTraversal = tweetsLens.composeTraversal(tweetTraversal).composeLens(tweetTextLens)\n *\n * const tweet1: Tweet = { text: 'hello world' }\n * const tweet2: Tweet = { text: 'foobar' }\n * const model: Tweets = { tweets: [tweet1, tweet2] }\n *\n * const actual = composedTraversal.modify(text =>\n *   text\n *     .split('')\n *     .reverse()\n *     .join('')\n * )(model)\n *\n * assert.deepStrictEqual(actual, { tweets: [ { text: 'dlrow olleh' }, { text: 'raboof' } ] })\n *\n * @category constructor\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1601,
        "to": 1601
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T extends URIS2>(T: Traversable2<T>): <L, A>() => Traversal<Kind2<T, L, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1602,
        "to": 1602
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T extends URIS>(T: Traversable1<T>): <A>() => Traversal<Kind<T, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1603,
        "to": 1603
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T>(T: Traversable<T>): <A>() => Traversal<HKT<T, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1604,
        "to": 1604
      }
    }
  },
  {
    "name": "fromTraversable",
    "text": "\nexport function fromTraversable<T>(T: Traversable<T>): <A>() => Traversal<HKT<T, A>, A> {\n  return <A>() =>\n    new Traversal(<F>(F: Applicative<F>) => {\n      const traverseF = T.traverse(F)\n      return (f: (a: A) => HKT<F, A>) => (s: HKT<T, A>) => traverseF(s, f)\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Traversal<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1605,
        "to": 1611
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a `Fold` from a `Foldable`\n *\n * @category constructor\n * @since 1.0.0\n */\nexport function fromFoldable<F extends URIS3>(F: Foldable3<F>): <U, L, A>() => Fold<Kind3<F, U, L, A>, A>",
    "docs": "/**\n * Create a `Fold` from a `Foldable`\n *\n * @category constructor\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1619,
        "to": 1619
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2>(F: Foldable2<F>): <L, A>() => Fold<Kind2<F, L, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1620,
        "to": 1620
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS>(F: Foldable1<F>): <A>() => Fold<Kind<F, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1621,
        "to": 1621
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F>(F: Foldable<F>): <A>() => Fold<HKT<F, A>, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1622,
        "to": 1622
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F>(F: Foldable<F>): <A>() => Fold<HKT<F, A>, A> {\n  return <A>() =>\n    new Fold<HKT<F, A>, A>(<M>(M: Monoid<M>) => {\n      const foldMapFM = F.foldMap(M)\n      return (f: (a: A) => M) => (s) => foldMapFM(s, f)\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Fold<any, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1623,
        "to": 1629
      }
    }
  },
  {
    "name": "atRecord",
    "text": "\n\n/**\n * @category constructor\n * @since 1.7.0\n */\nexport function atRecord<A = never>(): At<Record<string, A>, string, Option<A>> {\n  return new At(\n    (k) =>\n      new Lens(\n        (r) => R.lookup(k, r),\n        (oa) => (r) => {\n          if (isNone(oa)) {\n            return R.deleteAt(k)(r)\n          } else {\n            return R.insertAt(k, oa.value)(r)\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.7.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").At<Record<string, A>, string, any>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/At/Record.ts",
      "lines": {
        "from": 12,
        "to": 26
      }
    }
  },
  {
    "name": "atSet",
    "text": "\n\n/**\n * @category constructor\n * @since 1.2.0\n */\nexport function atSet<A = never>(E: Eq<A>): At<Set<A>, A, boolean> {\n  const elemE = S.elem(E)\n  const insertE = S.insert(E)\n  const removeE = S.remove(E)\n  return new At((at) => {\n    const insertEAt = insertE(at)\n    const removeEAt = removeE(at)\n    return new Lens(\n      (s) => elemE(at, s),\n      (a) => (s) => (a ? insertEAt(s) : removeEAt(s))\n    )\n  })\n}",
    "docs": "/**\n * @category constructor\n * @since 1.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").At<Set<A>, A, boolean>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/At/Set.ts",
      "lines": {
        "from": 12,
        "to": 24
      }
    }
  },
  {
    "name": "indexArray",
    "text": "\n\n/**\n * @category constructor\n * @since 1.2.0\n */\nexport function indexArray<A = never>(): Index<Array<A>, number, A> {\n  return new Index(\n    (i) =>\n      new Optional(\n        (as) => lookup(i, as),\n        (a) => (as) => {\n          const oas = updateAt(i, a)(as)\n          if (isNone(oas)) {\n            return as\n          } else {\n            return oas.value\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.2.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<A[], number, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/Array.ts",
      "lines": {
        "from": 12,
        "to": 27
      }
    }
  },
  {
    "name": "indexNonEmptyArray",
    "text": "\n\n/**\n * @category constructor\n * @since 1.5.0\n */\nexport function indexNonEmptyArray<A = never>(): Index<NonEmptyArray<A>, number, A> {\n  return new Index(\n    (i) =>\n      new Optional(\n        (s) => lookup(i, s),\n        (a) => (nea) => {\n          const onea = updateAt(i, a)(nea)\n          if (isNone(onea)) {\n            return nea\n          } else {\n            return onea.value\n          }\n        }\n      )\n  )\n}",
    "docs": "/**\n * @category constructor\n * @since 1.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<any, number, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/NonEmptyArray.ts",
      "lines": {
        "from": 13,
        "to": 28
      }
    }
  },
  {
    "name": "indexRecord",
    "text": "\n\n/**\n * @category constructor\n * @since 1.7.0\n */\nexport function indexRecord<A = never>(): Index<Record<string, A>, string, A> {\n  return Index.fromAt(atRecord<A>())\n}",
    "docs": "/**\n * @category constructor\n * @since 1.7.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/monocle-ts/src/index\").Index<Record<string, A>, string, A>"
      }
    },
    "module": "monocle-ts",
    "location": {
      "path": "src/Index/Record.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * @internal\n */\nexport function cons<A>(head: A, tail: LinkedList<A>): LinkedList<A> {\n  return {\n    type: 'Cons',\n    head,\n    tail,\n    length: tail.length + 1\n  }\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 36,
        "to": 43
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * @internal\n */\nexport function toArray<A>(list: LinkedList<A>): Array<A> {\n  const len = list.length\n  const r: Array<A> = new Array(len)\n  let l: LinkedList<A> = list\n  let i = 1\n  while (l.type !== 'Nil') {\n    r[len - i] = l.head\n    i++\n    l = l.tail\n  }\n  return r\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "list",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/express\").LinkedList<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 48,
        "to": 59
      }
    }
  },
  {
    "name": "toRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function toRequestHandler<I, O, E>(middleware: Middleware<I, O, E, void>): RequestHandler {\n  return (req, res, next) => exec(middleware, req, res, next)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "middleware",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 232,
        "to": 234
      }
    }
  },
  {
    "name": "toErrorRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function toErrorRequestHandler<I, O, E>(f: (err: unknown) => Middleware<I, O, E, void>): ErrorRequestHandler {\n  return (err, req, res, next) => exec(f(err), req, res, next)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(err: unknown) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 239,
        "to": 241
      }
    }
  },
  {
    "name": "fromRequestHandler",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromRequestHandler<I = StatusOpen, E = never, A = never>(\n  requestHandler: RequestHandler,\n  f: (req: Request) => A\n): Middleware<I, I, E, A> {\n  return c =>\n    rightTask(\n      () =>\n        new Promise(resolve => {\n          const { req, res } = c as ExpressConnection<I>\n          requestHandler(req, res, () => resolve([f(req), c]))\n        })\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "requestHandler",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(req: any) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/express.ts",
      "lines": {
        "from": 246,
        "to": 258
      }
    }
  },
  {
    "name": "gets",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function gets<I = StatusOpen, E = never, A = never>(f: (c: Connection<I>) => A): Middleware<I, I, E, A> {\n  return c => TE.right([f(c), c])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 207,
        "to": 209
      }
    }
  },
  {
    "name": "fromConnection",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromConnection<I = StatusOpen, E = never, A = never>(\n  f: (c: Connection<I>) => Either<E, A>\n): Middleware<I, I, E, A> {\n  return c =>\n    TE.fromEither(\n      pipe(\n        f(c),\n        E.map(a => [a, c])\n      )\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 214,
        "to": 224
      }
    }
  },
  {
    "name": "modifyConnection",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function modifyConnection<I, O, E>(f: (c: Connection<I>) => Connection<O>): Middleware<I, O, E, void> {\n  return c => TE.right([undefined, f(c)])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(c: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<O>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 229,
        "to": 231
      }
    }
  },
  {
    "name": "ichainW",
    "text": "\n\n/**\n * @since 0.6.1\n */\nexport function ichainW<A, O, Z, E, B>(\n  f: (a: A) => Middleware<O, Z, E, B>\n): <I, D>(ma: Middleware<I, O, D, A>) => Middleware<I, Z, D | E, B> {\n  return ma => ci =>\n    pipe(\n      ma(ci),\n      TEchainW(([a, co]) => f(a)(co))\n    )\n}",
    "docs": "/**\n * @since 0.6.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<O, Z, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, D>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, D, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, Z, E | D, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 275,
        "to": 283
      }
    }
  },
  {
    "name": "evalMiddleware",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function evalMiddleware<I, O, E, A>(ma: Middleware<I, O, E, A>, c: Connection<I>): TE.TaskEither<E, A> {\n  return pipe(\n    ma(c),\n    TE.map(([a]) => a)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
          }
        },
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 295,
        "to": 300
      }
    }
  },
  {
    "name": "execMiddleware",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function execMiddleware<I, O, E, A>(\n  ma: Middleware<I, O, E, A>,\n  c: Connection<I>\n): TE.TaskEither<E, Connection<O>> {\n  return pipe(\n    ma(c),\n    TE.map(([, c]) => c)\n  )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
          }
        },
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Connection<I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 305,
        "to": 313
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function orElse<E, I, O, M, A>(\n  f: (e: E) => Middleware<I, O, M, A>\n): (ma: Middleware<I, O, E, A>) => Middleware<I, O, M, A> {\n  return ma => c =>\n    pipe(\n      ma(c),\n      TE.orElse(e => f(e)(c))\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, M, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 318,
        "to": 326
      }
    }
  },
  {
    "name": "iof",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function iof<I = StatusOpen, O = StatusOpen, E = never, A = never>(a: A): Middleware<I, O, E, A> {\n  return c => TE.right([a, c as any])\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, O, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 331,
        "to": 333
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function tryCatch<I = StatusOpen, E = never, A = never>(\n  f: () => Promise<A>,\n  onRejected: (reason: unknown) => E\n): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.tryCatch(f, onRejected))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => Promise<A>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 338,
        "to": 343
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromTaskEither<I = StatusOpen, E = never, A = never>(fa: TE.TaskEither<E, A>): Middleware<I, I, E, A> {\n  return c =>\n    pipe(\n      fa,\n      TE.map(a => [a, c])\n    )\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 348,
        "to": 354
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function right<I = StatusOpen, E = never, A = never>(a: A): Middleware<I, I, E, A> {\n  return iof(a)\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 359,
        "to": 361
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function left<I = StatusOpen, E = never, A = never>(e: E): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.left(e))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 366,
        "to": 368
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function rightTask<I = StatusOpen, E = never, A = never>(fa: Task<A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.rightTask(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 373,
        "to": 375
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function leftTask<I = StatusOpen, E = never, A = never>(te: Task<E>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.leftTask(te))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "te",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 380,
        "to": 382
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function rightIO<I = StatusOpen, E = never, A = never>(fa: IO<A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.rightIO(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 387,
        "to": 389
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function leftIO<I = StatusOpen, E = never, A = never>(fe: IO<E>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.leftIO(fe))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fe",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 394,
        "to": 396
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @since 0.5.0\n */\nexport function fromIOEither<I = StatusOpen, E = never, A = never>(fa: IOEither<E, A>): Middleware<I, I, E, A> {\n  return fromTaskEither(TE.fromIOEither(fa))\n}",
    "docs": "/**\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 401,
        "to": 403
      }
    }
  },
  {
    "name": "status",
    "text": "\n\n/**\n * Returns a middleware that writes the response status\n *\n * @since 0.5.0\n */\nexport function status<E = never>(status: Status): Middleware<StatusOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setStatus(status))\n}",
    "docs": "/**\n * Returns a middleware that writes the response status\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "status",
          "type": {
            "__tag": "Other",
            "values": "100 | 101 | 102 | 103 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 421 | 422 | 423 | 424 | 425 | 426 | 428 | 429 | 431 | 451 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 410,
        "to": 412
      }
    }
  },
  {
    "name": "header",
    "text": "\n\n/**\n * Returns a middleware that writes the given header\n *\n * @since 0.5.0\n */\nexport function header<E = never>(name: string, value: string): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setHeader(name, value))\n}",
    "docs": "/**\n * Returns a middleware that writes the given header\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 419,
        "to": 421
      }
    }
  },
  {
    "name": "contentType",
    "text": "\n\n/**\n * Returns a middleware that sets the given `mediaType`\n *\n * @since 0.5.0\n */\nexport function contentType<E = never>(mediaType: MediaType): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return header('Content-Type', mediaType)\n}",
    "docs": "/**\n * Returns a middleware that sets the given `mediaType`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "mediaType",
          "type": {
            "__tag": "Other",
            "values": "\"application/x-www-form-urlencoded\" | \"application/json\" | \"application/javascript\" | \"application/octet-stream\" | \"application/xml\" | \"image/gif\" | \"image/jpeg\" | \"image/png\" | \"multipart/form-data\" | \"text/csv\" | \"text/html\" | \"text/plain\" | \"text/xml\""
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 428,
        "to": 430
      }
    }
  },
  {
    "name": "cookie",
    "text": "\n\n/**\n * Returns a middleware that sets the cookie `name` to `value`, with the given `options`\n *\n * @since 0.5.0\n */\nexport function cookie<E = never>(\n  name: string,\n  value: string,\n  options: CookieOptions\n): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.setCookie(name, value, options))\n}",
    "docs": "/**\n * Returns a middleware that sets the cookie `name` to `value`, with the given `options`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 437,
        "to": 443
      }
    }
  },
  {
    "name": "clearCookie",
    "text": "\n\n/**\n * Returns a middleware that clears the cookie `name`\n *\n * @since 0.5.0\n */\nexport function clearCookie<E = never>(\n  name: string,\n  options: CookieOptions\n): Middleware<HeadersOpen, HeadersOpen, E, void> {\n  return modifyConnection(c => c.clearCookie(name, options))\n}",
    "docs": "/**\n * Returns a middleware that clears the cookie `name`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 450,
        "to": 455
      }
    }
  },
  {
    "name": "closeHeaders",
    "text": "\n\n/**\n * Returns a middleware that changes the connection status to `BodyOpen`\n *\n * @since 0.5.0\n */\nexport function closeHeaders<E = never>(): Middleware<HeadersOpen, BodyOpen, E, void> {\n  return closedHeaders\n}",
    "docs": "/**\n * Returns a middleware that changes the connection status to `BodyOpen`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 464,
        "to": 466
      }
    }
  },
  {
    "name": "send",
    "text": "\n\n/**\n * Returns a middleware that sends `body` as response body\n *\n * @since 0.5.0\n */\nexport function send<E = never>(body: string): Middleware<BodyOpen, ResponseEnded, E, void> {\n  return modifyConnection(c => c.setBody(body))\n}",
    "docs": "/**\n * Returns a middleware that sends `body` as response body\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 473,
        "to": 475
      }
    }
  },
  {
    "name": "end",
    "text": "\n\n/**\n * Returns a middleware that ends the response without sending any response body\n *\n * @since 0.5.0\n */\nexport function end<E = never>(): Middleware<BodyOpen, ResponseEnded, E, void> {\n  return ended\n}",
    "docs": "/**\n * Returns a middleware that ends the response without sending any response body\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 484,
        "to": 486
      }
    }
  },
  {
    "name": "json",
    "text": "\n\n/**\n * Returns a middleware that sends `body` as JSON\n *\n * @since 0.5.0\n */\nexport function json<E>(\n  body: unknown,\n  onError: (reason: unknown) => E\n): Middleware<HeadersOpen, ResponseEnded, E, void> {\n  return pipe(\n    fromEither<HeadersOpen, E, string>(E.stringifyJSON(body, onError)),\n    ichain(json =>\n      pipe(\n        contentType<E>(MediaType.applicationJSON),\n        ichain(() => closeHeaders()),\n        ichain(() => send(json))\n      )\n    )\n  )\n}",
    "docs": "/**\n * Returns a middleware that sends `body` as JSON\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 493,
        "to": 507
      }
    }
  },
  {
    "name": "redirect",
    "text": "\n\n/**\n * Returns a middleware that sends a redirect to `uri`\n *\n * @since 0.5.0\n */\nexport function redirect<E = never>(uri: string): Middleware<StatusOpen, HeadersOpen, E, void> {\n  return pipe(\n    status(Status.Found),\n    ichain(() => header('Location', uri))\n  )\n}",
    "docs": "/**\n * Returns a middleware that sends a redirect to `uri`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "uri",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 514,
        "to": 519
      }
    }
  },
  {
    "name": "pipeStream",
    "text": "\n\n/**\n * Returns a middleware that pipes a stream to the response object.\n *\n * @since 0.6.2\n */\nexport function pipeStream<E>(stream: Readable): Middleware<BodyOpen, ResponseEnded, E, void> {\n  return modifyConnection(c => c.pipeStream(stream))\n}",
    "docs": "/**\n * Returns a middleware that pipes a stream to the response object.\n *\n * @since 0.6.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "stream",
          "type": {
            "__tag": "Other",
            "values": "import(\"stream\").Readable"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 526,
        "to": 528
      }
    }
  },
  {
    "name": "decodeParam",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getParams()[name]`\n *\n * @since 0.5.0\n */\nexport function decodeParam<E, A>(\n  name: string,\n  f: (input: unknown) => Either<E, A>\n): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => {\n    const params = c.getParams()\n    return f(isUnknownRecord(params) ? params[name] : undefined)\n  })\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getParams()[name]`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 537,
        "to": 545
      }
    }
  },
  {
    "name": "decodeParams",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getParams()`\n *\n * @since 0.5.0\n */\nexport function decodeParams<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getParams()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getParams()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 552,
        "to": 554
      }
    }
  },
  {
    "name": "decodeQuery",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getQuery()`\n *\n * @since 0.5.0\n */\nexport function decodeQuery<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getQuery()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getQuery()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 561,
        "to": 563
      }
    }
  },
  {
    "name": "decodeBody",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getBody()`\n *\n * @since 0.5.0\n */\nexport function decodeBody<E, A>(f: (input: unknown) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getBody()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getBody()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 570,
        "to": 572
      }
    }
  },
  {
    "name": "decodeMethod",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getMethod()`\n *\n * @since 0.5.0\n */\nexport function decodeMethod<E, A>(f: (method: string) => Either<E, A>): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getMethod()))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getMethod()`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(method: string) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 579,
        "to": 581
      }
    }
  },
  {
    "name": "decodeHeader",
    "text": "\n\n/**\n * Returns a middleware that tries to decode `connection.getHeader(name)`\n *\n * @since 0.5.0\n */\nexport function decodeHeader<E, A>(\n  name: string,\n  f: (input: unknown) => Either<E, A>\n): Middleware<StatusOpen, StatusOpen, E, A> {\n  return fromConnection(c => f(c.getHeader(name)))\n}",
    "docs": "/**\n * Returns a middleware that tries to decode `connection.getHeader(name)`\n *\n * @since 0.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 588,
        "to": 593
      }
    }
  },
  {
    "name": "TEchainW",
    "text": "const TEchainW = <A, E2, B>(f: (a: A) => TE.TaskEither<E2, B>) => <E1>(\n  ma: TE.TaskEither<E1, A>\n): TE.TaskEither<E1 | E2, B> =>\n  pipe(\n    ma,\n    T.chain(e => (E.isLeft(e) ? TE.left<E1 | E2, B>(e.left) : f(e.right)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(ma: any) => any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 264,
        "to": 270
      }
    }
  },
  {
    "name": "bindTo",
    "text": "const bindTo = <N extends string>(\n  name: N\n): (<I, E, A>(fa: Middleware<I, I, E, A>) => Middleware<I, I, E, { [K in N]: A }>) => map(bindTo_(name))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, { [K in N]: A; }>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 619,
        "to": 621
      }
    }
  },
  {
    "name": "bindW",
    "text": "const bindW = <N extends string, I, A, E2, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Middleware<I, I, E2, B>\n): (<E1>(\n  fa: Middleware<I, I, E1, A>\n) => Middleware<I, I, E1 | E2, { [K in keyof A | N]: K extends keyof A ? A[K] : B }>) =>\n  ichainW(a =>\n    pipe(\n      f(a),\n      map(b => bind_(a, name, b))\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "Exclude<N, keyof A>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E2 | E1, { [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 626,
        "to": 637
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function fromTaskEither<R, I = H.StatusOpen, E = never, A = never>(\n  fa: TE.TaskEither<E, A>\n): ReaderMiddleware<R, I, I, E, A> {\n  return () => H.fromTaskEither(fa)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 50,
        "to": 54
      }
    }
  },
  {
    "name": "fromReaderTaskEither",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function fromReaderTaskEither<R, I = H.StatusOpen, E = never, A = never>(\n  fa: RTE.ReaderTaskEither<R, E, A>\n): ReaderMiddleware<R, I, I, E, A> {\n  return r => H.fromTaskEither(fa(r))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 59,
        "to": 63
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function left<R, I = H.StatusOpen, E = never, A = never>(e: E): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.left(e))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function rightTask<R, I = H.StatusOpen, E = never, A = never>(fa: Task<A>): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.rightTask(fa))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function leftTask<R, I = H.StatusOpen, E = never, A = never>(te: Task<E>): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.leftTask(te))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "te",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 94,
        "to": 96
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function rightIO<R, I = H.StatusOpen, E = never, A = never>(fa: IO<A>): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.rightIO(fa))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function leftIO<R, I = H.StatusOpen, E = never, A = never>(fe: IO<E>): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.leftIO(fe))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fe",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 108,
        "to": 110
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function fromIOEither<R, I = H.StatusOpen, E = never, A = never>(\n  fa: IOEither<E, A>\n): ReaderMiddleware<R, I, I, E, A> {\n  return fromMiddleware(H.fromIOEither(fa))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 115,
        "to": 119
      }
    }
  },
  {
    "name": "leftReader",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function leftReader<R, I = H.StatusOpen, E = never, A = never>(\n  me: Reader<R, E>\n): ReaderMiddleware<R, I, I, E, A> {\n  return r => H.left(me(r))\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 131,
        "to": 135
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function orElse<R, E, I, O, M, A>(\n  f: (e: E) => ReaderMiddleware<R, I, O, M, A>\n): (ma: ReaderMiddleware<R, I, O, E, A>) => ReaderMiddleware<R, I, O, M, A> {\n  return ma => r => c =>\n    pipe(\n      ma(r)(c),\n      TE.orElse(e => f(e)(r)(c))\n    )\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, O, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, O, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, O, M, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 151,
        "to": 159
      }
    }
  },
  {
    "name": "status",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function status<R, E = never>(status: H.Status): ReaderMiddleware<R, H.StatusOpen, H.HeadersOpen, E, void> {\n  return () => H.status(status)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "status",
          "type": {
            "__tag": "Other",
            "values": "100 | 101 | 102 | 103 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 421 | 422 | 423 | 424 | 425 | 426 | 428 | 429 | 431 | 451 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 | 508 | 510 | 511"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 171,
        "to": 173
      }
    }
  },
  {
    "name": "header",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function header<R, E = never>(\n  name: string,\n  value: string\n): ReaderMiddleware<R, H.HeadersOpen, H.HeadersOpen, E, void> {\n  return () => H.header(name, value)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 178,
        "to": 183
      }
    }
  },
  {
    "name": "contentType",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function contentType<R, E = never>(\n  mediaType: H.MediaType\n): ReaderMiddleware<R, H.HeadersOpen, H.HeadersOpen, E, void> {\n  return header('Content-Type', mediaType)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "mediaType",
          "type": {
            "__tag": "Other",
            "values": "\"application/x-www-form-urlencoded\" | \"application/json\" | \"application/javascript\" | \"application/octet-stream\" | \"application/xml\" | \"image/gif\" | \"image/jpeg\" | \"image/png\" | \"multipart/form-data\" | \"text/csv\" | \"text/html\" | \"text/plain\" | \"text/xml\""
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 188,
        "to": 192
      }
    }
  },
  {
    "name": "cookie",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function cookie<R, E = never>(\n  name: string,\n  value: string,\n  options: H.CookieOptions\n): ReaderMiddleware<R, H.HeadersOpen, H.HeadersOpen, E, void> {\n  return () => H.cookie(name, value, options)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 197,
        "to": 203
      }
    }
  },
  {
    "name": "clearCookie",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function clearCookie<R, E = never>(\n  name: string,\n  options: H.CookieOptions\n): ReaderMiddleware<R, H.HeadersOpen, H.HeadersOpen, E, void> {\n  return () => H.clearCookie(name, options)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "options",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").CookieOptions"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 208,
        "to": 213
      }
    }
  },
  {
    "name": "closeHeaders",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function closeHeaders<R, E = never>(): ReaderMiddleware<R, H.HeadersOpen, H.BodyOpen, E, void> {\n  return closedHeaders\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 220,
        "to": 222
      }
    }
  },
  {
    "name": "send",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function send<R, E = never>(body: string): ReaderMiddleware<R, H.BodyOpen, H.ResponseEnded, E, void> {\n  return () => H.send(body)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 227,
        "to": 229
      }
    }
  },
  {
    "name": "end",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function end<R, E = never>(): ReaderMiddleware<R, H.BodyOpen, H.ResponseEnded, E, void> {\n  return H.end\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").BodyOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 234,
        "to": 236
      }
    }
  },
  {
    "name": "json",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function json<R, E>(\n  body: unknown,\n  onError: (reason: unknown) => E\n): ReaderMiddleware<R, H.HeadersOpen, H.ResponseEnded, E, void> {\n  return () => H.json(body, onError)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "body",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").ResponseEnded, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 241,
        "to": 246
      }
    }
  },
  {
    "name": "redirect",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function redirect<R, E = never>(uri: string): ReaderMiddleware<R, H.StatusOpen, H.HeadersOpen, E, void> {\n  return () => H.redirect(uri)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "uri",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").HeadersOpen, E, void>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 251,
        "to": 253
      }
    }
  },
  {
    "name": "decodeParam",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeParam<R, E, A>(\n  name: string,\n  f: (input: unknown) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeParam(name, f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 258,
        "to": 263
      }
    }
  },
  {
    "name": "decodeParams",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeParams<R, E, A>(\n  f: (input: unknown) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeParams(f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 268,
        "to": 272
      }
    }
  },
  {
    "name": "decodeQuery",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeQuery<R, E, A>(\n  f: (input: unknown) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeQuery(f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 277,
        "to": 281
      }
    }
  },
  {
    "name": "decodeBody",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeBody<R, E, A>(\n  f: (input: unknown) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeBody(f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 286,
        "to": 290
      }
    }
  },
  {
    "name": "decodeMethod",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeMethod<R, E, A>(\n  f: (method: string) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeMethod(f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(method: string) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 295,
        "to": 299
      }
    }
  },
  {
    "name": "decodeHeader",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function decodeHeader<R, E, A>(\n  name: string,\n  f: (input: unknown) => E.Either<E, A>\n): ReaderMiddleware<R, H.StatusOpen, H.StatusOpen, E, A> {\n  return () => H.decodeHeader(name, f)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(input: unknown) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").StatusOpen, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 304,
        "to": 309
      }
    }
  },
  {
    "name": "iof",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function iof<R, I = H.StatusOpen, O = H.StatusOpen, E = never, A = never>(\n  a: A\n): ReaderMiddleware<R, I, O, E, A> {\n  return () => H.iof(a)\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, O, E, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 442,
        "to": 446
      }
    }
  },
  {
    "name": "ichainW",
    "text": "\n\n/**\n * @since 0.6.3\n */\nexport function ichainW<R2, A, O, Z, E2, B>(\n  f: (a: A) => ReaderMiddleware<R2, O, Z, E2, B>\n): <R1, I, E1>(ma: ReaderMiddleware<R1, I, O, E1, A>) => ReaderMiddleware<R1 & R2, I, Z, E1 | E2, B> {\n  return ma => r => ci =>\n    pipe(\n      ma(r)(ci),\n      H.TEchainW(([a, co]) => f(a)(r)(co))\n    )\n}",
    "docs": "/**\n * @since 0.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R2, O, Z, E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, I, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R1, I, O, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R1 & R2, I, Z, E2 | E1, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 478,
        "to": 486
      }
    }
  },
  {
    "name": "orElseW",
    "text": "const orElseW = <R2, E, I, O, M, A>(f: (e: E) => ReaderMiddleware<R2, I, O, M, A>) => <R1, B>(\n  ma: ReaderMiddleware<R1, I, O, E, B>\n): ReaderMiddleware<R2 & R1, I, O, M, A | B> => pipe(ma, orElse<R1 & R2, E, I, O, M, A | B>(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R2, I, O, M, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, B>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R1, I, O, E, B>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R2 & R1, I, O, M, A | B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 164,
        "to": 166
      }
    }
  },
  {
    "name": "bindTo",
    "text": "const bindTo = <N extends string>(\n  name: N\n): (<R, I, E, A>(fa: ReaderMiddleware<R, I, I, E, A>) => ReaderMiddleware<R, I, I, E, { [K in N]: A }>) =>\n  map(bindTo_(name))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, I, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, { [K in N]: A; }>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 335,
        "to": 338
      }
    }
  },
  {
    "name": "bindW",
    "text": "const bindW = <N extends string, R, I, A, E2, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => ReaderMiddleware<R, I, I, E2, B>\n): (<E1>(\n  fa: ReaderMiddleware<R, I, I, E1, A>\n) => ReaderMiddleware<R, I, I, E1 | E2, { [K in keyof A | N]: K extends keyof A ? A[K] : B }>) =>\n  ichainW(a =>\n    pipe(\n      f(a),\n      map(b => bind_(a, name, b))\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "Exclude<N, keyof A>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E2 | E1, { [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 343,
        "to": 354
      }
    }
  },
  {
    "name": "map",
    "text": "const map = <A, B>(f: (a: A) => B) => <R, I, E>(\n  fa: ReaderMiddleware<R, I, I, E, A>\n): ReaderMiddleware<R, I, I, E, B> => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, I, E>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 387,
        "to": 389
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap = <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R, I>(\n  fa: ReaderMiddleware<R, I, I, E, A>\n): ReaderMiddleware<R, I, I, G, B> => _bimap(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, I>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, G, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 397,
        "to": 399
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft = <E, G>(f: (e: E) => G) => <R, I, A>(\n  fa: ReaderMiddleware<R, I, I, E, A>\n): ReaderMiddleware<R, I, I, G, A> => _mapLeft(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, I, A>(fa: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, G, A>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 407,
        "to": 409
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap = <R, I, E, A>(fa: ReaderMiddleware<R, I, I, E, A>) => <B>(\n  fab: ReaderMiddleware<R, I, I, E, (a: A) => B>\n): ReaderMiddleware<R, I, I, E, B> => T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 417,
        "to": 419
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain = <R, I, E, A, B>(f: (a: A) => ReaderMiddleware<R, I, I, E, B>) => (\n  ma: ReaderMiddleware<R, I, I, E, A>\n): ReaderMiddleware<R, I, I, E, B> => T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 454,
        "to": 456
      }
    }
  },
  {
    "name": "chainMiddlewareK",
    "text": "const chainMiddlewareK = <R, I, E, A, B>(f: (a: A) => H.Middleware<I, I, E, B>) => (\n  ma: ReaderMiddleware<R, I, I, E, A>\n): ReaderMiddleware<R, I, I, E, B> => T.chain(ma, a => fromMiddleware(f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/index\").Middleware<I, I, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, B>"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 491,
        "to": 493
      }
    }
  },
  {
    "name": "chainTaskEitherK",
    "text": "const chainTaskEitherK: <E, A, B>(\n  f: (a: A) => TE.TaskEither<E, B>\n) => <R, I>(ma: ReaderMiddleware<R, I, I, E, A>) => ReaderMiddleware<R, I, I, E, B> = f => ma => r =>\n  pipe(\n    ma(r),\n    H.chain(a => H.fromTaskEither(f(a)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, I>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => (r: R) => any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 512,
        "to": 518
      }
    }
  },
  {
    "name": "chainReaderTaskEitherK",
    "text": "const chainReaderTaskEitherK: <R, E, A, B>(\n  f: (a: A) => RTE.ReaderTaskEither<R, E, B>\n) => <I>(ma: ReaderMiddleware<R, I, I, E, A>) => ReaderMiddleware<R, I, I, E, B> = f => ma => r =>\n  pipe(\n    ma(r),\n    H.chain(a => H.fromTaskEither(f(a)(r)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(ma: import(\"/home/bb8/dev/tsearch/projects/hyper-ts/src/ReaderMiddleware\").ReaderMiddleware<R, I, I, E, A>) => (r: R) => any"
      }
    },
    "module": "hyper-ts",
    "location": {
      "path": "src/ReaderMiddleware.ts",
      "lines": {
        "from": 530,
        "to": 536
      }
    }
  },
  {
    "name": "copyPackageJson",
    "text": "const copyPackageJson: Build<void> = (C) =>\n  pipe(\n    C.readFile(PKG),\n    TE.chain((s) => TE.fromEither(E.parseJSON(s, E.toError))),\n    TE.map((v) => {\n      const clone = Object.assign({}, v as any)\n\n      delete clone.scripts\n      delete clone.files\n      delete clone.devDependencies\n\n      return clone\n    }),\n    TE.chain((json) => C.writeFile(path.join(OUTPUT_FOLDER, PKG), JSON.stringify(json, null, 2)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 15,
        "to": 29
      }
    }
  },
  {
    "name": "copyFiles",
    "text": "const copyFiles: Build<ReadonlyArray<void>> = (C) =>\n  pipe(\n    FILES,\n    A.traverse(TE.taskEither)((from) => C.copyFile(from, path.resolve(OUTPUT_FOLDER, from)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 33,
        "to": 37
      }
    }
  },
  {
    "name": "makeModules",
    "text": "const makeModules: Build<void> = (C) =>\n  pipe(\n    C.glob(`${OUTPUT_FOLDER}/lib/**/*.js`),\n    TE.map(getModules),\n    TE.chain(traverse(makeSingleModule(C))),\n    TE.map(() => undefined)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 41,
        "to": 47
      }
    }
  },
  {
    "name": "run",
    "text": "\n\nexport function run<A>(eff: TaskEither<Error, A>): void {\n  eff()\n    .then(\n      fold(\n        (e) => {\n          throw e\n        },\n        (_) => {\n          process.exitCode = 0\n        }\n      )\n    )\n    .catch((e) => {\n      console.error(e) // tslint:disable-line no-console\n\n      process.exitCode = 1\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eff",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "scripts/run.ts",
      "lines": {
        "from": 4,
        "to": 21
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "const fromOptionK: <A extends Array<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => ArrayOption<B> = (\n  f\n) => (...a) => fromOption(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 48,
        "to": 50
      }
    }
  },
  {
    "name": "fold",
    "text": "const fold: <A, B>(onNone: () => Array<B>, onSome: (a: A) => Array<B>) => (as: ArrayOption<A>) => Array<B> = (\n  onNone,\n  onSome\n) => (as) => T.fold(as, onNone, onSome)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => B[]"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 72,
        "to": 75
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "const getOrElse: <A>(onNone: () => Array<A>) => (as: ArrayOption<A>) => Array<A> = (onNone) => (as) =>\n  T.getOrElse(as, onNone)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 81,
        "to": 82
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: ArrayOption<A>) => ArrayOption<B> = (f) => (fa) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: ArrayOption<A>) => <B>(fab: ArrayOption<(a: A) => B>) => ArrayOption<B> = (fa) => (fab) =>\n  T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<(a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 98,
        "to": 99
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <B>(fb: ArrayOption<B>) => <A>(fa: ArrayOption<A>): ArrayOption<A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 105,
        "to": 110
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: ArrayOption<B>) => <A>(fa: ArrayOption<A>): ArrayOption<B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 116,
        "to": 121
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: ArrayOption<A>) => ArrayOption<B> = (f) =>\n  chain(fromOptionK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 133,
        "to": 134
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => ArrayOption<B>) => (fa: ArrayOption<A>) => ArrayOption<B> = (f) => (fa) =>\n  T.chain(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 140,
        "to": 141
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => ArrayOption<B>) => (ma: ArrayOption<A>) => ArrayOption<A> = (f) => (ma) =>\n  T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 147,
        "to": 148
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: ArrayOption<ArrayOption<A>>) => ArrayOption<A> = (mma) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 154,
        "to": 154
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => ArrayOption<A>) => (fa: ArrayOption<A>) => ArrayOption<A> = (that) => (fa) =>\n  T.alt(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ArrayOption\").ArrayOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 160,
        "to": 161
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero: Alternative1<URI>['zero'] = () => empty",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ArrayOption.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\n\n/**\n * Like `array.traverse` but actions are batched in chunks.\n * You can use `Array.chunksOf` to provide the `as` argument.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { batchTraverse } from 'fp-ts-contrib/batchTraverse'\n *\n * async function processInStrictSequence() {\n *   const numbers = [1, 2, 3, 4];\n *   const asyncTransform = (n: number): T.Task<number> => T.of(n + 1);\n *   const result = await pipe(\n *     numbers,\n *     A.chunksOf(2),\n *     // process asyncTransform in strict sequence with chunkSize 2:\n *     // next asyncTransform only starts after previous is finished\n *     (chunks) =>  batchTraverse(T.task)(chunks, asyncTransform),\n *   )();\n *   assert.deepStrictEqual(result, [2,3,4,5]);\n * }\n *\n * processInStrictSequence();\n *\n * @since 0.1.0\n */\nexport function batchTraverse<M extends URIS3>(\n  M: Monad3<M>\n): <U, L, A, B>(as: Array<Array<A>>, f: (a: A) => Kind3<M, U, L, B>) => Kind3<M, U, L, Array<B>>",
    "docs": "/**\n * Like `array.traverse` but actions are batched in chunks.\n * You can use `Array.chunksOf` to provide the `as` argument.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { batchTraverse } from 'fp-ts-contrib/batchTraverse'\n *\n * async function processInStrictSequence() {\n *   const numbers = [1, 2, 3, 4];\n *   const asyncTransform = (n: number): T.Task<number> => T.of(n + 1);\n *   const result = await pipe(\n *     numbers,\n *     A.chunksOf(2),\n *     // process asyncTransform in strict sequence with chunkSize 2:\n *     // next asyncTransform only starts after previous is finished\n *     (chunks) =>  batchTraverse(T.task)(chunks, asyncTransform),\n *   )();\n *   assert.deepStrictEqual(result, [2,3,4,5]);\n * }\n *\n * processInStrictSequence();\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 35,
        "to": 37
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS2>(\n  M: Monad2<M>\n): <L, A, B>(as: Array<Array<A>>, f: (a: A) => Kind2<M, L, B>) => Kind2<M, L, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 38,
        "to": 40
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS2, L>(\n  M: Monad2C<M, L>\n): <A, B>(as: Array<Array<A>>, f: (a: A) => Kind2<M, L, B>) => Kind2<M, L, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 41,
        "to": 43
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(as: Array<Array<A>>, f: (a: A) => Kind<M, B>) => Kind<M, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 44,
        "to": 46
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M>(M: Monad<M>): <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) => HKT<M, Array<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "batchTraverse",
    "text": "\nexport function batchTraverse<M>(M: Monad<M>): <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) => HKT<M, Array<B>> {\n  const traverseM = array.traverse(M)\n  return <A, B>(as: Array<Array<A>>, f: (a: A) => HKT<M, B>) =>\n    as.reduce(\n      (mbs: HKT<M, Array<B>>, chunk: Array<A>) =>\n        M.chain(mbs, (bs) =>\n          M.map(traverseM(chunk, f), (chunk) => {\n            bs.push(...chunk)\n            return bs\n          })\n        ),\n      M.of([])\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(as: A[][], f: (a: A) => any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/batchTraverse.ts",
      "lines": {
        "from": 48,
        "to": 61
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\n\n/**\n * Execute an action repeatedly until the `Option` condition returns a `None`. Collects results into an arbitrary `Alt`\n * value, such as a `Array` or `NonEmptyArray`.\n *\n * @example\n * import { array } from 'fp-ts/Array'\n * import * as E from 'fp-ts/Either'\n * import { flow } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as TE from 'fp-ts/TaskEither'\n * import { collectUntil } from 'fp-ts-contrib/collectUntil'\n *\n * interface Page {\n *   rows: Array<string>\n *   current_page: number\n *   last_page: number\n * }\n *\n * // fake API\n * function fetchPage(current_page: number): TE.TaskEither<string, Page> {\n *   if (current_page <= 3) {\n *     return TE.right({\n *       rows: [`row1-Page${current_page}`, `row2-Page${current_page}`],\n *       current_page: current_page,\n *       last_page: 3\n *     })\n *   } else {\n *     return TE.left('invalid page')\n *   }\n * }\n *\n * const getNextInput = (page: Page): O.Option<number> =>\n *   page.current_page < page.last_page ? O.some(page.current_page + 1) : O.none\n *\n * const collectRows = collectUntil(\n *   TE.taskEither,\n *   array\n * )(\n *   flow(\n *     fetchPage,\n *     TE.map(page => [page.rows, getNextInput(page)])\n *   )\n * )\n *\n * collectRows(1)().then(rows => {\n *   assert.deepStrictEqual(\n *     rows,\n *     E.right(['row1-Page1', 'row2-Page1', 'row1-Page2', 'row2-Page2', 'row1-Page3', 'row2-Page3'])\n *   )\n * })\n *\n * @since 0.1.8\n */\nexport function collectUntil<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Alt1<F>\n): <I, E, A>(f: (i: I) => Kind2<M, E, [Kind<F, A>, Option<I>]>) => (i: I) => Kind2<M, E, Kind<F, A>>",
    "docs": "/**\n * Execute an action repeatedly until the `Option` condition returns a `None`. Collects results into an arbitrary `Alt`\n * value, such as a `Array` or `NonEmptyArray`.\n *\n * @example\n * import { array } from 'fp-ts/Array'\n * import * as E from 'fp-ts/Either'\n * import { flow } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as TE from 'fp-ts/TaskEither'\n * import { collectUntil } from 'fp-ts-contrib/collectUntil'\n *\n * interface Page {\n *   rows: Array<string>\n *   current_page: number\n *   last_page: number\n * }\n *\n * // fake API\n * function fetchPage(current_page: number): TE.TaskEither<string, Page> {\n *   if (current_page <= 3) {\n *     return TE.right({\n *       rows: [`row1-Page${current_page}`, `row2-Page${current_page}`],\n *       current_page: current_page,\n *       last_page: 3\n *     })\n *   } else {\n *     return TE.left('invalid page')\n *   }\n * }\n *\n * const getNextInput = (page: Page): O.Option<number> =>\n *   page.current_page < page.last_page ? O.some(page.current_page + 1) : O.none\n *\n * const collectRows = collectUntil(\n *   TE.taskEither,\n *   array\n * )(\n *   flow(\n *     fetchPage,\n *     TE.map(page => [page.rows, getNextInput(page)])\n *   )\n * )\n *\n * collectRows(1)().then(rows => {\n *   assert.deepStrictEqual(\n *     rows,\n *     E.right(['row1-Page1', 'row2-Page1', 'row1-Page2', 'row2-Page2', 'row1-Page3', 'row2-Page3'])\n *   )\n * })\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 64,
        "to": 67
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M extends URIS, F extends URIS2>(\n  M: Monad1<M>,\n  F: Alt2<F>\n): <I, E, A>(f: (i: I) => Kind<M, [Kind2<F, E, A>, Option<I>]>) => (i: I) => Kind<M, Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 68,
        "to": 71
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Alt1<F>\n): <I, A>(f: (i: I) => Kind<M, [Kind<F, A>, Option<I>]>) => (i: I) => Kind<M, Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 72,
        "to": 75
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M, F>(\n  M: Monad<M>,\n  F: Alt<F>\n): <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>) => (i: I) => HKT<M, HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 76,
        "to": 79
      }
    }
  },
  {
    "name": "collectUntil",
    "text": "\nexport function collectUntil<M, F>(\n  M: Monad<M>,\n  F: Alt<F>\n): <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>) => (i: I) => HKT<M, HKT<F, A>> {\n  return <I, A>(f: (i: I) => HKT<M, [HKT<F, A>, Option<I>]>): ((i: I) => HKT<M, HKT<F, A>>) => {\n    const go = (mfa: HKT<M, [HKT<F, A>, Option<I>]>): HKT<M, HKT<F, A>> => {\n      return M.chain(mfa, ([fx, oi]) => {\n        return pipe(\n          oi,\n          fold(\n            () => M.of(fx),\n            (i) => go(M.map(f(i), ([fy, oi]) => [F.alt(fx, () => fy), oi]))\n          )\n        )\n      })\n    }\n    return flow(f, go)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(f: (i: I) => any) => (i: I) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/collectUntil.ts",
      "lines": {
        "from": 80,
        "to": 98
      }
    }
  },
  {
    "name": "Do",
    "text": "\n\n/**\n * This function provides a simulation of Haskell do notation. The `bind` / `bindL` functions contributes to a threaded\n * scope that is available to each subsequent step. The `do` / `doL` functions can be used to perform computations that\n * add nothing to the scope. The `return` function lifts the given callback to the monad context. Finally the `done`\n * function returns the scope.\n *\n * @example\n * import { option, some } from 'fp-ts/Option'\n * import { Do } from 'fp-ts-contrib/Do'\n *\n * // x: Option<number>\n * const x = Do(option) // <- a monad instance\n *   .bindL('foo', () => some('bar'))\n *   .bindL('baz', () => some(4))\n *   .return(({ foo, baz }) => foo.length + baz)\n *\n * assert.deepStrictEqual(x, some(7))\n *\n * @since 0.0.2\n */\nexport function Do<M extends URIS3>(M: Monad3<M>): Do3<M, {}>",
    "docs": "/**\n * This function provides a simulation of Haskell do notation. The `bind` / `bindL` functions contributes to a threaded\n * scope that is available to each subsequent step. The `do` / `doL` functions can be used to perform computations that\n * add nothing to the scope. The `return` function lifts the given callback to the monad context. Finally the `done`\n * function returns the scope.\n *\n * @example\n * import { option, some } from 'fp-ts/Option'\n * import { Do } from 'fp-ts-contrib/Do'\n *\n * // x: Option<number>\n * const x = Do(option) // <- a monad instance\n *   .bindL('foo', () => some('bar'))\n *   .bindL('baz', () => some(4))\n *   .return(({ foo, baz }) => foo.length + baz)\n *\n * assert.deepStrictEqual(x, some(7))\n *\n * @since 0.0.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do3<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 227,
        "to": 227
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS2>(M: Monad2<M>): Do2<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do2<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 228,
        "to": 228
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS2, L>(M: Monad2C<M, L>): Do2C<M, {}, L>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do2C<M, {}, L>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 229,
        "to": 229
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M extends URIS>(M: Monad1<M>): Do1<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do1<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 230,
        "to": 230
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M>(M: Monad<M>): Do0<M, {}>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Do\").Do0<M, {}>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 231,
        "to": 231
      }
    }
  },
  {
    "name": "Do",
    "text": "\nexport function Do<M>(M: Monad<M>): any {\n  return new DoClass(M, M.of(init))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Do.ts",
      "lines": {
        "from": 232,
        "to": 234
      }
    }
  },
  {
    "name": "filterA",
    "text": "\n\n/**\n * This generalizes the array-based `filter` function.\n *\n * @example\n * import { io, IO } from 'fp-ts/IO'\n * import { filterA } from 'fp-ts-contrib/filterA'\n *\n * const filterAIO = filterA(io)\n *\n * const p = (n: number): IO<boolean> => io.of(n % 2 === 0)\n *\n * assert.deepStrictEqual(filterAIO(p)([1, 2, 3, 4, 5])(), [2, 4])\n *\n * @since 0.1.15\n */\nexport function filterA<F extends URIS4>(\n  F: Applicative4<F>\n): <S, R, E, A>(p: (a: A) => Kind4<F, S, R, E, boolean>) => (as: Array<A>) => Kind4<F, S, R, E, Array<A>>",
    "docs": "/**\n * This generalizes the array-based `filter` function.\n *\n * @example\n * import { io, IO } from 'fp-ts/IO'\n * import { filterA } from 'fp-ts-contrib/filterA'\n *\n * const filterAIO = filterA(io)\n *\n * const p = (n: number): IO<boolean> => io.of(n % 2 === 0)\n *\n * assert.deepStrictEqual(filterAIO(p)([1, 2, 3, 4, 5])(), [2, 4])\n *\n * @since 0.1.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 31,
        "to": 33
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A>(p: (a: A) => Kind3<F, R, E, boolean>) => (as: Array<A>) => Kind3<F, R, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 34,
        "to": 36
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A>(p: (a: A) => Kind2<F, E, boolean>) => (as: Array<A>) => Kind2<F, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 37,
        "to": 39
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A>(p: (a: A) => Kind2<F, E, boolean>) => (as: Array<A>) => Kind2<F, E, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 40,
        "to": 42
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F extends URIS>(\n  F: Applicative1<F>\n): <A>(p: (a: A) => Kind<F, boolean>) => (as: Array<A>) => Kind<F, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 43,
        "to": 45
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F>(F: Applicative<F>): <A>(p: (a: A) => HKT<F, boolean>) => (as: Array<A>) => HKT<F, Array<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 46,
        "to": 46
      }
    }
  },
  {
    "name": "filterA",
    "text": "\nexport function filterA<F>(F: Applicative<F>): <A>(p: (a: A) => HKT<F, boolean>) => (as: Array<A>) => HKT<F, Array<A>> {\n  const wither = A.array.wither(F)\n  return (p) => (as) => wither(as, (a) => F.map(p(a), (b) => (b ? O.some(a) : O.none)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(p: (a: A) => any) => (as: A[]) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/filterA.ts",
      "lines": {
        "from": 47,
        "to": 50
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\n\n/**\n * Perform folding of a free monad using given natural transformation as an interpreter\n *\n * @category destructors\n * @since 0.1.3\n */\nexport function foldFree<M extends URIS3>(M: Monad3<M>): FoldFree3<M>",
    "docs": "/**\n * Perform folding of a free monad using given natural transformation as an interpreter\n *\n * @category destructors\n * @since 0.1.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree3<M>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 87,
        "to": 87
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS2>(M: Monad2<M>): FoldFree2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree2<M>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 88,
        "to": 88
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS2, L>(M: Monad2C<M, L>): FoldFree2C<M, L>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").FoldFree2C<M, L>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 89,
        "to": 89
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M extends URIS>(\n  M: Monad1<M>\n): <F extends URIS, A>(nt: <X>(fa: Kind<F, X>) => Kind<M, X>, fa: Free<F, A>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F extends any, A>(nt: <X>(fa: any) => any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 90,
        "to": 92
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M>(M: Monad<M>): <F, A>(nt: <X>(fa: HKT<F, X>) => HKT<M, X>, fa: Free<F, A>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F, A>(nt: <X>(fa: any) => any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 93,
        "to": 93
      }
    }
  },
  {
    "name": "foldFree",
    "text": "\nexport function foldFree<M>(M: Monad<M>): <F, A>(nt: any, fa: Free<F, A>) => HKT<M, A> {\n  return (nt, fa) => {\n    if (isPure(fa)) {\n      return M.of(fa.value)\n    } else {\n      return M.chain(nt(fa.fx), (x) => foldFree(M)(nt, fa.f(x)))\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F, A>(nt: any, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 94,
        "to": 102
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\n\n/**\n * Use a natural transformation to change the generating type constructor of a free monad\n *\n * @category combinators\n * @since 0.1.3\n */\nexport function hoistFree<F extends URIS3 = never, G extends URIS3 = never>(\n  nt: <U, L, A>(fa: Kind3<F, U, L, A>) => Kind3<G, U, L, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "/**\n * Use a natural transformation to change the generating type constructor of a free monad\n *\n * @category combinators\n * @since 0.1.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<U, L, A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 126,
        "to": 128
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F extends URIS2 = never, G extends URIS2 = never>(\n  nt: <L, A>(fa: Kind2<F, L, A>) => Kind2<G, L, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<L, A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 129,
        "to": 131
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F extends URIS = never, G extends URIS = never>(\n  nt: <A>(fa: Kind<F, A>) => Kind<G, A>\n): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 132,
        "to": 134
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F, G>(nt: <A>(fa: HKT<F, A>) => HKT<G, A>): <A>(fa: Free<F, A>) => Free<G, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 135,
        "to": 135
      }
    }
  },
  {
    "name": "hoistFree",
    "text": "\nexport function hoistFree<F, G>(nt: <A>(fa: HKT<F, A>) => HKT<G, A>): <A>(fa: Free<F, A>) => Free<G, A> {\n  return substFree((fa) => liftF(nt(fa)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nt",
          "type": {
            "__tag": "Other",
            "values": "<A>(fa: any) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<G, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 136,
        "to": 138
      }
    }
  },
  {
    "name": "liftF",
    "text": "const liftF = <F, A>(fa: HKT<F, A>): Free<F, A> => impure(fa, (a) => free.of(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <F>(fa: Free<F, A>) => Free<F, B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 159,
        "to": 159
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <F, A, B>(fa: Free<F, A>) => (fab: Free<F, (a: A) => B>) => Free<F, B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 165,
        "to": 165
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <F, A, B>(f: (a: A) => Free<F, B>) => (ma: Free<F, A>) => Free<F, B> = (f) => (ma) => chain_(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 171,
        "to": 171
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <E, A>(mma: Free<E, Free<E, A>>) => Free<E, A> = (mma) => chain_(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 177,
        "to": 177
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <F, A>(a: A) => Free<F, A> = (a) => ({ _tag: 'Pure', value: a })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ _tag: \"Pure\"; value: A; }"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 183,
        "to": 183
      }
    }
  },
  {
    "name": "isPure",
    "text": "const isPure = <F, A>(fa: Free<F, A>): fa is Pure<F, A> => fa._tag === 'Pure'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 260,
        "to": 260
      }
    }
  },
  {
    "name": "isImpure",
    "text": "const isImpure = <F, A>(fa: Free<F, A>): fa is Impure<F, A, any> => fa._tag === 'Impure'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Free\").Free<F, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Free.ts",
      "lines": {
        "from": 267,
        "to": 267
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "const fromOptionK: <A extends Array<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => IOOption<B> = (\n  f\n) => (...a) => fromOption(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 70,
        "to": 72
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "const fromNullable: <A>(a: A) => IOOption<NonNullable<A>> = (a) => fromOption(O.fromNullable(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<NonNullable<A>>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 78,
        "to": 78
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "const fromIOEither: <A>(ma: IOEither<any, A>) => IOOption<A> = (ma) => io.map(ma, O.fromEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 84,
        "to": 84
      }
    }
  },
  {
    "name": "fold",
    "text": "const fold: <A, B>(onNone: () => IO<B>, onSome: (a: A) => IO<B>) => (ma: IOOption<A>) => IO<B> = (\n  onNone,\n  onSome\n) => (ma) => T.fold(ma, onNone, onSome)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 94,
        "to": 97
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "const getOrElse: <A>(onNone: () => IO<A>) => (ma: IOOption<A>) => IO<A> = (onNone) => (ma) =>\n  T.getOrElse(ma, onNone)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 103,
        "to": 104
      }
    }
  },
  {
    "name": "toUndefined",
    "text": "const toUndefined: <A>(ma: IOOption<A>) => IO<A | undefined> = (ma) => io.map(ma, O.toUndefined)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 110,
        "to": 110
      }
    }
  },
  {
    "name": "toNullable",
    "text": "const toNullable: <A>(ma: IOOption<A>) => IO<A | null> = (ma) => io.map(ma, O.toNullable)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 116,
        "to": 116
      }
    }
  },
  {
    "name": "mapNullable",
    "text": "const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: IOOption<A>) => IOOption<B> = (f) =>\n  ioMap(O.mapNullable(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 126,
        "to": 127
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B> = (f) => (fa) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 137,
        "to": 137
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B> = (fa) => (fab) => T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<(a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 143,
        "to": 143
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>): IOOption<A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 149,
        "to": 154
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: IOOption<B>) => <A>(fa: IOOption<A>): IOOption<B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 160,
        "to": 165
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B> = (f) => (ma) => T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 177,
        "to": 177
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<A> = (f) => (ma) =>\n  T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 183,
        "to": 184
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: IOOption<A>) => IOOption<B> = (f) =>\n  chain(fromOptionK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 190,
        "to": 191
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A> = (mma) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 197,
        "to": 197
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => IOOption<A>) => (fa: IOOption<A>) => IOOption<A> = (that) => (fa) => T.alt(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 203,
        "to": 203
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero: Alternative1<URI>['zero'] = () => () => O.none",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "() => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 209,
        "to": 209
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: IOOption<A>) => IOOption<B>\n  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => IOOption<A>\n} = <A>(predicate: Predicate<A>) => (fa: IOOption<A>) => F.filter(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 227,
        "to": 230
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => O.Option<B>) => (fa: IOOption<A>) => IOOption<B> = (f) => (fa) =>\n  F.filterMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 236,
        "to": 237
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<B>>\n  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<A>>\n} = <A>(predicate: Predicate<A>) => (fa: IOOption<A>) => F.partition(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 243,
        "to": 246
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: IOOption<A>) => Separated<IOOption<B>, IOOption<C>> = (f) => (fa) => F.partitionMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/IOOption\").IOOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 252,
        "to": 254
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "const getApplySemigroup = <A>(S: Semigroup<A>): Semigroup<IOOption<A>> =>\n  getIOSemigroup(O.getApplySemigroup<A>(S))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 282,
        "to": 283
      }
    }
  },
  {
    "name": "getApplyMonoid",
    "text": "const getApplyMonoid = <A>(M: Monoid<A>): Monoid<IOOption<A>> => ({\n  concat: getApplySemigroup<A>(M).concat,\n  empty: some(M.empty)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/IOOption.ts",
      "lines": {
        "from": 289,
        "to": 292
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\n\n/**\n * Drops those elements from the front of a list which match a predicate.\n *\n * @example\n * import * as L from 'fp-ts-contrib/List'\n *\n * const isLTThree = (n: number) => n < 3\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.cons(2, L.of(3)))), L.of(3))\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */\nexport function dropLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (fa: List<A>) => List<B>",
    "docs": "/**\n * Drops those elements from the front of a list which match a predicate.\n *\n * @example\n * import * as L from 'fp-ts-contrib/List'\n *\n * const isLTThree = (n: number) => n < 3\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.nil), L.nil)\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.cons(2, L.of(3)))), L.of(3))\n * assert.deepStrictEqual(L.dropLeftWhile(isLTThree)(L.cons(1, L.of(2))), L.nil)\n *\n * @since 0.1.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 255,
        "to": 255
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\nexport function dropLeftWhile<A>(predicate: Predicate<A>): (fa: List<A>) => List<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 256,
        "to": 256
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "\nexport function dropLeftWhile<A>(predicate: Predicate<A>): (fa: List<A>) => List<A> {\n  return (fa) => {\n    if (isNil(fa)) return nil\n\n    let l: List<A> = fa\n    while (isCons(l) && predicate(l.head)) {\n      l = l.tail\n    }\n    return l\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 257,
        "to": 267
      }
    }
  },
  {
    "name": "cons",
    "text": "const cons: <A>(head: A, tail: List<A>) => List<A> = (head, tail) => ({\n  type: 'Cons',\n  head,\n  tail,\n  length: 1 + tail.length\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ type: \"Cons\"; head: A; tail: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>; length: number; }"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 73,
        "to": 78
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <A>(as: Array<A>): List<A> => A.array.reduceRight<A, List<A>>(as, nil, cons)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "head",
    "text": "const head: <A>(fa: List<A>) => O.Option<A> = (fa) => (isCons(fa) ? O.some(fa.head) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 111,
        "to": 111
      }
    }
  },
  {
    "name": "tail",
    "text": "const tail: <A>(fa: List<A>) => O.Option<List<A>> = (fa) => (isCons(fa) ? O.some(fa.tail) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 127,
        "to": 127
      }
    }
  },
  {
    "name": "foldLeft",
    "text": "const foldLeft: <A, B>(onNil: () => B, onCons: (head: A, tail: List<A>) => B) => (fa: List<A>) => B = (\n  onNil,\n  onCons\n) => (fa) => (isNil(fa) ? onNil() : onCons(fa.head, fa.tail))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNil",
          "type": {
            "__tag": "Other",
            "values": "() => B"
          }
        },
        {
          "name": "onCons",
          "type": {
            "__tag": "Other",
            "values": "(head: A, tail: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => B"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 144,
        "to": 147
      }
    }
  },
  {
    "name": "toArray",
    "text": "const toArray = <A>(fa: List<A>): Array<A> => {\n  const length = fa.length\n  const out: Array<A> = new Array(length)\n  let l: List<A> = fa\n  for (let i = 0; i < length; i++) {\n    out[i] = (l as Cons<A>).head\n    l = (l as Cons<A>).tail\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 160,
        "to": 169
      }
    }
  },
  {
    "name": "toReversedArray",
    "text": "const toReversedArray = <A>(fa: List<A>): Array<A> => {\n  const length = fa.length\n  const out: Array<A> = new Array(length)\n  let l: List<A> = fa\n  for (let i = 0; i < length; i++) {\n    out[length - i - 1] = (l as Cons<A>).head\n    l = (l as Cons<A>).tail\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 182,
        "to": 191
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(fa: List<A>): List<A> => {\n  let out: List<A> = nil\n  let l = fa\n  while (isCons(l)) {\n    out = cons(l.head, out)\n    l = l.tail\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 208,
        "to": 216
      }
    }
  },
  {
    "name": "dropLeft",
    "text": "const dropLeft = (n: number) => <A>(fa: List<A>): List<A> => {\n  if (isNil(fa)) return nil\n  let i = 0\n  let l: List<A> = fa\n  while (isCons(l) && i < n) {\n    i++\n    l = l.tail\n  }\n  return l\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 231,
        "to": 240
      }
    }
  },
  {
    "name": "map",
    "text": "const map = <A, B>(f: (a: A) => B) => (fa: List<A>): List<B> =>\n  pipe(\n    toArray(fa),\n    A.reduceRight<A, List<B>>(nil, (a, b) => cons(f(a), b))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 305,
        "to": 309
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: List<A>) => <B>(fab: List<(a: A) => B>) => List<B> = (fa) => chain((f) => pipe(fa, map(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 315,
        "to": 315
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst: <B>(fb: List<B>) => <A>(fa: List<A>) => List<A> = (fb) =>\n  flow(\n    map((a) => () => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 321,
        "to": 325
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: List<B>): (<A>(fa: List<A>) => List<B>) =>\n  flow(\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 331,
        "to": 335
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain = <A, B>(f: (a: A) => List<B>) => (ma: List<A>): List<B> =>\n  pipe(\n    ma,\n    foldLeft(\n      () => nil,\n      (x, xs) => {\n        const S = getSemigroup<B>()\n        let out = f(x)\n        let l = xs\n        while (isCons(l)) {\n          out = S.concat(out, f(l.head))\n          l = l.tail\n        }\n        return out\n      }\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 341,
        "to": 357
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => List<B>) => (fa: List<A>) => List<A> = (f) =>\n  chain((a) =>\n    pipe(\n      f(a),\n      map(() => a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 363,
        "to": 369
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: List<A>) => B = (b, f) => (fa) => {\n  let out = b\n  let l = fa\n  while (isCons(l)) {\n    out = f(out, l.head)\n    l = l.tail\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => B"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 375,
        "to": 383
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: List<A>) => B = (b, f) => (fa) =>\n  pipe(toArray(fa), A.reduceRight(b, f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 389,
        "to": 390
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: List<A>) => M = (M) => (f) => (fa) => {\n  let out = M.empty\n  let l = fa\n  while (isCons(l)) {\n    out = M.concat(out, f(l.head))\n    l = l.tail\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 396,
        "to": 404
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: ApplicativeHKT<F>\n): (<A>(ta: List<HKT<F, A>>) => HKT<F, List<A>>) => sequence_(F)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<any>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 422,
        "to": 424
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <A>(head: A) => List<A> = (head) => cons(head, nil)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 437,
        "to": 437
      }
    }
  },
  {
    "name": "findIndex",
    "text": "const findIndex = <A>(predicate: Predicate<A>) => (fa: List<A>): O.Option<number> => {\n  let l: List<A> = fa\n  let i = 0\n  while (isCons(l)) {\n    if (predicate(l.head)) return O.some(i)\n    l = l.tail\n    i++\n  }\n  return O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 458,
        "to": 467
      }
    }
  },
  {
    "name": "getEq",
    "text": "const getEq = <A>(E: Eq.Eq<A>): Eq.Eq<List<A>> => ({\n  equals: (x, y) => {\n    if (x.length !== y.length) return false\n    let lx = x\n    let ly = y\n    while (isCons(lx) && isCons(ly)) {\n      if (!E.equals(lx.head, ly.head)) return false\n      lx = lx.tail\n      ly = ly.tail\n    }\n    return true\n  }\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 508,
        "to": 520
      }
    }
  },
  {
    "name": "getShow",
    "text": "const getShow = <A>(S: Show<A>): Show<List<A>> => ({\n  show: (as) =>\n    pipe(\n      as,\n      map(S.show),\n      foldLeft(\n        () => 'Nil',\n        (x, xs) => `(${intercalate(monoidString, Foldable)(' : ', cons(x, xs))} : Nil)`\n      )\n    )\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 526,
        "to": 536
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A>(): Semigroup<List<A>> => ({\n  concat: (xs, ys) => pipe(xs, reduceRight(ys, cons))\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 542,
        "to": 544
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <A>(): Monoid<List<A>> => ({\n  ...getSemigroup(),\n  empty: nil\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 550,
        "to": 553
      }
    }
  },
  {
    "name": "bindTo",
    "text": "const bindTo = <N extends string>(name: N) => <A>(fa: List<A>): List<{ [K in N]: A }> =>\n  pipe(\n    fa,\n    map((a) => bind_({}, name, a))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<{ [K in N]: A; }>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 652,
        "to": 656
      }
    }
  },
  {
    "name": "bind",
    "text": "const bind = <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => List<B>) => (\n  fa: List<A>\n): List<{ [K in keyof A | N]: K extends keyof A ? A[K] : B }> =>\n  pipe(\n    fa,\n    chain((a) =>\n      pipe(\n        f(a),\n        map((b) => bind_(a, name, b))\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "Exclude<N, keyof A>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 661,
        "to": 672
      }
    }
  },
  {
    "name": "apS",
    "text": "const apS = <A, N extends string, B>(\n  name: Exclude<N, keyof A>,\n  fb: List<B>\n): ((fa: List<A>) => List<{ [K in keyof A | N]: K extends keyof A ? A[K] : B }>) =>\n  flow(\n    map((a) => (b: B) => bind_(a, name, b)),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "Exclude<N, keyof A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 681,
        "to": 688
      }
    }
  },
  {
    "name": "isNil",
    "text": "const isNil = <A>(a: List<A>): a is Nil => a.type === 'Nil'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 705,
        "to": 705
      }
    }
  },
  {
    "name": "isCons",
    "text": "const isCons = <A>(a: List<A>): a is Cons<A> => a.type === 'Cons'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/List\").List<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/List.ts",
      "lines": {
        "from": 718,
        "to": 718
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "const fromIOK: <A extends Array<unknown>, B>(f: (...a: A) => IO<B>) => <R>(...a: A) => ReaderIO<R, B> = (f) => (\n  ...a\n) => fromIO(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 44,
        "to": 46
      }
    }
  },
  {
    "name": "local",
    "text": "const local: <Q, R>(f: (f: Q) => R) => <A>(ma: ReaderIO<R, A>) => ReaderIO<Q, A> = (f) => (ma) => T.local(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(f: Q) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 74,
        "to": 74
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: ReaderIO<E, A>) => ReaderIO<E, B> = (f) => (fa) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 84,
        "to": 84
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <E, A>(fa: ReaderIO<E, A>) => <B>(fab: ReaderIO<E, (a: A) => B>) => ReaderIO<E, B> = (fa) => (fab) =>\n  T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, (a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 90,
        "to": 91
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <E, B>(fb: ReaderIO<E, B>) => <A>(fa: ReaderIO<E, A>): ReaderIO<E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 97,
        "to": 102
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: ReaderIO<E, B>) => <A>(fa: ReaderIO<E, A>): ReaderIO<E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 108,
        "to": 113
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <E, A, B>(f: (a: A) => ReaderIO<E, B>) => (ma: ReaderIO<E, A>) => ReaderIO<E, B> = (f) => (ma) =>\n  T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 125,
        "to": 126
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => ReaderIO<E, B>) => (ma: ReaderIO<E, A>) => ReaderIO<E, A> = (f) => (\n  ma\n) => T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 132,
        "to": 134
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "const chainIOK = <A, B>(f: (a: A) => IO<B>): (<R>(ma: ReaderIO<R, A>) => ReaderIO<R, B>) =>\n  chain<any, A, B>(fromIOK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 140,
        "to": 141
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <E, A>(mma: ReaderIO<E, ReaderIO<E, A>>) => ReaderIO<E, A> = (mma) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 147,
        "to": 147
      }
    }
  },
  {
    "name": "run",
    "text": "const run: <R, A>(ma: ReaderIO<R, A>, r: R) => A = (ma, r) => ma(r)()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/ReaderIO\").ReaderIO<R, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/ReaderIO.ts",
      "lines": {
        "from": 232,
        "to": 232
      }
    }
  },
  {
    "name": "match",
    "text": "const match: (r: RegExp) => (s: string) => O.Option<RegExpMatchArray> = (r) => (s) => O.fromNullable(s.match(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 27,
        "to": 27
      }
    }
  },
  {
    "name": "test",
    "text": "const test: (r: RegExp) => Predicate<string> = (r) => (s) => {\n  const lastIndex = r.lastIndex\n  const res = r.test(s)\n  r.lastIndex = lastIndex\n  return res\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: any) => boolean"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 42,
        "to": 47
      }
    }
  },
  {
    "name": "sub",
    "text": "const sub: (r: RegExp, replacement: string) => (s: string) => string = (r, replacement) => (s) =>\n  s.replace(r, replacement)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        },
        {
          "name": "replacement",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => string"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 61,
        "to": 62
      }
    }
  },
  {
    "name": "split",
    "text": "const split: (r: RegExp) => (s: string) => NonEmptyArray<string> = (r) => (s) => s.split(r) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "RegExp"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: string) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/RegExp.ts",
      "lines": {
        "from": 77,
        "to": 77
      }
    }
  },
  {
    "name": "left",
    "text": "const left: <S, E, A = never>(e: E) => StateEither<S, E, A> = (e) => fromEither(E.left(e))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 62,
        "to": 62
      }
    }
  },
  {
    "name": "leftState",
    "text": "const leftState: <S, E = never, A = never>(me: State<S, E>) => StateEither<S, E, A> = (me) => (s) =>\n  E.left(me(s)[0])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 74,
        "to": 75
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <R, A>(ma: Option<A>) => StateEither<R, E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: any) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 87,
        "to": 88
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "const fromEitherK: <E, A extends Array<unknown>, B>(\n  f: (...a: A) => E.Either<E, B>\n) => <S>(...a: A) => StateEither<S, E, B> = (f) => (...a) => fromEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 100,
        "to": 102
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => StateEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => StateEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(a: A): StateEither<R, E, A> =>\n  predicate(a) ? right(a) : left(onFalse(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 108,
        "to": 112
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n    ma: StateEither<R, E, A>\n  ) => StateEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: StateEither<R, E, A>) => StateEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(ma: StateEither<R, E, A>) =>\n  T.chain(ma, (a) => (predicate(a) ? right(a) : left(onFalse(a))))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 122,
        "to": 128
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R, E>(fa: StateEither<R, E, A>) => StateEither<R, E, B> = (f) => (fa) =>\n  T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 138,
        "to": 139
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <R, E, A>(\n  fa: StateEither<R, E, A>\n) => <B>(fab: StateEither<R, E, (a: A) => B>) => StateEither<R, E, B> = (fa) => (fab) => T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, (a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 145,
        "to": 147
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <R, E, B>(fb: StateEither<R, E, B>) => <A>(fa: StateEither<R, E, A>): StateEither<R, E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 153,
        "to": 158
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, E, B>(fb: StateEither<R, E, B>) => <A>(fa: StateEither<R, E, A>): StateEither<R, E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 164,
        "to": 169
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <R, E, A, B>(\n  f: (a: A) => StateEither<R, E, B>\n) => (ma: StateEither<R, E, A>) => StateEither<R, E, B> = (f) => (ma) => T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 181,
        "to": 183
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <R, E, A, B>(\n  f: (a: A) => StateEither<R, E, B>\n) => (ma: StateEither<R, E, A>) => StateEither<R, E, A> = (f) => (ma) => T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 189,
        "to": 191
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "const chainEitherK = <E, A, B>(\n  f: (a: A) => E.Either<E, B>\n): (<S>(ma: StateEither<S, E, A>) => StateEither<S, E, B>) => chain<any, E, A, B>(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 196,
        "to": 198
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <R, E, A>(mma: StateEither<R, E, StateEither<R, E, A>>) => StateEither<R, E, A> = (mma) =>\n  T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateEither\").StateEither<R, E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateEither.ts",
      "lines": {
        "from": 204,
        "to": 205
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "const fromIOK: <A extends Array<unknown>, B>(f: (...a: A) => IO<B>) => <R>(...a: A) => StateIO<R, B> = (f) => (\n  ...a\n) => fromIO(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 74,
        "to": 76
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: StateIO<E, A>) => StateIO<E, B> = (f) => (fa) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 86,
        "to": 86
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <E, A>(fa: StateIO<E, A>) => <B>(fab: StateIO<E, (a: A) => B>) => StateIO<E, B> = (fa) => (fab) =>\n  T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, (a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 92,
        "to": 93
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <E, B>(fb: StateIO<E, B>) => <A>(fa: StateIO<E, A>): StateIO<E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 99,
        "to": 104
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <E, B>(fb: StateIO<E, B>) => <A>(fa: StateIO<E, A>): StateIO<E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 110,
        "to": 115
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <E, A, B>(f: (a: A) => StateIO<E, B>) => (ma: StateIO<E, A>) => StateIO<E, B> = (f) => (ma) =>\n  T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 127,
        "to": 128
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <E, A, B>(f: (a: A) => StateIO<E, B>) => (ma: StateIO<E, A>) => StateIO<E, A> = (f) => (ma) =>\n  T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 134,
        "to": 135
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "const chainIOK = <A, B>(f: (a: A) => IO<B>): (<R>(ma: StateIO<R, A>) => StateIO<R, B>) =>\n  chain<any, A, B>(fromIOK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<R, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 141,
        "to": 142
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <E, A>(mma: StateIO<E, StateIO<E, A>>) => StateIO<E, A> = (mma) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 148,
        "to": 148
      }
    }
  },
  {
    "name": "run",
    "text": "const run: <S, A>(ma: StateIO<S, A>, s: S) => A = (ma, s) => ma(s)()[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateIO\").StateIO<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateIO.ts",
      "lines": {
        "from": 243,
        "to": 243
      }
    }
  },
  {
    "name": "left",
    "text": "const left: <S, E>(e: E) => StateTaskEither<S, E, never> = (e) => fromTaskEither(TE.left(e))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 68,
        "to": 68
      }
    }
  },
  {
    "name": "leftIO",
    "text": "const leftIO: <S, E>(me: IO<E>) => StateTaskEither<S, E, never> = (me) => fromTaskEither(TE.leftIO(me))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 80,
        "to": 80
      }
    }
  },
  {
    "name": "rightIO",
    "text": "const rightIO: <S, A>(ma: IO<A>) => StateTaskEither<S, never, A> = (ma) => fromTaskEither(TE.rightIO(ma))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, never, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 86,
        "to": 86
      }
    }
  },
  {
    "name": "leftTask",
    "text": "const leftTask: <S, E>(me: Task<E>) => StateTaskEither<S, E, never> = (me) => fromTaskEither(TE.leftTask(me))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "rightTask",
    "text": "const rightTask: <S, A>(ma: Task<A>) => StateTaskEither<S, never, A> = (ma) => fromTaskEither(TE.rightTask(ma))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, never, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 98,
        "to": 98
      }
    }
  },
  {
    "name": "leftState",
    "text": "const leftState: <S, E>(me: State<S, E>) => StateTaskEither<S, E, never> = (me) => (s) => TE.left(me(s)[0])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 104,
        "to": 104
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: () => E) => <R, A>(ma: Option<A>) => StateTaskEither<R, E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: any) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 116,
        "to": 117
      }
    }
  },
  {
    "name": "fromEither",
    "text": "const fromEither: <R, E, A>(ma: Either<E, A>) => StateTaskEither<R, E, A> = (ma) =>\n  ma._tag === 'Left' ? left(ma.left) : right(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, any, never>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 123,
        "to": 124
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "const fromIOEither: <S, E, A>(ma: IOEither<E, A>) => StateTaskEither<S, E, A> = (ma) =>\n  fromTaskEither(TE.fromIOEither(ma))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 130,
        "to": 131
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "const fromEitherK: <E, A extends Array<unknown>, B>(\n  f: (...a: A) => Either<E, B>\n) => <S>(...a: A) => StateTaskEither<S, E, B> = (f) => (...a) => fromEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 143,
        "to": 145
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "const fromIOEitherK: <E, A extends Array<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n) => <S>(...a: A) => StateTaskEither<S, E, B> = (f) => (...a) => fromIOEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "const fromTaskEitherK: <E, A extends Array<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n) => <S>(...a: A) => StateTaskEither<S, E, B> = (f) => (...a) => fromTaskEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 159,
        "to": 161
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => StateTaskEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => StateTaskEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(a: A): StateTaskEither<R, E, A> =>\n  predicate(a) ? right(a) : left(onFalse(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 167,
        "to": 171
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "const filterOrElse: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n    ma: StateTaskEither<R, E, A>\n  ) => StateTaskEither<R, E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => <R>(\n  ma: StateTaskEither<R, E, A>\n): StateTaskEither<R, E, A> => T.chain(ma, (a) => (predicate(a) ? right(a) : left(onFalse(a))))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 181,
        "to": 188
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R, E>(fa: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B> = (f) => (\n  fa\n) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 198,
        "to": 200
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <R, E, A>(\n  fa: StateTaskEither<R, E, A>\n) => <B>(fab: StateTaskEither<R, E, (a: A) => B>) => StateTaskEither<R, E, B> = (fa) => (fab) => T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, (a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 206,
        "to": 208
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <R, E, B>(fb: StateTaskEither<R, E, B>) => <A>(\n  fa: StateTaskEither<R, E, A>\n): StateTaskEither<R, E, A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 214,
        "to": 221
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <R, E, B>(fb: StateTaskEither<R, E, B>) => <A>(\n  fa: StateTaskEither<R, E, A>\n): StateTaskEither<R, E, B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 227,
        "to": 234
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <R, E, A, B>(\n  f: (a: A) => StateTaskEither<R, E, B>\n) => (ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, B> = (f) => (ma) => T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 246,
        "to": 248
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <R, E, A, B>(\n  f: (a: A) => StateTaskEither<R, E, B>\n) => (ma: StateTaskEither<R, E, A>) => StateTaskEither<R, E, A> = (f) => (ma) =>\n  T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 254,
        "to": 257
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "const chainEitherK = <E, A, B>(\n  f: (a: A) => Either<E, B>\n): (<S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>) => chain<any, E, A, B>(fromEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 263,
        "to": 265
      }
    }
  },
  {
    "name": "chainIOEitherK",
    "text": "const chainIOEitherK = <E, A, B>(\n  f: (a: A) => IOEither<E, B>\n): (<S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>) => chain<any, E, A, B>(fromIOEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 271,
        "to": 273
      }
    }
  },
  {
    "name": "chainTaskEitherK",
    "text": "const chainTaskEitherK = <E, A, B>(\n  f: (a: A) => TaskEither<E, B>\n): (<S>(ma: StateTaskEither<S, E, A>) => StateTaskEither<S, E, B>) => chain<any, E, A, B>(fromTaskEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 279,
        "to": 281
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <R, E, A>(mma: StateTaskEither<R, E, StateTaskEither<R, E, A>>) => StateTaskEither<R, E, A> = (\n  mma\n) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<R, E, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 287,
        "to": 289
      }
    }
  },
  {
    "name": "run",
    "text": "const run: <S, E, A>(ma: StateTaskEither<S, E, A>, s: S) => Promise<Either<E, [A, S]>> = (ma, s) => ma(s)()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/StateTaskEither\").StateTaskEither<S, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/StateTaskEither.ts",
      "lines": {
        "from": 396,
        "to": 396
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "const fromOptionK: <A extends Array<unknown>, B>(f: (...a: A) => O.Option<B>) => (...a: A) => TaskOption<B> = (\n  f\n) => (...a) => fromOption(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 58,
        "to": 60
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "const fromNullable: <A>(a: A) => TaskOption<NonNullable<A>> = (a) => fromOption(O.fromNullable(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<NonNullable<A>>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 72,
        "to": 72
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "const fromTaskEither: <A>(ma: TaskEither<any, A>) => TaskOption<A> = (ma) => task.map(ma, O.fromEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 78,
        "to": 78
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch: <A>(f: Lazy<Promise<A>>) => TaskOption<A> = (f) => () =>\n  f().then(\n    (a) => O.some(a),\n    () => O.none\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 84,
        "to": 88
      }
    }
  },
  {
    "name": "fold",
    "text": "const fold: <A, B>(onNone: () => Task<B>, onSome: (a: A) => Task<B>) => (as: TaskOption<A>) => Task<B> = (\n  onNone,\n  onSome\n) => (as) => T.fold(as, onNone, onSome)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 98,
        "to": 101
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "const getOrElse: <A>(onNone: () => Task<A>) => (as: TaskOption<A>) => Task<A> = (onNone) => (as) =>\n  T.getOrElse(as, onNone)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 107,
        "to": 108
      }
    }
  },
  {
    "name": "toUndefined",
    "text": "const toUndefined: <A>(ma: TaskOption<A>) => Task<A | undefined> = (ma) => task.map(ma, O.toUndefined)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 114,
        "to": 114
      }
    }
  },
  {
    "name": "toNullable",
    "text": "const toNullable: <A>(ma: TaskOption<A>) => Task<A | null> = (ma) => task.map(ma, O.toNullable)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 120,
        "to": 120
      }
    }
  },
  {
    "name": "mapNullable",
    "text": "const mapNullable: <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskOption<A>) => TaskOption<B> = (f) =>\n  taskMap(O.mapNullable(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 130,
        "to": 131
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: TaskOption<A>) => TaskOption<B> = (f) => (fa) => T.map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 141,
        "to": 141
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: TaskOption<A>) => <B>(fab: TaskOption<(a: A) => B>) => TaskOption<B> = (fa) => (fab) =>\n  T.ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<(a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 147,
        "to": 148
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>): TaskOption<A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 154,
        "to": 159
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: TaskOption<B>) => <A>(fa: TaskOption<A>): TaskOption<B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 165,
        "to": 170
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<B> = (f) => (ma) =>\n  T.chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 182,
        "to": 183
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "const chainFirst: <A, B>(f: (a: A) => TaskOption<B>) => (ma: TaskOption<A>) => TaskOption<A> = (f) => (ma) =>\n  T.chain(ma, (a) => T.map(f(a), () => a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 189,
        "to": 190
      }
    }
  },
  {
    "name": "chainTask",
    "text": "const chainTask: <A, B>(f: (a: A) => Task<B>) => (ma: TaskOption<A>) => TaskOption<B> = (f) => (ma) =>\n  T.chain(ma, (a) => fromTask(f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 196,
        "to": 197
      }
    }
  },
  {
    "name": "chainOption",
    "text": "const chainOption: <A, B>(f: (a: A) => O.Option<B>) => (ma: TaskOption<A>) => TaskOption<B> = (f) =>\n  taskMap(O.chain(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 203,
        "to": 204
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "const chainOptionK: <A, B>(f: (a: A) => O.Option<B>) => (ma: TaskOption<A>) => TaskOption<B> = (f) =>\n  chain(fromOptionK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 210,
        "to": 211
      }
    }
  },
  {
    "name": "flatten",
    "text": "const flatten: <A>(mma: TaskOption<TaskOption<A>>) => TaskOption<A> = (mma) => T.chain(mma, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "mma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 217,
        "to": 217
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt: <A>(that: () => TaskOption<A>) => (fa: TaskOption<A>) => TaskOption<A> = (that) => (fa) =>\n  T.alt(fa, that)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 223,
        "to": 224
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: TaskOption<A>) => TaskOption<B>\n  <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => TaskOption<A>\n} = <A>(predicate: Predicate<A>) => (fa: TaskOption<A>): TaskOption<A> => F.filter(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 248,
        "to": 251
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => O.Option<B>) => (fa: TaskOption<A>) => TaskOption<B> = (f) => (fa) =>\n  F.filterMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 257,
        "to": 258
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<B>>\n  <A>(predicate: Predicate<A>): (fa: TaskOption<A>) => Separated<TaskOption<A>, TaskOption<A>>\n} = <A>(predicate: Predicate<A>) => (fa: TaskOption<A>): Separated<TaskOption<A>, TaskOption<A>> =>\n  F.partition(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 264,
        "to": 268
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: TaskOption<A>) => Separated<TaskOption<B>, TaskOption<C>> = (f) => (fa) => F.partitionMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/TaskOption\").TaskOption<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 274,
        "to": 276
      }
    }
  },
  {
    "name": "time",
    "text": "\n\n/**\n * Mimics the analogous Unix command: given an action `HKT<M, A>`, we can derive an action `HKT<M, [A, number]>` that\n * returns the elapsed time along with the computed value\n *\n * @example\n * import { io } from 'fp-ts/IO'\n * import { randomInt } from 'fp-ts/Random'\n * import { time } from 'fp-ts-contrib/time'\n *\n * const timeIO = time(io)\n *\n * function fib(n: number): number {\n *   return n <= 1 ? 1 : fib(n - 1) + fib(n - 2)\n * }\n *\n * timeIO(io.map(randomInt(30, 35), fib))() // [ 14930352, 127 ]\n *\n * @since 0.1.0\n */\nexport function time<M extends URIS3>(M: MonadIO3<M>): <R, E, A>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, [A, number]>",
    "docs": "/**\n * Mimics the analogous Unix command: given an action `HKT<M, A>`, we can derive an action `HKT<M, [A, number]>` that\n * returns the elapsed time along with the computed value\n *\n * @example\n * import { io } from 'fp-ts/IO'\n * import { randomInt } from 'fp-ts/Random'\n * import { time } from 'fp-ts-contrib/time'\n *\n * const timeIO = time(io)\n *\n * function fib(n: number): number {\n *   return n <= 1 ? 1 : fib(n - 1) + fib(n - 2)\n * }\n *\n * timeIO(io.map(randomInt(30, 35), fib))() // [ 14930352, 127 ]\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 27,
        "to": 27
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS2>(M: MonadIO2<M>): <E, A>(ma: Kind2<M, E, A>) => Kind2<M, E, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 28,
        "to": 28
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS2, E>(M: MonadIO2C<M, E>): <A>(ma: Kind2<M, E, A>) => Kind2<M, E, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 29,
        "to": 29
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M extends URIS>(M: MonadIO1<M>): <A>(ma: Kind<M, A>) => Kind<M, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 30,
        "to": 30
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M>(M: MonadIO<M>): <A>(ma: HKT<M, A>) => HKT<M, [A, number]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 31,
        "to": 31
      }
    }
  },
  {
    "name": "time",
    "text": "\nexport function time<M>(M: MonadIO<M>): <A>(ma: HKT<M, A>) => HKT<M, [A, number]> {\n  const nowM = M.fromIO(now)\n  return (ma) => M.chain(nowM, (start) => M.chain(ma, (a) => M.map(nowM, (end) => [a, end - start])))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/time.ts",
      "lines": {
        "from": 32,
        "to": 35
      }
    }
  },
  {
    "name": "make",
    "text": "const make: <A>(lefts: ReadonlyArray<A>, focus: A, rights: ReadonlyArray<A>) => Zipper<A> = (\n  lefts,\n  focus,\n  rights\n) => ({\n  lefts: lefts.slice(),\n  focus,\n  rights: rights.slice()\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "lefts",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "focus",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "rights",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ lefts: A[]; focus: A; rights: A[]; }"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 62,
        "to": 70
      }
    }
  },
  {
    "name": "fromReadonlyArray",
    "text": "const fromReadonlyArray: <A>(as: ReadonlyArray<A>, focusIndex?: number) => Option<Zipper<A>> = (\n  as,\n  focusIndex = 0\n) => {\n  if (RA.isEmpty(as) || RA.isOutOfBound(focusIndex, as)) {\n    return O.none\n  } else {\n    return O.some(\n      make(pipe(as.slice(), A.takeLeft(focusIndex)), as[focusIndex], pipe(as.slice(), A.dropLeft(focusIndex + 1)))\n    )\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "focusIndex",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 76,
        "to": 87
      }
    }
  },
  {
    "name": "fromReadonlyNonEmptyArray",
    "text": "const fromReadonlyNonEmptyArray: <A>(rnea: ReadonlyNonEmptyArray<A>) => Zipper<A> = (nea) =>\n  make([], nea[0], nea.slice(1))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "nea",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 99,
        "to": 100
      }
    }
  },
  {
    "name": "isOutOfBound",
    "text": "const isOutOfBound: <A>(index: number, fa: Zipper<A>) => boolean = (index, fa) =>\n  index < 0 || index >= length(fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "index",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 116,
        "to": 117
      }
    }
  },
  {
    "name": "length",
    "text": "const length: <A>(fa: Zipper<A>) => number = (fa) => fa.lefts.length + 1 + fa.rights.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 123,
        "to": 123
      }
    }
  },
  {
    "name": "toNonEmptyArray",
    "text": "const toNonEmptyArray: <A>(fa: Zipper<A>) => NonEmptyArray<A> = (fa) =>\n  pipe(\n    NEA.of(fa.focus),\n    (as) => NEA.concat(fa.lefts, as),\n    (as) => NEA.concat(as, fa.rights)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 129,
        "to": 134
      }
    }
  },
  {
    "name": "update",
    "text": "const update: <A>(a: A) => (fa: Zipper<A>) => Zipper<A> = (a) => (fa) => make(fa.lefts, a, fa.rights)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 159,
        "to": 159
      }
    }
  },
  {
    "name": "modify",
    "text": "const modify: <A>(f: (a: A) => A) => (fa: Zipper<A>) => Zipper<A> = (f) => (fa) => pipe(fa, update(f(fa.focus)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "move",
    "text": "const move: <A>(f: (currentIndex: number) => number, fa: Zipper<A>) => Option<Zipper<A>> = (f, fa) => {\n  const newIndex = f(fa.lefts.length)\n  if (isOutOfBound(newIndex, fa)) {\n    return O.none\n  } else {\n    return fromArray(toNonEmptyArray(fa), newIndex)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(currentIndex: number) => number"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 175,
        "to": 182
      }
    }
  },
  {
    "name": "findIndex",
    "text": "const findIndex = <A>(predicate: Predicate<A>) => (fa: Zipper<A>): Option<number> =>\n  pipe(\n    fa.lefts,\n    RA.findIndex(predicate),\n    O.alt(() => (predicate(fa.focus) ? O.some(fa.lefts.length) : O.none)),\n    O.alt(() =>\n      pipe(\n        fa.rights,\n        RA.findIndex(predicate),\n        O.map((i) => fa.lefts.length + 1 + i)\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 190,
        "to": 202
      }
    }
  },
  {
    "name": "moveByFindFirst",
    "text": "const moveByFindFirst = <A>(predicate: Predicate<A>) => (fa: Zipper<A>): Option<Zipper<A>> =>\n  pipe(\n    fa,\n    findIndex(predicate),\n    O.chain((i) => (i === fa.lefts.length ? O.some(fa) : move(() => i, fa)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 212,
        "to": 217
      }
    }
  },
  {
    "name": "up",
    "text": "const up: <A>(fa: Zipper<A>) => Option<Zipper<A>> = (fa) => move(decrement, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 225,
        "to": 225
      }
    }
  },
  {
    "name": "down",
    "text": "const down: <A>(fa: Zipper<A>) => Option<Zipper<A>> = (fa) => move(increment, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 233,
        "to": 233
      }
    }
  },
  {
    "name": "start",
    "text": "const start: <A>(fa: Zipper<A>) => Zipper<A> = (fa) => {\n  if (A.isEmpty(fa.lefts)) {\n    return fa\n  } else {\n    return make([], fa.lefts[0], A.snoc(pipe(fa.lefts, A.dropLeft(1)), fa.focus).concat(fa.rights))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 241,
        "to": 247
      }
    }
  },
  {
    "name": "end",
    "text": "const end: <A>(fa: Zipper<A>) => Zipper<A> = (fa) => {\n  const len = fa.rights.length\n  if (len === 0) {\n    return fa\n  } else {\n    return make(A.snoc(fa.lefts, fa.focus).concat(pipe(fa.rights, A.takeLeft(len - 1))), fa.rights[len - 1], [])\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 255,
        "to": 262
      }
    }
  },
  {
    "name": "insertLeft",
    "text": "const insertLeft: <A>(a: A) => (fa: Zipper<A>) => Zipper<A> = (a) => (fa) =>\n  make(fa.lefts, a, A.cons(fa.focus, fa.rights))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 270,
        "to": 271
      }
    }
  },
  {
    "name": "insertRight",
    "text": "const insertRight: <A>(a: A) => (fa: Zipper<A>) => Zipper<A> = (a) => (fa) =>\n  make(A.snoc(fa.lefts, fa.focus), a, fa.rights)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 279,
        "to": 280
      }
    }
  },
  {
    "name": "deleteLeft",
    "text": "const deleteLeft: <A>(fa: Zipper<A>) => Option<Zipper<A>> = (fa) => {\n  const len = fa.lefts.length\n  return fromArray(fa.lefts.concat(fa.rights), len > 0 ? len - 1 : 0)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 289,
        "to": 292
      }
    }
  },
  {
    "name": "deleteRight",
    "text": "const deleteRight: <A>(fa: Zipper<A>) => Option<Zipper<A>> = (fa) => {\n  const lenl = fa.lefts.length\n  const lenr = fa.rights.length\n  return fromArray(fa.lefts.concat(fa.rights), lenr > 0 ? lenl : lenl - 1)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 301,
        "to": 305
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Zipper<A>) => Zipper<B> = (f) => (fa) => map_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 363,
        "to": 363
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (fa: Zipper<A>) => Zipper<B> = (f) => (fa) =>\n  mapWithIndex_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 369,
        "to": 370
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Zipper<A>) => <B>(fab: Zipper<(a: A) => B>) => Zipper<B> = (fa) => (fab) => ap_(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<(a: A) => B>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 376,
        "to": 376
      }
    }
  },
  {
    "name": "apFirst",
    "text": "const apFirst = <B>(fb: Zipper<B>) => <A>(fa: Zipper<A>): Zipper<A> =>\n  pipe(\n    fa,\n    map((a) => (_: B) => a),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 382,
        "to": 387
      }
    }
  },
  {
    "name": "apSecond",
    "text": "const apSecond = <B>(fb: Zipper<B>) => <A>(fa: Zipper<A>): Zipper<B> =>\n  pipe(\n    fa,\n    map(() => (b: B) => b),\n    ap(fb)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<B>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 393,
        "to": 398
      }
    }
  },
  {
    "name": "of",
    "text": "const of: <A>(focus: A) => Zipper<A> = (focus) => make([], focus, [])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "focus",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 404,
        "to": 404
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (fa: Zipper<A>) => B) => (wa: Zipper<A>) => Zipper<B> = (f) => (wa) => extend_(wa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 410,
        "to": 410
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Zipper<A>) => M = (M) => (f) => (fa) =>\n  foldMap_(M)(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 422,
        "to": 423
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Zipper<A>) => B = (b, f) => (fa) => reduce_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 429,
        "to": 429
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Zipper<A>) => B = (b, f) => (fa) =>\n  reduceRight_(fa, b, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<A>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 435,
        "to": 436
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: ApplicativeHKT<F>\n): (<A>(ta: Zipper<HKT<F, A>>) => HKT<F, Zipper<A>>) => {\n  const sequenceF = A.array.sequence(F)\n  return <A>(ta: Zipper<HKT<F, A>>) =>\n    F.ap(\n      F.ap(\n        F.map(sequenceF(ta.lefts), (lefts) => (focus: A) => (rights: Array<A>) => make(lefts, focus, rights)),\n        ta.focus\n      ),\n      sequenceF(ta.rights)\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<any>) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 442,
        "to": 454
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: Comonad1<URI>['extract'] = (fa) => fa.focus",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 460,
        "to": 460
      }
    }
  },
  {
    "name": "getShow",
    "text": "const getShow: <A>(S: Show<A>) => Show<Zipper<A>> = (S) => {\n  const SA = A.getShow(S)\n  return {\n    show: (fa) => `Zipper(${SA.show(fa.lefts)}, ${S.show(fa.focus)}, ${SA.show(fa.rights)})`\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ show: (fa: any) => string; }"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 488,
        "to": 493
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup: <A>(S: Semigroup<A>) => Semigroup<Zipper<A>> = (S) => ({\n  concat: (x, y) => make(x.lefts.concat(y.lefts), S.concat(x.focus, y.focus), x.rights.concat(y.rights))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ concat: (x: any, y: any) => import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Zipper\").Zipper<any>; }"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 499,
        "to": 501
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid: <A>(M: Monoid<A>) => Monoid<Zipper<A>> = (M) => ({\n  ...getSemigroup(M),\n  empty: make([], M.empty, [])\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Zipper.ts",
      "lines": {
        "from": 507,
        "to": 510
      }
    }
  },
  {
    "name": "repro38",
    "text": " // $ExpectType () => Task<{ a: string; b: number; }>\n\n// issue #38\n\nexport function repro38<F extends URIS>(\n  F: Monad1<F> & {\n    f: Kind<F, void>\n  }\n) {\n  Do(F).do(F.f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 76,
        "to": 82
      }
    }
  },
  {
    "name": "lpadZipWith",
    "text": "const lpadZipWith: <A, B, C>(xs: Array<A>, ys: Array<B>, f: (a: Option<A>, b: B) => C) => Array<C> = (\n  xs,\n  ys,\n  f\n) => array.compact(padZipWith(alignArray)(xs, ys, (ma, mb) => option.map(mb, (b) => f(ma, b))))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: any, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 99,
        "to": 103
      }
    }
  },
  {
    "name": "lpadZip",
    "text": "const lpadZip: <A, B>(xs: Array<A>, ys: Array<B>) => Array<[Option<A>, B]> = (xs, ys) =>\n  lpadZipWith(xs, ys, (a, b) => tuple(a, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "any[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 120,
        "to": 121
      }
    }
  },
  {
    "name": "rpadZipWith",
    "text": "const rpadZipWith: <A, B, C>(xs: Array<A>, ys: Array<B>, f: (a: A, b: Option<B>) => C) => Array<C> = (\n  xs,\n  ys,\n  f\n) => lpadZipWith(ys, xs, (a, b) => f(b, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 139,
        "to": 143
      }
    }
  },
  {
    "name": "rpadZip",
    "text": "const rpadZip: <A, B>(xs: Array<A>, ys: Array<B>) => Array<[A, Option<B>]> = (xs, ys) =>\n  rpadZipWith(xs, ys, (a, b) => tuple(a, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "xs",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "ys",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "any[]"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Array.ts",
      "lines": {
        "from": 160,
        "to": 161
      }
    }
  },
  {
    "name": "salign",
    "text": "\n\n/**\n * Align two structures, using a semigroup for combining values.\n *\n * @example\n * import { semigroupSum } from 'fp-ts/Semigroup'\n * import { salign } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n *\n * assert.deepStrictEqual(salign(alignArray, semigroupSum)([1, 2, 3], [4, 5]), [5, 7, 3])\n *\n * @since 0.1.0\n */\nexport function salign<F extends URIS3, A, L>(\n  F: Align3<F>,\n  S: Semigroup<A>\n): <U, L>(fx: Kind3<F, U, L, A>, fy: Kind3<F, U, L, A>) => Kind3<F, U, L, A>",
    "docs": "/**\n * Align two structures, using a semigroup for combining values.\n *\n * @example\n * import { semigroupSum } from 'fp-ts/Semigroup'\n * import { salign } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n *\n * assert.deepStrictEqual(salign(alignArray, semigroupSum)([1, 2, 3], [4, 5]), [5, 7, 3])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L>(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 69,
        "to": 72
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS2, A>(\n  F: Align2<F>,\n  S: Semigroup<A>\n): <L>(fx: Kind2<F, L, A>, fy: Kind2<F, L, A>) => Kind2<F, L, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L>(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 73,
        "to": 76
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS2, A, L>(\n  F: Align2C<F, L>,\n  S: Semigroup<A>\n): (fx: Kind2<F, L, A>, fy: Kind2<F, L, A>) => Kind2<F, L, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 77,
        "to": 80
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F extends URIS, A>(F: Align1<F>, S: Semigroup<A>): (fx: Kind<F, A>, fy: Kind<F, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 81,
        "to": 81
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F, A>(F: Align<F>, S: Semigroup<A>): (fx: HKT<F, A>, fy: HKT<F, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 82,
        "to": 82
      }
    }
  },
  {
    "name": "salign",
    "text": "\nexport function salign<F, A>(F: Align<F>, S: Semigroup<A>): (fx: HKT<F, A>, fy: HKT<F, A>) => HKT<F, A> {\n  return (fx, fy) => F.alignWith(fx, fy, fold(identity, identity, S.concat))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fx: any, fy: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 83,
        "to": 85
      }
    }
  },
  {
    "name": "padZip",
    "text": "\n\n/**\n * Align two structures, using `none` to fill blanks.\n *\n * It is similar to `zip`, but it doesn't discard elements.\n *\n * @example\n * import { some, none } from 'fp-ts/Option'\n * import { padZip } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n *\n * assert.deepStrictEqual(padZip(alignArray)([1, 2, 3], [4, 5]), [[some(1), some(4)], [some(2), some(5)], [some(3), none]])\n *\n * @since 0.1.0\n */\nexport function padZip<F extends URIS3, L>(\n  F: Align3<F>\n): <U, L, A, B>(fa: Kind3<F, U, L, A>, fb: Kind3<F, U, L, B>) => Kind3<F, U, L, [Option<A>, Option<B>]>",
    "docs": "/**\n * Align two structures, using `none` to fill blanks.\n *\n * It is similar to `zip`, but it doesn't discard elements.\n *\n * @example\n * import { some, none } from 'fp-ts/Option'\n * import { padZip } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n *\n * assert.deepStrictEqual(padZip(alignArray)([1, 2, 3], [4, 5]), [[some(1), some(4)], [some(2), some(5)], [some(3), none]])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS2>(\n  F: Align2<F>\n): <L, A, B>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>) => Kind2<F, L, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 104,
        "to": 106
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS2, L>(\n  F: Align2C<F, L>\n): <A, B>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>) => Kind2<F, L, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F extends URIS>(\n  F: Align1<F>\n): <A, B>(fa: Kind<F, A>, fb: Kind<F, B>) => Kind<F, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F>(F: Align<F>): <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => HKT<F, [Option<A>, Option<B>]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 113,
        "to": 113
      }
    }
  },
  {
    "name": "padZip",
    "text": "\nexport function padZip<F>(F: Align<F>): <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => HKT<F, [Option<A>, Option<B>]> {\n  return (fa, fb) => padZipWith(F)(fa, fb, (a, b) => tuple(a, b))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: any, fb: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 114,
        "to": 116
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\n\n/**\n * Align two structures by applying a function to each pair of aligned elements, using `none` to fill blanks.\n *\n * It is similar to `zipWith`, but it doesn't discard elements.\n *\n * @example\n * import { Option, fold, getOrElse } from 'fp-ts/Option'\n * import { padZipWith } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (ma: Option<number>, mb: Option<string>) =>\n *   pipe(\n *     ma,\n *     fold(() => '*', a => a.toString())\n *   ) +\n *   pipe(\n *     mb,\n *     getOrElse(() => '#')\n *   )\n *\n * assert.deepStrictEqual(padZipWith(alignArray)([1, 2], ['a'], f), ['1a', '2#'])\n * assert.deepStrictEqual(padZipWith(alignArray)([1], ['a', 'b'], f), ['1a', '*b'])\n *\n * @since 0.1.0\n */\nexport function padZipWith<F extends URIS3, L>(\n  F: Align3<F>\n): <U, L, A, B, C>(\n  fa: Kind3<F, U, L, A>,\n  fb: Kind3<F, U, L, B>,\n  f: (a: Option<A>, b: Option<B>) => C\n) => Kind3<F, U, L, C>",
    "docs": "/**\n * Align two structures by applying a function to each pair of aligned elements, using `none` to fill blanks.\n *\n * It is similar to `zipWith`, but it doesn't discard elements.\n *\n * @example\n * import { Option, fold, getOrElse } from 'fp-ts/Option'\n * import { padZipWith } from 'fp-ts-contrib/Align'\n * import { alignArray } from 'fp-ts-contrib/Align/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (ma: Option<number>, mb: Option<string>) =>\n *   pipe(\n *     ma,\n *     fold(() => '*', a => a.toString())\n *   ) +\n *   pipe(\n *     mb,\n *     getOrElse(() => '#')\n *   )\n *\n * assert.deepStrictEqual(padZipWith(alignArray)([1, 2], ['a'], f), ['1a', '2#'])\n * assert.deepStrictEqual(padZipWith(alignArray)([1], ['a', 'b'], f), ['1a', '*b'])\n *\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<U, L, A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 144,
        "to": 150
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS2>(\n  F: Align2<F>\n): <L, A, B, C>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind2<F, L, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<L, A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS2, L>(\n  F: Align2C<F, L>\n): <A, B, C>(fa: Kind2<F, L, A>, fb: Kind2<F, L, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind2<F, L, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align2C<F, L>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 154,
        "to": 156
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F extends URIS>(\n  F: Align1<F>\n): <A, B, C>(fa: Kind<F, A>, fb: Kind<F, B>, f: (a: Option<A>, b: Option<B>) => C) => Kind<F, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F>(\n  F: Align<F>\n): <A, B, C>(fa: HKT<F, A>, fb: HKT<F, B>, f: (a: Option<A>, b: Option<B>) => C) => HKT<F, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 160,
        "to": 162
      }
    }
  },
  {
    "name": "padZipWith",
    "text": "\nexport function padZipWith<F>(\n  F: Align<F>\n): <A, B, C>(fa: HKT<F, A>, fb: HKT<F, B>, f: (a: Option<A>, b: Option<B>) => C) => HKT<F, C> {\n  return (fa, fb, f) =>\n    F.alignWith(fa, fb, (ab) =>\n      pipe(\n        ab,\n        bimap(some, some),\n        fold(\n          (a) => f(a, none),\n          (b) => f(none, b),\n          (a, b) => f(a, b)\n        )\n      )\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts-contrib/src/Align/index\").Align<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(fa: any, fb: any, f: (a: any, b: any) => C) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/index.ts",
      "lines": {
        "from": 163,
        "to": 178
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function alignWith<K extends string, P extends string, A, B, C>(\n  fa: Record<K, A>,\n  fb: Record<P, B>,\n  f: (x: These<A, B>) => C\n): Record<K | P, C>",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<P, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K | P, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 11,
        "to": 15
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\nexport function alignWith<A, B, C>(\n  fa: Record<string, A>,\n  fb: Record<string, B>,\n  f: (x: These<A, B>) => C\n): Record<string, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 16,
        "to": 20
      }
    }
  },
  {
    "name": "alignWith",
    "text": "\nexport function alignWith<A, B, C>(\n  fa: Record<string, A>,\n  fb: Record<string, B>,\n  f: (x: These<A, B>) => C\n): Record<string, C> {\n  const r: Record<string, C> = {}\n  for (const key of Object.keys(fa)) {\n    if (fb.hasOwnProperty(key)) {\n      r[key] = f(both(fa[key], fb[key]))\n    } else {\n      r[key] = f(left(fa[key]))\n    }\n  }\n  for (const key of Object.keys(fb)) {\n    if (!fa.hasOwnProperty(key)) {\n      r[key] = f(right(fb[key]))\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(x: any) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, C>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 21,
        "to": 40
      }
    }
  },
  {
    "name": "align",
    "text": "\n\n/**\n * @since 0.1.0\n */\nexport function align<K extends string, P extends string, A, B>(\n  fa: Record<K, A>,\n  fb: Record<P, B>\n): Record<K | P, These<A, B>>",
    "docs": "/**\n * @since 0.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K | P, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 45,
        "to": 48
      }
    }
  },
  {
    "name": "align",
    "text": "\nexport function align<A, B>(fa: Record<string, A>, fb: Record<string, B>): Record<string, These<A, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 49,
        "to": 49
      }
    }
  },
  {
    "name": "align",
    "text": "\nexport function align<A, B>(fa: Record<string, A>, fb: Record<string, B>): Record<string, These<A, B>> {\n  return alignWith<A, B, These<A, B>>(fa, fb, identity)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Record<string, A>"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "Record<string, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, any>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "nil",
    "text": "const nil: <A>() => Record<string, A> = () => R.empty",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Align/Record.ts",
      "lines": {
        "from": 57,
        "to": 57
      }
    }
  },
  {
    "name": "getLine",
    "text": "const getLine: (question: string) => Task<string> = (question) => () =>\n  new Promise((resolve) => {\n    const rl = createInterface({\n      input: process.stdin,\n      output: process.stdout\n    })\n\n    rl.question(question, (answer) => {\n      rl.close()\n      resolve(answer)\n    })\n  })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "question",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => Promise<unknown>"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Task/getLine.ts",
      "lines": {
        "from": 10,
        "to": 21
      }
    }
  },
  {
    "name": "withTimeout",
    "text": "const withTimeout = <A>(onTimeout: A, millis: number): ((ma: Task<A>) => Task<A>) => {\n  const M = getRaceMonoid<A>()\n  const fallback = delay(millis)(of(onTimeout))\n  return (ma) => M.concat(ma, fallback)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onTimeout",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "millis",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: any) => any"
      }
    },
    "module": "fp-ts-contrib",
    "location": {
      "path": "src/Task/withTimeout.ts",
      "lines": {
        "from": 26,
        "to": 30
      }
    }
  },
  {
    "name": "copyPackageJson",
    "text": "const copyPackageJson: Build<void> = (C) =>\n  pipe(\n    C.readFile(PKG),\n    TE.chain((s) => TE.fromEither(E.parseJSON(s, E.toError))),\n    TE.map((v) => {\n      const clone = Object.assign({}, v as any)\n\n      delete clone.scripts\n      delete clone.files\n      delete clone.devDependencies\n\n      return clone\n    }),\n    TE.chain((json) => C.writeFile(path.join(OUTPUT_FOLDER, PKG), JSON.stringify(json, null, 2)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 15,
        "to": 29
      }
    }
  },
  {
    "name": "copyFiles",
    "text": "const copyFiles: Build<ReadonlyArray<void>> = (C) =>\n  A.readonlyArray.traverse(TE.taskEither)(FILES, (from) => C.copyFile(from, path.resolve(OUTPUT_FOLDER, from)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 33,
        "to": 34
      }
    }
  },
  {
    "name": "makeModules",
    "text": "const makeModules: Build<void> = (C) =>\n  pipe(\n    C.glob(`${OUTPUT_FOLDER}/lib/*.js`),\n    TE.map(getModules),\n    TE.chain((modules) => traverse(modules, makeSingleModule(C))),\n    TE.map(() => undefined)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 38,
        "to": 44
      }
    }
  },
  {
    "name": "run",
    "text": "\n\nexport function run<A>(eff: TaskEither<Error, A>): void {\n  eff()\n    .then(\n      fold(\n        (e) => {\n          throw e\n        },\n        (_) => {\n          process.exitCode = 0\n        }\n      )\n    )\n    .catch((e) => {\n      console.error(e) // tslint:disable-line no-console\n\n      process.exitCode = 1\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eff",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "scripts/run.ts",
      "lines": {
        "from": 4,
        "to": 21
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function make<I, O, A>(decoder: D.Decoder<I, A>, encoder: E.Encoder<O, A>): Codec<I, O, A> {\n  return {\n    decode: decoder.decode,\n    encode: encoder.encode\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
          }
        },
        {
          "name": "encoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 41,
        "to": 46
      }
    }
  },
  {
    "name": "fromDecoder",
    "text": "\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function fromDecoder<I, A>(decoder: D.Decoder<I, A>): Codec<I, A, A> {\n  return {\n    decode: decoder.decode,\n    encode: identity\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, A, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 52,
        "to": 57
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n/**\n * @category constructors\n * @since 2.2.3\n */\nexport function literal<A extends readonly [Literal, ...Array<Literal>]>(\n  ...values: A\n): Codec<unknown, A[number], A[number]> {\n  return fromDecoder(D.literal(...values))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, A[number], A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 63,
        "to": 67
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function nullable<I, O, A>(or: Codec<I, O, A>): Codec<null | I, null | O, null | A> {\n  return make(D.nullable(or), E.nullable(or))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 141,
        "to": 143
      }
    }
  },
  {
    "name": "fromStruct",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function fromStruct<P extends Record<string, Codec<any, any, any>>>(\n  properties: P\n): Codec<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return make(D.fromStruct(properties) as any, E.struct(properties))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 149,
        "to": 153
      }
    }
  },
  {
    "name": "struct",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function struct<P extends Record<string, Codec<unknown, any, any>>>(\n  properties: P\n): Codec<unknown, { [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return pipe(UnknownRecord, compose(fromStruct(properties as any))) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 168,
        "to": 172
      }
    }
  },
  {
    "name": "fromPartial",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport function fromPartial<P extends Record<string, Codec<any, any, any>>>(\n  properties: P\n): Codec<\n  Partial<{ [K in keyof P]: InputOf<P[K]> }>,\n  Partial<{ [K in keyof P]: OutputOf<P[K]> }>,\n  Partial<{ [K in keyof P]: TypeOf<P[K]> }>\n> {\n  return make(D.fromPartial(properties), E.partial(properties))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 187,
        "to": 195
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Codec<unknown, any, any>>>(\n  properties: P\n): Codec<unknown, Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return pipe(UnknownRecord, compose(fromPartial(properties as any))) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 201,
        "to": 205
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function fromArray<I, O, A>(item: Codec<I, O, A>): Codec<Array<I>, Array<O>, Array<A>> {\n  return make(D.fromArray(item), E.array(item))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I[], O[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 211,
        "to": 213
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function array<O, A>(item: Codec<unknown, O, A>): Codec<unknown, Array<O>, Array<A>> {\n  return pipe(UnknownArray, compose(fromArray(item))) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, O[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 219,
        "to": 221
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function fromRecord<I, O, A>(\n  codomain: Codec<I, O, A>\n): Codec<Record<string, I>, Record<string, O>, Record<string, A>> {\n  return make(D.fromRecord(codomain), E.record(codomain))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<Record<string, I>, Record<string, O>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 227,
        "to": 231
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Codec<unknown, O, A>): Codec<unknown, Record<string, O>, Record<string, A>> {\n  return pipe(UnknownRecord, compose(fromRecord(codomain))) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, Record<string, O>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 237,
        "to": 239
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Codec<unknown, any, any>>>(\n  ...components: C\n): Codec<unknown, { [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return pipe(UnknownArray as any, compose(fromTuple(...components) as any)) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 254,
        "to": 258
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <M extends Record<string, Codec<unknown, any, any>>>(\n  members: M\n) => Codec<unknown, OutputOf<M[keyof M]>, TypeOf<M[keyof M]>> {\n  const sum = fromSum(tag)\n  return (members) => pipe(UnknownRecord, compose(sum(members) as any)) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, any, any>>>(members: M) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<unknown, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<M[keyof M]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<M[keyof M]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 290,
        "to": 297
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function lazy<I, O, A>(id: string, f: () => Codec<I, O, A>): Codec<I, O, A> {\n  return make(D.lazy(id, f), E.lazy(f))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 303,
        "to": 305
      }
    }
  },
  {
    "name": "mapLeftWithInput",
    "text": "const mapLeftWithInput = <I>(f: (i: I, e: D.DecodeError) => D.DecodeError) => <O, A>(\n  codec: Codec<I, O, A>\n): Codec<I, O, A> => make(pipe(codec, D.mapLeftWithInput(f)), codec)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: I, e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<O, A>(codec: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 121,
        "to": 123
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I, O>(from: Codec<I, O, A>) => Codec<I, O, B>) => {\n  const refine = D.refine(refinement, id)\n  return (from) => make(refine(from), from)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, O>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 129,
        "to": 135
      }
    }
  },
  {
    "name": "fromTuple",
    "text": "const fromTuple = <C extends ReadonlyArray<Codec<any, any, any>>>(\n  ...components: C\n): Codec<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  make(D.fromTuple(...components) as any, E.tuple(...components)) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 245,
        "to": 248
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <IB, OB, B>(\n  right: Codec<IB, OB, B>\n): (<IA, OA, A>(left: Codec<IA, OA, A>) => Codec<IA & IB, OA & OB, A & B>) => {\n  const intersectD = D.intersect(right)\n  const intersectE = E.intersect(right)\n  return (left) => make(intersectD(left), intersectE(left))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<IB, OB, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<IA, OA, A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<IA, OA, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<IA & IB, OA & OB, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 264,
        "to": 270
      }
    }
  },
  {
    "name": "fromSum",
    "text": "const fromSum = <T extends string>(\n  tag: T\n): (<MS extends Record<string, Codec<any, any, any>>>(\n  members: MS\n) => Codec<InputOf<MS[keyof MS]>, OutputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>>) => {\n  const decoder = D.fromSum(tag)\n  const encoder = E.sum(tag)\n  return (members) => make(decoder(members) as any, encoder(members))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<MS extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<any, any, any>>>(members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, MS[keyof MS]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<MS[keyof MS]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 276,
        "to": 284
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose = <L, A extends L, P extends A, B>(to: Codec<L, P, B>) => <I, O>(\n  from: Codec<I, O, A>\n): Codec<I, O, B> => make(D.compose(to)(from), E.compose(from)(to))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "to",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<L, P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, O>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 317,
        "to": 319
      }
    }
  },
  {
    "name": "imap",
    "text": "const imap: <I, O, A, B>(f: (a: A) => B, g: (b: B) => A) => (fa: Codec<I, O, A>) => Codec<I, O, B> = (f, g) => (\n  fa\n) => imap_(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Codec\").Codec<I, O, A>) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Codec.ts",
      "lines": {
        "from": 335,
        "to": 337
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<E = never>(): Semigroup<FS.FreeSemigroup<DecodeError<E>>> {\n  return FS.getSemigroup()\n}",
    "docs": "/**\n * @category instances\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 193,
        "to": 195
      }
    }
  },
  {
    "name": "leaf",
    "text": "const leaf = <E>(actual: unknown, error: E): DecodeError<E> => ({ _tag: 'Leaf', actual, error })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "error",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 104,
        "to": 104
      }
    }
  },
  {
    "name": "key",
    "text": "const key = <E>(key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Key',\n  key,\n  kind,\n  errors\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "key",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "kind",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").Kind"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 110,
        "to": 115
      }
    }
  },
  {
    "name": "index",
    "text": "const index = <E>(index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Index',\n  index,\n  kind,\n  errors\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "index",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "kind",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").Kind"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 121,
        "to": 126
      }
    }
  },
  {
    "name": "member",
    "text": "const member = <E>(index: number, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Member',\n  index,\n  errors\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "index",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 132,
        "to": 136
      }
    }
  },
  {
    "name": "lazy",
    "text": "const lazy = <E>(id: string, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Lazy',\n  id,\n  errors\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 142,
        "to": 146
      }
    }
  },
  {
    "name": "wrap",
    "text": "const wrap = <E>(error: E, errors: FS.FreeSemigroup<DecodeError<E>>): DecodeError<E> => ({\n  _tag: 'Wrap',\n  error,\n  errors\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "error",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 152,
        "to": 156
      }
    }
  },
  {
    "name": "fold",
    "text": "const fold = <E, R>(patterns: {\n  Leaf: (input: unknown, error: E) => R\n  Key: (key: string, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Index: (index: number, kind: Kind, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Member: (index: number, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Lazy: (id: string, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n  Wrap: (error: E, errors: FS.FreeSemigroup<DecodeError<E>>) => R\n}): ((e: DecodeError<E>) => R) => {\n  const f = (e: DecodeError<E>): R => {\n    switch (e._tag) {\n      case 'Leaf':\n        return patterns.Leaf(e.actual, e.error)\n      case 'Key':\n        return patterns.Key(e.key, e.kind, e.errors)\n      case 'Index':\n        return patterns.Index(e.index, e.kind, e.errors)\n      case 'Member':\n        return patterns.Member(e.index, e.errors)\n      case 'Lazy':\n        return patterns.Lazy(e.id, e.errors)\n      case 'Wrap':\n        return patterns.Wrap(e.error, e.errors)\n    }\n  }\n  return f\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "patterns",
          "type": {
            "__tag": "Other",
            "values": "{ Leaf: (input: unknown, error: E) => R; Key: (key: string, kind: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").Kind, errors: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>) => R; Index: (index: number, kind: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").Kind, errors: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>) => R; Member: (index: number, errors: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>) => R; Lazy: (id: string, errors: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>) => R; Wrap: (error: E, errors: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>>) => R; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<E>) => R"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/DecodeError.ts",
      "lines": {
        "from": 162,
        "to": 187
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap = <A, B>(\n  fab: E.Either<DecodeError, (a: A) => B>,\n  fa: E.Either<DecodeError, A>\n): E.Either<DecodeError, B> =>\n  E.isLeft(fab)\n    ? E.isLeft(fa)\n      ? E.left(SE.concat(fab.left, fa.left))\n      : fab\n    : E.isLeft(fa)\n    ? fa\n    : E.right(fab.right(fa.right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fab",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 39,
        "to": 49
      }
    }
  },
  {
    "name": "error",
    "text": "const error = (actual: unknown, message: string): DecodeError => FS.of(DE.leaf(actual, message))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 94,
        "to": 94
      }
    }
  },
  {
    "name": "failure",
    "text": "const failure = <A = never>(actual: unknown, message: string): E.Either<DecodeError, A> =>\n  E.left(error(actual, message))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 106,
        "to": 107
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): Decoder<I, A> =>\n  K.fromRefinement(M)(refinement, (u) => error(u, expected))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 117,
        "to": 118
      }
    }
  },
  {
    "name": "fromGuard",
    "text": "const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): Decoder<I, A> =>\n  fromRefinement(guard.is, expected)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "guard",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 124,
        "to": 125
      }
    }
  },
  {
    "name": "withMessage",
    "text": "const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: Decoder<I, A>) => Decoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "message",
          "type": {
            "__tag": "Other",
            "values": "(input: I, e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(decoder: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 199,
        "to": 202
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: Decoder<I, A>) => Decoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 208,
        "to": 211
      }
    }
  },
  {
    "name": "fromStruct",
    "text": "const fromStruct = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 233,
        "to": 236
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(\n  properties: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, { [K in keyof A]: A[K] }> => pipe(UnknownRecord as any, compose(fromStruct(properties)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, { [K in keyof A]: A[K]; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 251,
        "to": 253
      }
    }
  },
  {
    "name": "fromPartial",
    "text": "const fromPartial = <P extends Record<string, Decoder<any, any>>>(\n  properties: P\n): Decoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 268,
        "to": 271
      }
    }
  },
  {
    "name": "partial",
    "text": "const partial = <A>(\n  properties: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, Partial<{ [K in keyof A]: A[K] }>> => pipe(UnknownRecord as any, compose(fromPartial(properties)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, Partial<{ [K in keyof A]: A[K]; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 277,
        "to": 279
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <I, A>(item: Decoder<I, A>): Decoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 285,
        "to": 286
      }
    }
  },
  {
    "name": "array",
    "text": "const array = <A>(item: Decoder<unknown, A>): Decoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 292,
        "to": 293
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "const fromRecord = <I, A>(codomain: Decoder<I, A>): Decoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<Record<string, I>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 299,
        "to": 300
      }
    }
  },
  {
    "name": "record",
    "text": "const record = <A>(codomain: Decoder<unknown, A>): Decoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 306,
        "to": 307
      }
    }
  },
  {
    "name": "fromTuple",
    "text": "const fromTuple = <C extends ReadonlyArray<Decoder<any, any>>>(\n  ...components: C\n): Decoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 313,
        "to": 316
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Decoder<unknown, A[K]> }\n): Decoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 322,
        "to": 324
      }
    }
  },
  {
    "name": "fromSum",
    "text": "const fromSum = <T extends string>(tag: T) => <MS extends Record<string, Decoder<any, any>>>(\n  members: MS\n): Decoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n  K.fromSum(M)((tag, value, keys) =>\n    FS.of(\n      DE.key(\n        tag,\n        DE.required,\n        error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n      )\n    )\n  )(tag)(members)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<MS extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<any, any>>>(members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, MS[keyof MS]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 348,
        "to": 359
      }
    }
  },
  {
    "name": "sum",
    "text": "const sum = <T extends string>(tag: T) => <A>(\n  members: { [K in keyof A]: Decoder<unknown, A[K] & Record<T, K>> }\n): Decoder<unknown, A[keyof A]> => pipe(UnknownRecord as any, compose(fromSum(tag)(members)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<unknown, A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 365,
        "to": 367
      }
    }
  },
  {
    "name": "draw",
    "text": "const draw = (e: DecodeError): string => toForest(e).map(drawTree).join('\\n')",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Decoder.ts",
      "lines": {
        "from": 604,
        "to": 604
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function nullable<O, A>(or: Encoder<O, A>): Encoder<null | O, null | A> {\n  return {\n    encode: (a) => (a === null ? null : or.encode(a))\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 36,
        "to": 40
      }
    }
  },
  {
    "name": "struct",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function struct<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<{ [K in keyof P]: OutputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        o[k] = properties[k].encode(a[k])\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 46,
        "to": 58
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function partial<P extends Record<string, Encoder<any, any>>>(\n  properties: P\n): Encoder<Partial<{ [K in keyof P]: OutputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> {\n  return {\n    encode: (a) => {\n      const o: Record<keyof P, any> = {} as any\n      for (const k in properties) {\n        const v = a[k]\n        // don't add missing properties\n        if (k in a) {\n          // don't strip undefined properties\n          o[k] = v === undefined ? undefined : properties[k].encode(v)\n        }\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 73,
        "to": 90
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function record<O, A>(codomain: Encoder<O, A>): Encoder<Record<string, O>, Record<string, A>> {\n  return {\n    encode: (r) => {\n      const o: Record<string, O> = {}\n      for (const k in r) {\n        o[k] = codomain.encode(r[k])\n      }\n      return o\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<Record<string, O>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 96,
        "to": 106
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function array<O, A>(item: Encoder<O, A>): Encoder<Array<O>, Array<A>> {\n  return {\n    encode: (as) => as.map(item.encode)\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 112,
        "to": 116
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function tuple<C extends ReadonlyArray<Encoder<any, any>>>(\n  ...components: C\n): Encoder<{ [K in keyof C]: OutputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> {\n  return {\n    encode: (as) => components.map((c, i) => c.encode(as[i])) as any\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 122,
        "to": 128
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function sum<T extends string>(\n  tag: T\n): <MS extends Record<string, Encoder<any, any>>>(\n  members: MS\n) => Encoder<OutputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> {\n  return (members) => {\n    return {\n      encode: (a) => members[a[tag]].encode(a)\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<MS extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<any, any>>>(members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").OutputOf<MS[keyof MS]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").TypeOf<MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 142,
        "to": 152
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.3\n */\nexport function lazy<O, A>(f: () => Encoder<O, A>): Encoder<O, A> {\n  const get = memoize<void, Encoder<O, A>>(f)\n  return {\n    encode: (a) => get().encode(a)\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 158,
        "to": 163
      }
    }
  },
  {
    "name": "id",
    "text": "\n\n/**\n * @category Category\n * @since 2.2.3\n */\nexport function id<A>(): Encoder<A, A> {\n  return {\n    encode: identity\n  }\n}",
    "docs": "/**\n * @category Category\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<A, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 203,
        "to": 207
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <P, B>(right: Encoder<P, B>) => <O, A>(left: Encoder<O, A>): Encoder<O & P, A & B> => ({\n  encode: (ab) => intersect_(left.encode(ab), right.encode(ab))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<P, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<O, A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<O & P, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 134,
        "to": 136
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Encoder<E, A>) => Encoder<E, B> = (f) => (fa) =>\n  contramap_(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 189,
        "to": 190
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <E, A>(ea: Encoder<E, A>) => <B>(ab: Encoder<A, B>) => Encoder<E, B> = (ea) => (ab) =>\n  compose_(ab, ea)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(ab: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<A, B>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Encoder\").Encoder<E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Encoder.ts",
      "lines": {
        "from": 196,
        "to": 197
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function nullable<A>(or: Eq<A>): Eq<null | A> {\n  return {\n    equals: (x, y) => (x === null || y === null ? x === y : or.equals(x, y))\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 86,
        "to": 90
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function partial<A>(properties: { [K in keyof A]: Eq<A[K]> }): Eq<Partial<{ [K in keyof A]: A[K] }>> {\n  return {\n    equals: (x, y) => {\n      for (const k in properties) {\n        const xk = x[k]\n        const yk = y[k]\n        if (!(xk === undefined || yk === undefined ? xk === yk : properties[k].equals(xk!, yk!))) {\n          return false\n        }\n      }\n      return true\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: any; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 111,
        "to": 124
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function sum<T extends string>(\n  tag: T\n): <A>(members: { [K in keyof A]: Eq<A[K] & Record<T, K>> }) => Eq<A[keyof A]> {\n  return (members: Record<string, Eq<any>>) => {\n    return {\n      equals: (x: Record<string, any>, y: Record<string, any>) => {\n        const vx = x[tag]\n        const vy = y[tag]\n        if (vx !== vy) {\n          return false\n        }\n        return members[vx].equals(x, y)\n      }\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: any; }) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 158,
        "to": 173
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.2\n */\nexport function lazy<A>(f: () => Eq<A>): Eq<A> {\n  const get = memoize<void, Eq<A>>(f)\n  return {\n    equals: (x, y) => get().equals(x, y)\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.2\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => any"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 179,
        "to": 184
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <B>(right: Eq<B>) => <A>(left: Eq<A>): Eq<A & B> => ({\n  equals: (x, y) => left.equals(x, y) && right.equals(x, y)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(left: any) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 150,
        "to": 152
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.2.7\n */\nexport function getSemigroup<A = never>(): Semigroup<FreeSemigroup<A>> {\n  return { concat }\n}",
    "docs": "/**\n * @category instances\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/FreeSemigroup.ts",
      "lines": {
        "from": 73,
        "to": 75
      }
    }
  },
  {
    "name": "of",
    "text": "const of = <A>(a: A): FreeSemigroup<A> => ({ _tag: 'Of', value: a })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/FreeSemigroup.ts",
      "lines": {
        "from": 42,
        "to": 42
      }
    }
  },
  {
    "name": "concat",
    "text": "const concat = <A>(left: FreeSemigroup<A>, right: FreeSemigroup<A>): FreeSemigroup<A> => ({\n  _tag: 'Concat',\n  left,\n  right\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/FreeSemigroup.ts",
      "lines": {
        "from": 48,
        "to": 52
      }
    }
  },
  {
    "name": "fold",
    "text": "const fold = <A, R>(onOf: (value: A) => R, onConcat: (left: FreeSemigroup<A>, right: FreeSemigroup<A>) => R) => (\n  f: FreeSemigroup<A>\n): R => {\n  switch (f._tag) {\n    case 'Of':\n      return onOf(f.value)\n    case 'Concat':\n      return onConcat(f.left, f.right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onOf",
          "type": {
            "__tag": "Other",
            "values": "(value: A) => R"
          }
        },
        {
          "name": "onConcat",
          "type": {
            "__tag": "Other",
            "values": "(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>, right: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(f: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<A>) => R"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/FreeSemigroup.ts",
      "lines": {
        "from": 58,
        "to": 67
      }
    }
  },
  {
    "name": "literal",
    "text": "const literal = <A extends readonly [Literal, ...Array<Literal>]>(...values: A): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A[number] => values.findIndex((a) => a === u) !== -1\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 49,
        "to": 51
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <I, A extends I, B extends A>(refinement: Refinement<A, B>) => (\n  from: Guard<I, A>\n): Guard<I, B> => ({\n  is: (i: I): i is B => from.is(i) && refinement(i)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 107,
        "to": 111
      }
    }
  },
  {
    "name": "nullable",
    "text": "const nullable = <I, A extends I>(or: Guard<I, A>): Guard<null | I, null | A> => ({\n  is: (i): i is null | A => i === null || or.is(i)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 117,
        "to": 119
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(\n  properties: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, { [K in keyof A]: A[K] }> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is {\n      [K in keyof A]: A[K]\n    } => {\n      for (const k in properties) {\n        if (!(k in r) || !properties[k].is(r[k])) {\n          return false\n        }\n      }\n      return true\n    })\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, { [K in keyof A]: A[K]; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 125,
        "to": 140
      }
    }
  },
  {
    "name": "partial",
    "text": "const partial = <A>(\n  properties: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, Partial<{ [K in keyof A]: A[K] }>> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Partial<A> => {\n      for (const k in properties) {\n        const v = r[k]\n        if (v !== undefined && !properties[k].is(v)) {\n          return false\n        }\n      }\n      return true\n    })\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, Partial<{ [K in keyof A]: A[K]; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 155,
        "to": 169
      }
    }
  },
  {
    "name": "array",
    "text": "const array = <A>(item: Guard<unknown, A>): Guard<unknown, Array<A>> =>\n  pipe(\n    UnknownArray,\n    refine((us): us is Array<A> => us.every(item.is))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 175,
        "to": 179
      }
    }
  },
  {
    "name": "record",
    "text": "const record = <A>(codomain: Guard<unknown, A>): Guard<unknown, Record<string, A>> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is Record<string, A> => {\n      for (const k in r) {\n        if (!codomain.is(r[k])) {\n          return false\n        }\n      }\n      return true\n    })\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 185,
        "to": 196
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A> => ({\n  is: (u): u is A => Array.isArray(u) && u.length === components.length && components.every((c, i) => c.is(u[i]))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 202,
        "to": 206
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <B>(right: Guard<unknown, B>) => <A>(left: Guard<unknown, A>): Guard<unknown, A & B> => ({\n  is: (u: unknown): u is A & B => left.is(u) && right.is(u)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 212,
        "to": 214
      }
    }
  },
  {
    "name": "union",
    "text": "const union = <A extends readonly [unknown, ...Array<unknown>]>(\n  ...members: { [K in keyof A]: Guard<unknown, A[K]> }\n): Guard<unknown, A[number]> => ({\n  is: (u: unknown): u is A | A[number] => members.some((m) => m.is(u))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 220,
        "to": 224
      }
    }
  },
  {
    "name": "sum",
    "text": "const sum = <T extends string>(tag: T) => <A>(\n  members: { [K in keyof A]: Guard<unknown, A[K] & Record<T, K>> }\n): Guard<unknown, A[keyof A]> =>\n  pipe(\n    UnknownRecord,\n    refine((r): r is any => {\n      const v = r[tag] as keyof A\n      if (v in members) {\n        return members[v].is(r)\n      }\n      return false\n    })\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 230,
        "to": 242
      }
    }
  },
  {
    "name": "lazy",
    "text": "const lazy = <A>(f: () => Guard<unknown, A>): Guard<unknown, A> => {\n  const get = memoize<void, Guard<unknown, A>>(f)\n  return {\n    is: (u: unknown): u is A => get().is(u)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<unknown, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 248,
        "to": 253
      }
    }
  },
  {
    "name": "alt",
    "text": "const alt = <I, A extends I>(that: () => Guard<I, A>) => (me: Guard<I, A>): Guard<I, A> => ({\n  is: (i): i is A => me.is(i) || that().is(i)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 265,
        "to": 267
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero = <I, A extends I>(): Guard<I, A> => ({\n  is: (_): _ is A => false\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 273,
        "to": 275
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose = <I, A extends I, B extends A>(to: Guard<A, B>) => (from: Guard<I, A>): Guard<I, B> => ({\n  is: (i): i is B => from.is(i) && to.is(i)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "to",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 281,
        "to": 283
      }
    }
  },
  {
    "name": "id",
    "text": "const id = <A>(): Guard<A, A> => ({\n  is: (_): _ is A => true\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<A, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Guard.ts",
      "lines": {
        "from": 289,
        "to": 291
      }
    }
  },
  {
    "name": "getFunctionName",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function getFunctionName(f: Function): string {\n  return (f as any).displayName || (f as any).name || `<function${f.length}>`\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 226,
        "to": 228
      }
    }
  },
  {
    "name": "getContextEntry",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function getContextEntry(key: string, decoder: Decoder<any, any>): ContextEntry {\n  return { key, type: decoder }\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "key",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ContextEntry"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 233,
        "to": 235
      }
    }
  },
  {
    "name": "appendContext",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function appendContext(c: Context, key: string, decoder: Decoder<any, any>, actual?: unknown): Context {\n  const len = c.length\n  const r = Array(len + 1)\n  for (let i = 0; i < len; i++) {\n    r[i] = c[i]\n  }\n  r[len] = { key, type: decoder, actual }\n  return r\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "c",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        },
        {
          "name": "key",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        },
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 240,
        "to": 248
      }
    }
  },
  {
    "name": "getDomainKeys",
    "text": "\n\n/**\n * @internal\n */\nexport function getDomainKeys<D extends Mixed>(domain: D): Record<string, unknown> | undefined {\n  if (isLiteralC(domain)) {\n    const literal = domain.value\n    if (string.is(literal)) {\n      return { [literal]: null }\n    }\n  } else if (isKeyofC(domain)) {\n    return domain.keys\n  } else if (isUnionC(domain)) {\n    const keys = domain.types.map((type) => getDomainKeys(type))\n    return keys.some(undefinedType.is) ? undefined : Object.assign({}, ...keys)\n  }\n  return undefined\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "domain",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 377,
        "to": 390
      }
    }
  },
  {
    "name": "mergeAll",
    "text": "\n\n/**\n * @internal\n */\nexport function mergeAll(base: any, us: Array<any>): any {\n  let equal = true\n  let primitive = true\n  const baseIsNotADictionary = !UnknownRecord.is(base)\n  for (const u of us) {\n    if (u !== base) {\n      equal = false\n    }\n    if (UnknownRecord.is(u)) {\n      primitive = false\n    }\n  }\n  if (equal) {\n    return base\n  } else if (primitive) {\n    return us[us.length - 1]\n  }\n  const r: any = {}\n  for (const u of us) {\n    for (const k in u) {\n      if (!r.hasOwnProperty(k) || baseIsNotADictionary || u[k] !== base[k]) {\n        r[k] = u[k]\n      }\n    }\n  }\n  return r\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "base",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "us",
          "type": {
            "__tag": "Other",
            "values": "any[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 463,
        "to": 489
      }
    }
  },
  {
    "name": "getTags",
    "text": "\n\n/**\n * @internal\n */\nexport function getTags(codec: Any): Tags {\n  if (lazyCodecs.indexOf(codec) !== -1) {\n    return emptyTags\n  }\n  if (isTypeC(codec) || isStrictC(codec)) {\n    let index: Tags = emptyTags\n    // tslint:disable-next-line: forin\n    for (const k in codec.props) {\n      const prop = codec.props[k]\n      if (isLiteralC(prop)) {\n        if (index === emptyTags) {\n          index = {}\n        }\n        index[k] = [prop.value]\n      }\n    }\n    return index\n  } else if (isExactC(codec) || isRefinementC(codec)) {\n    return getTags(codec.type)\n  } else if (isIntersectionC(codec)) {\n    return codec.types.reduce((tags, codec) => mergeTags(tags, getTags(codec)), emptyTags)\n  } else if (isUnionC(codec)) {\n    return codec.types.slice(1).reduce((tags, codec) => intersectTags(tags, getTags(codec)), getTags(codec.types[0]))\n  } else if (isRecursiveC(codec)) {\n    lazyCodecs.push(codec)\n    const tags = getTags(codec.type)\n    lazyCodecs.pop()\n    return tags\n  }\n  return emptyTags\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Tags"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 673,
        "to": 703
      }
    }
  },
  {
    "name": "getIndex",
    "text": "\n\n/**\n * @internal\n */\nexport function getIndex(codecs: NonEmptyArray<Any>): [string, NonEmptyArray<NonEmptyArray<LiteralValue>>] | undefined {\n  const tags = getTags(codecs[0])\n  const keys = Object.keys(tags)\n  const len = codecs.length\n  keys: for (const k of keys) {\n    const all = tags[k].slice()\n    const index: NonEmptyArray<NonEmptyArray<LiteralValue>> = [tags[k]]\n    for (let i = 1; i < len; i++) {\n      const codec = codecs[i]\n      const ctags = getTags(codec)\n      const values = ctags[k]\n      // tslint:disable-next-line: strict-type-predicates\n      if (values === undefined) {\n        continue keys\n      } else {\n        if (values.some((v) => all.indexOf(v) !== -1)) {\n          continue keys\n        } else {\n          all.push(...values)\n          index.push(values)\n        }\n      }\n    }\n    return [k, index]\n  }\n  return undefined\n}",
    "docs": "/**\n * @internal\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[string, NonEmptyArray<NonEmptyArray<LiteralValue>>]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 708,
        "to": 734
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function literal<V extends LiteralValue>(value: V, name: string = JSON.stringify(value)): LiteralC<V> {\n  const is = (u: unknown): u is V => u === value\n  return new LiteralType(name, is, (u, c) => (is(u) ? success(value) : failure(u, c)), identity, value)\n}",
    "docs": "/**\n * @category constructors\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Other",
            "values": "V"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").LiteralC<V>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1067,
        "to": 1070
      }
    }
  },
  {
    "name": "keyof",
    "text": "\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function keyof<D extends { [key: string]: unknown }>(\n  keys: D,\n  name: string = Object.keys(keys)\n    .map((k) => JSON.stringify(k))\n    .join(' | ')\n): KeyofC<D> {\n  const is = (u: unknown): u is keyof D => string.is(u) && hasOwnProperty.call(keys, u)\n  return new KeyofType(name, is, (u, c) => (is(u) ? success(u) : failure(u, c)), identity, keys)\n}",
    "docs": "/**\n * @category constructors\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "keys",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").KeyofC<D>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1100,
        "to": 1108
      }
    }
  },
  {
    "name": "brand",
    "text": "\n\n/**\n * @category combinators\n * @since 1.8.1\n */\nexport function brand<C extends Any, N extends string, B extends { readonly [K in N]: symbol }>(\n  codec: C,\n  predicate: Refinement<TypeOf<C>, Branded<TypeOf<C>, B>>,\n  name: N\n): BrandC<C, B> {\n  // tslint:disable-next-line: deprecation\n  return refinement(codec, predicate, name)\n}",
    "docs": "/**\n * @category combinators\n * @since 1.8.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "Other",
            "values": "N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").BrandC<C, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1157,
        "to": 1164
      }
    }
  },
  {
    "name": "recursion",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function recursion<A, O = A, I = unknown, C extends Type<A, O, I> = Type<A, O, I>>(\n  name: string,\n  definition: (self: C) => C\n): RecursiveType<C, A, O, I> {\n  let cache: C\n  const runDefinition = (): C => {\n    if (!cache) {\n      cache = definition(Self)\n      ;(cache as any).name = name\n    }\n    return cache\n  }\n  const Self: any = new RecursiveType<C, A, O, I>(\n    name,\n    (u): u is A => runDefinition().is(u),\n    (u, c) => runDefinition().validate(u, c),\n    (a) => runDefinition().encode(a),\n    runDefinition\n  )\n  return Self\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "definition",
          "type": {
            "__tag": "Other",
            "values": "(self: C) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RecursiveType<C, A, O, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1221,
        "to": 1241
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function array<C extends Mixed>(item: C, name: string = `Array<${item.name}>`): ArrayC<C> {\n  return new ArrayType(\n    name,\n    (u): u is Array<TypeOf<C>> => UnknownArray.is(u) && u.every(item.is),\n    (u, c) => {\n      const e = UnknownArray.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const us = e.right\n      const len = us.length\n      let as: Array<TypeOf<C>> = us\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const ui = us[i]\n        const result = item.validate(ui, appendContext(c, String(i), item, ui))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const ai = result.right\n          if (ai !== ui) {\n            if (as === us) {\n              as = us.slice()\n            }\n            as[i] = ai\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(as)\n    },\n    item.encode === identity ? identity : (a) => a.map(item.encode),\n    item\n  )\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ArrayC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1271,
        "to": 1304
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function type<P extends Props>(props: P, name: string = getInterfaceTypeName(props)): TypeC<P> {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new InterfaceType(\n    name,\n    (u): u is { [K in keyof P]: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = types[i]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const vak = result.right\n          if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [x: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const encode = types[i].encode\n            if (encode !== identity) {\n              s[k] = encode(a[k])\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1335,
        "to": 1397
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function partial<P extends Props>(\n  props: P,\n  name: string = getPartialTypeName(getInterfaceTypeName(props))\n): PartialC<P> {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new PartialType(\n    name,\n    (u): u is { [K in keyof P]?: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if (uk !== undefined && !props[k].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = props[k]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          if (ak !== undefined) {\n            pushAll(errors, result.left)\n          }\n        } else {\n          const vak = result.right\n          if (vak !== ak) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [key: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const ak = a[k]\n            if (ak !== undefined) {\n              s[k] = types[i].encode(ak)\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1428,
        "to": 1495
      }
    }
  },
  {
    "name": "record",
    "text": "\n\n/**\n * @category combinators\n * @since 1.7.1\n */\nexport function record<D extends Mixed, C extends Mixed>(domain: D, codomain: C, name?: string): RecordC<D, C> {\n  const keys = getDomainKeys(domain)\n  return keys\n    ? enumerableRecord(Object.keys(keys), domain, codomain, name)\n    : nonEnumerableRecord(domain, codomain, name)\n}",
    "docs": "/**\n * @category combinators\n * @since 1.7.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "domain",
          "type": {
            "__tag": "Other",
            "values": "D"
          }
        },
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RecordC<D, C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1527,
        "to": 1532
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function union<CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = getUnionName(codecs)\n): UnionC<CS> {\n  const index = getIndex(codecs)\n  if (index !== undefined && codecs.length > 0) {\n    const [tag, groups] = index\n    const len = groups.length\n    const find = (value: any): number | undefined => {\n      for (let i = 0; i < len; i++) {\n        if (groups[i].indexOf(value) !== -1) {\n          return i\n        }\n      }\n      return undefined\n    }\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(\n      name,\n      (u): u is TypeOf<CS[number]> => {\n        if (UnknownRecord.is(u)) {\n          const i = find(u[tag])\n          return i !== undefined ? codecs[i].is(u) : false\n        }\n        return false\n      },\n      (u, c) => {\n        const e = UnknownRecord.validate(u, c)\n        if (isLeft(e)) {\n          return e\n        }\n        const r = e.right\n        const i = find(r[tag])\n        if (i === undefined) {\n          return failure(u, c)\n        }\n        const codec = codecs[i]\n        return codec.validate(r, appendContext(c, String(i), codec, r))\n      },\n      useIdentity(codecs)\n        ? identity\n        : (a) => {\n            const i = find(a[tag])\n            if (i === undefined) {\n              // https://github.com/gcanti/io-ts/pull/305\n              throw new Error(`no codec found to encode value in union codec ${name}`)\n            } else {\n              return codecs[i].encode(a)\n            }\n          },\n      codecs,\n      tag\n    )\n  } else {\n    return new UnionType(\n      name,\n      (u): u is TypeOf<CS[number]> => codecs.some((type) => type.is(u)),\n      (u, c) => {\n        const errors: Errors = []\n        for (let i = 0; i < codecs.length; i++) {\n          const codec = codecs[i]\n          const result = codec.validate(u, appendContext(c, String(i), codec, u))\n          if (isLeft(result)) {\n            pushAll(errors, result.left)\n          } else {\n            return success(result.right)\n          }\n        }\n        return failures(errors)\n      },\n      useIdentity(codecs)\n        ? identity\n        : (a) => {\n            for (const codec of codecs) {\n              if (codec.is(a)) {\n                return codec.encode(a)\n              }\n            }\n            // https://github.com/gcanti/io-ts/pull/305\n            throw new Error(`no codec found to encode value in union type ${name}`)\n          },\n      codecs\n    )\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").UnionC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1563,
        "to": 1647
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed, E extends Mixed>(\n  codecs: [A, B, C, D, E],\n  name?: string\n): IntersectionC<[A, B, C, D, E]>",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D, E]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C, D, E]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1699,
        "to": 1702
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed>(\n  codecs: [A, B, C, D],\n  name?: string\n): IntersectionC<[A, B, C, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C, D]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1703,
        "to": 1706
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed, C extends Mixed>(\n  codecs: [A, B, C],\n  name?: string\n): IntersectionC<[A, B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B, C]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1707,
        "to": 1710
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A extends Mixed, B extends Mixed>(codecs: [A, B], name?: string): IntersectionC<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[A, B]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1711,
        "to": 1711
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = `(${codecs.map((type) => type.name).join(' & ')})`\n): IntersectionC<CS> {\n  const len = codecs.length\n  return new IntersectionType(\n    name,\n    (u: unknown): u is any => codecs.every((type) => type.is(u)),\n    codecs.length === 0\n      ? success\n      : (u, c) => {\n          const us: Array<unknown> = []\n          const errors: Errors = []\n          for (let i = 0; i < len; i++) {\n            const codec = codecs[i]\n            const result = codec.validate(u, appendContext(c, String(i), codec, u))\n            if (isLeft(result)) {\n              pushAll(errors, result.left)\n            } else {\n              us.push(result.right)\n            }\n          }\n          return errors.length > 0 ? failures(errors) : success(mergeAll(u, us))\n        },\n    codecs.length === 0\n      ? identity\n      : (a) =>\n          mergeAll(\n            a,\n            codecs.map((codec) => codec.encode(a))\n          ),\n    codecs\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1712,
        "to": 1745
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed, E extends Mixed>(\n  codecs: [A, B, C, D, E],\n  name?: string\n): TupleC<[A, B, C, D, E]>",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D, E]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C, D, E]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1801,
        "to": 1804
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed, D extends Mixed>(\n  codecs: [A, B, C, D],\n  name?: string\n): TupleC<[A, B, C, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C, D]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C, D]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1805,
        "to": 1808
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed, C extends Mixed>(\n  codecs: [A, B, C],\n  name?: string\n): TupleC<[A, B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B, C]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B, C]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1809,
        "to": 1812
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed, B extends Mixed>(codecs: [A, B], name?: string): TupleC<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A, B]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A, B]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1813,
        "to": 1813
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<A extends Mixed>(codecs: [A], name?: string): TupleC<[A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "[A]"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<[A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1814,
        "to": 1814
      }
    }
  },
  {
    "name": "tuple",
    "text": "\nexport function tuple<CS extends [Mixed, ...Array<Mixed>]>(\n  codecs: CS,\n  name: string = `[${codecs.map((type) => type.name).join(', ')}]`\n): TupleC<CS> {\n  const len = codecs.length\n  return new TupleType(\n    name,\n    (u): u is any => UnknownArray.is(u) && u.length === len && codecs.every((type, i) => type.is(u[i])),\n    (u, c) => {\n      const e = UnknownArray.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const us = e.right\n      let as: Array<any> = us.length > len ? us.slice(0, len) : us // strip additional components\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const a = us[i]\n        const type = codecs[i]\n        const result = type.validate(a, appendContext(c, String(i), type, a))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const va = result.right\n          if (va !== a) {\n            /* istanbul ignore next */\n            if (as === us) {\n              as = us.slice()\n            }\n            as[i] = va\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(as)\n    },\n    useIdentity(codecs) ? identity : (a) => codecs.map((type, i) => type.encode(a[i])),\n    codecs\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TupleC<CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1815,
        "to": 1853
      }
    }
  },
  {
    "name": "readonly",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonly<C extends Mixed>(codec: C, name: string = `Readonly<${codec.name}>`): ReadonlyC<C> {\n  return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec)\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ReadonlyC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1884,
        "to": 1886
      }
    }
  },
  {
    "name": "readonlyArray",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonlyArray<C extends Mixed>(\n  item: C,\n  name: string = `ReadonlyArray<${item.name}>`\n): ReadonlyArrayC<C> {\n  const codec = array(item)\n  return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item) as any\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ReadonlyArrayC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1917,
        "to": 1923
      }
    }
  },
  {
    "name": "exact",
    "text": "\n\n/**\n * Strips additional properties.\n *\n * @category combinators\n * @since 1.1.0\n */\nexport function exact<C extends HasProps>(codec: C, name: string = getExactTypeName(codec)): ExactC<C> {\n  const props: Props = getProps(codec)\n  return new ExactType(\n    name,\n    codec.is,\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const ce = codec.validate(u, c)\n      if (isLeft(ce)) {\n        return ce\n      }\n      return right(stripKeys(ce.right, props))\n    },\n    (a) => codec.encode(stripKeys(a, props)),\n    codec\n  )\n}",
    "docs": "/**\n * Strips additional properties.\n *\n * @category combinators\n * @since 1.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ExactC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1963,
        "to": 1982
      }
    }
  },
  {
    "name": "refinement",
    "text": "\n\n/**\n * Use `brand` instead.\n *\n * @category combinators\n * @since 1.0.0\n * @deprecated\n */\nexport function refinement<C extends Any>(\n  codec: C,\n  predicate: Predicate<TypeOf<C>>,\n  name: string = `(${codec.name} | ${getFunctionName(predicate)})`\n): // tslint:disable-next-line: deprecation\nRefinementC<C> {\n  return new RefinementType(\n    name,\n    (u): u is TypeOf<C> => codec.is(u) && predicate(u),\n    (i, c) => {\n      const e = codec.validate(i, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const a = e.right\n      return predicate(a) ? success(a) : failure(a, c)\n    },\n    codec.encode,\n    codec,\n    predicate\n  )\n}",
    "docs": "/**\n * Use `brand` instead.\n *\n * @category combinators\n * @since 1.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        },
        {
          "name": "predicate",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").RefinementC<C>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2255,
        "to": 2276
      }
    }
  },
  {
    "name": "clean",
    "text": "\n\n/**\n * Drops the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */\nexport function clean<A, O = A, I = unknown>(codec: Type<A, O, I>): Type<A, O, I> {\n  return codec as any\n}",
    "docs": "/**\n * Drops the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2429,
        "to": 2431
      }
    }
  },
  {
    "name": "alias",
    "text": "\n\n/**\n * Keeps the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */\nexport function alias<A, O, P, I>(\n  codec: PartialType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => PartialType<PP, AA, OO, II>",
    "docs": "/**\n * Keeps the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2453,
        "to": 2463
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, P, I>(\n  // tslint:disable-next-line: deprecation\n  codec: StrictType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => // tslint:disable-next-line: deprecation\nStrictType<PP, AA, OO, II>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").StrictType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").StrictType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2464,
        "to": 2476
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, P, I>(\n  codec: InterfaceType<P, A, O, I>\n): <\n  // tslint:disable-next-line: deprecation\n  AA extends Exact<A, AA>,\n  // tslint:disable-next-line: deprecation\n  OO extends Exact<O, OO> = O,\n  // tslint:disable-next-line: deprecation\n  PP extends Exact<P, PP> = P,\n  II extends I = I\n>() => InterfaceType<PP, AA, OO, II>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").InterfaceType<P, A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O, PP extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<P, PP> = P, II extends I = I>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").InterfaceType<PP, AA, OO, II>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2477,
        "to": 2487
      }
    }
  },
  {
    "name": "alias",
    "text": "\nexport function alias<A, O, I>(\n  codec: Type<A, O, I>\n): // tslint:disable-next-line: deprecation\n<AA extends Exact<A, AA>, OO extends Exact<O, OO> = O>() => Type<AA, OO, I> {\n  return () => codec as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<A, O, I>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<AA extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<A, AA>, OO extends import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Exact<O, OO> = O>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<AA, OO, I>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2488,
        "to": 2493
      }
    }
  },
  {
    "name": "failure",
    "text": "const failure = <T>(value: unknown, context: Context, message?: string): Validation<T> =>\n  failures([{ value, context, message }])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "context",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 63,
        "to": 64
      }
    }
  },
  {
    "name": "identity",
    "text": "const identity = <A>(a: A): A => a",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 221,
        "to": 221
      }
    }
  },
  {
    "name": "strict",
    "text": "const strict = <P extends Props>(props: P, name?: string): ExactC<TypeC<P>> => exact(type(props), name)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ExactC<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1931,
        "to": 1931
      }
    }
  },
  {
    "name": "taggedUnion",
    "text": "const taggedUnion = <Tag extends string, CS extends [Mixed, Mixed, ...Array<Mixed>]>(\n  tag: Tag,\n  codecs: CS,\n  name: string = getUnionName(codecs)\n  // tslint:disable-next-line: deprecation\n): TaggedUnionC<Tag, CS> => {\n  const U = union(codecs, name)\n  // tslint:disable-next-line: deprecation\n  if (U instanceof TaggedUnionType) {\n    return U\n  } else {\n    console.warn(`[io-ts] Cannot build a tagged union for ${name}, returning a de-optimized union`)\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "Tag"
          }
        },
        {
          "name": "codecs",
          "type": {
            "__tag": "Other",
            "values": "CS"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TaggedUnionC<Tag, CS>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2063,
        "to": 2078
      }
    }
  },
  {
    "name": "type",
    "text": "\n\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function type<P extends Props>(props: P, name: string = getInterfaceTypeName(props)): TypeC<P> {\n  const keys = Object.keys(props)\n  const types = keys.map((key) => props[key])\n  const len = keys.length\n  return new InterfaceType(\n    name,\n    (u): u is { [K in keyof P]: TypeOf<P[K]> } => {\n      if (UnknownRecord.is(u)) {\n        for (let i = 0; i < len; i++) {\n          const k = keys[i]\n          const uk = u[k]\n          if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    },\n    (u, c) => {\n      const e = UnknownRecord.validate(u, c)\n      if (isLeft(e)) {\n        return e\n      }\n      const o = e.right\n      let a = o\n      const errors: Errors = []\n      for (let i = 0; i < len; i++) {\n        const k = keys[i]\n        const ak = a[k]\n        const type = types[i]\n        const result = type.validate(ak, appendContext(c, k, type, ak))\n        if (isLeft(result)) {\n          pushAll(errors, result.left)\n        } else {\n          const vak = result.right\n          if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = { ...o }\n            }\n            a[k] = vak\n          }\n        }\n      }\n      return errors.length > 0 ? failures(errors) : success(a as any)\n    },\n    useIdentity(types)\n      ? identity\n      : (a) => {\n          const s: { [x: string]: any } = { ...a }\n          for (let i = 0; i < len; i++) {\n            const k = keys[i]\n            const encode = types[i].encode\n            if (encode !== identity) {\n              s[k] = encode(a[k])\n            }\n          }\n          return s as any\n        },\n    props\n  )\n}",
    "docs": "/**\n * @category combinators\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "props",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<P>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 1335,
        "to": 1397
      }
    }
  },
  {
    "name": "getValidationError",
    "text": "const getValidationError /* istanbul ignore next */ = (value: unknown, context: Context): ValidationError => ({\n  value,\n  context\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "context",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ValidationError"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2114,
        "to": 2117
      }
    }
  },
  {
    "name": "getDefaultContext",
    "text": "const getDefaultContext /* istanbul ignore next */ = (decoder: Decoder<any, any>): Context => [\n  { key: '', type: decoder }\n]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Decoder<any, any>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Context"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/index.ts",
      "lines": {
        "from": 2123,
        "to": 2125
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function fromRefinement<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I, A extends I>(refinement: Refinement<I, A>, onError: (i: I) => E) => Kleisli<M, I, E, A> {\n  return (refinement, onError) => ({\n    decode: (i) => (refinement(i) ? M.of(i) : M.throwError(onError(i)))\n  })\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A extends I>(refinement: any, onError: (i: I) => E) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 44,
        "to": 50
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n/**\n * @category constructors\n * @since 2.2.7\n */\nexport function literal<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): <I>(\n  onError: (i: I, values: readonly [Literal, ...Array<Literal>]) => E\n) => <A extends readonly [Literal, ...Array<Literal>]>(...values: A) => Kleisli<M, I, E, A[number]> {\n  return (onError) => <A extends readonly [Literal, ...Array<Literal>]>(...values: A) => ({\n    decode: (i) => (G.literal(...values).is(i) ? M.of<A[number]>(i) : M.throwError(onError(i, values)))\n  })\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(onError: (i: I, values: readonly [LiteralValue, ...LiteralValue[]]) => E) => <A extends readonly [LiteralValue, ...LiteralValue[]]>(...values: A) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 56,
        "to": 64
      }
    }
  },
  {
    "name": "mapLeftWithInput",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function mapLeftWithInput<M extends URIS2>(\n  M: Bifunctor2<M>\n): <I, E>(f: (i: I, e: E) => E) => <A>(decoder: Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return (f) => (decoder) => ({\n    decode: (i) => M.mapLeft(decoder.decode(i), (e) => f(i, e))\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, E>(f: (i: I, e: E) => E) => <A>(decoder: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 74,
        "to": 80
      }
    }
  },
  {
    "name": "refine",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function refine<M extends URIS2, E>(\n  M: MonadThrow2C<M, E> & Bifunctor2<M>\n): <A, B extends A>(\n  refinement: (a: A) => a is B,\n  onError: (a: A) => E\n) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (refinement, onError) => (from) => compose(M)(fromRefinement(M)(refinement, onError))(from)\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B extends A>(refinement: (a: A) => a is B, onError: (a: A) => E) => <I>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 86,
        "to": 93
      }
    }
  },
  {
    "name": "parse",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function parse<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(decode: (a: A) => Kind2<M, E, B>) => <I>(from: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (decode) => (from) => compose(M)({ decode })(from)\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(decode: (a: A) => any) => <I>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 99,
        "to": 103
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function nullable<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): <I>(onError: (i: I, e: E) => E) => <A>(or: Kleisli<M, I, E, A>) => Kleisli<M, null | I, E, null | A> {\n  return <I>(onError: (i: I, e: E) => E) => <A>(or: Kleisli<M, I, E, A>): Kleisli<M, null | I, E, null | A> => ({\n    decode: (i) =>\n      i === null\n        ? M.of<null | A>(null)\n        : M.bimap(\n            or.decode(i),\n            (e) => onError(i, e),\n            (a): A | null => a\n          )\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(onError: (i: I, e: E) => E) => <A>(or: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 109,
        "to": 122
      }
    }
  },
  {
    "name": "fromStruct",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.15\n */\nexport function fromStruct<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, { [K in keyof P]: InputOf<M, P[K]> }, E, { [K in keyof P]: TypeOf<M, P[K]> }> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) =>\n        M.mapLeft(decoder.decode(i[key]), (e) => onPropertyError(key, e))\n      ) as any\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.15\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onPropertyError: (key: string, e: E) => E) => <P extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>>>(properties: P) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<M, P[K]>; }, E, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<M, P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 128,
        "to": 142
      }
    }
  },
  {
    "name": "fromPartial",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromPartial<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onPropertyError: (key: string, e: E) => E\n) => <P extends Record<string, Kleisli<M, any, E, any>>>(\n  properties: P\n) => Kleisli<M, Partial<{ [K in keyof P]: InputOf<M, P[K]> }>, E, Partial<{ [K in keyof P]: TypeOf<M, P[K]> }>> {\n  const traverse = traverseRecordWithIndex(M)\n  const undefinedProperty = M.of<E.Either<void, unknown>>(E.right(undefined))\n  const skipProperty = M.of<E.Either<void, unknown>>(E.left(undefined))\n  return (onPropertyError) => (properties) => ({\n    decode: (i) =>\n      M.map(\n        traverse(properties as Record<string, Kleisli<M, unknown, E, unknown>>, (key, decoder) => {\n          const ikey = i[key]\n          if (ikey === undefined) {\n            return key in i\n              ? // don't strip undefined properties\n                undefinedProperty\n              : // don't add missing properties\n                skipProperty\n          }\n          return M.bimap(\n            decoder.decode(ikey),\n            (e) => onPropertyError(key, e),\n            (a) => E.right<void, unknown>(a)\n          )\n        }),\n        compactRecord\n      ) as any\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onPropertyError: (key: string, e: E) => E) => <P extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>>>(properties: P) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<M, P[K]>; }>, E, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<M, P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 157,
        "to": 188
      }
    }
  },
  {
    "name": "fromArray",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromArray<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (onItemError: (index: number, e: E) => E) => <I, A>(item: Kleisli<M, I, E, A>) => Kleisli<M, Array<I>, E, Array<A>> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onItemError) => (item) => ({\n    decode: (is) => traverse(is, (index, i) => M.mapLeft(item.decode(i), (e) => onItemError(index, e)))\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onItemError: (index: number, e: E) => E) => <I, A>(item: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I[], E, A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 194,
        "to": 201
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromRecord<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onKeyError: (key: string, e: E) => E\n) => <I, A>(codomain: Kleisli<M, I, E, A>) => Kleisli<M, Record<string, I>, E, Record<string, A>> {\n  const traverse = traverseRecordWithIndex(M)\n  return (onKeyError) => (codomain) => ({\n    decode: (ir) => traverse(ir, (key, i) => M.mapLeft(codomain.decode(i), (e) => onKeyError(key, e)))\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onKeyError: (key: string, e: E) => E) => <I, A>(codomain: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, Record<string, I>, E, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 207,
        "to": 216
      }
    }
  },
  {
    "name": "fromTuple",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromTuple<M extends URIS2, E>(\n  M: Applicative2C<M, E> & Bifunctor2<M>\n): (\n  onIndexError: (index: number, e: E) => E\n) => <C extends ReadonlyArray<Kleisli<M, any, E, any>>>(\n  ...components: C\n) => Kleisli<M, { [K in keyof C]: InputOf<M, C[K]> }, E, { [K in keyof C]: TypeOf<M, C[K]> }> {\n  const traverse = traverseArrayWithIndex(M)\n  return (onIndexError) => (...components) => ({\n    decode: (is) =>\n      traverse((components as unknown) as Array<Kleisli<M, unknown, E, unknown>>, (index, decoder) =>\n        M.mapLeft(decoder.decode(is[index]), (e) => onIndexError(index, e))\n      ) as any\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onIndexError: (index: number, e: E) => E) => <C extends readonly import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>[]>(...components: C) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<M, C[K]>; }, E, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<M, C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 222,
        "to": 236
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function union<M extends URIS2, E>(\n  M: Alt2C<M, E> & Bifunctor2<M>\n): (\n  onMemberError: (index: number, e: E) => E\n) => <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(\n  ...members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onMemberError) => <MS extends readonly [Kleisli<M, any, E, any>, ...Array<Kleisli<M, any, E, any>>]>(\n    ...members: MS\n  ) => ({\n    decode: (i) => {\n      let out: Kind2<M, E, TypeOf<M, MS[keyof MS]>> = M.mapLeft(members[0].decode(i), (e) => onMemberError(0, e))\n      for (let index = 1; index < members.length; index++) {\n        out = M.alt(out, () => M.mapLeft(members[index].decode(i), (e) => onMemberError(index, e)))\n      }\n      return out\n    }\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onMemberError: (index: number, e: E) => E) => <MS extends readonly [import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>, ...import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>[]]>(...members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<M, MS[keyof MS]>, E, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<M, MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 242,
        "to": 260
      }
    }
  },
  {
    "name": "intersect",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function intersect<M extends URIS2, E>(\n  M: Apply2C<M, E>\n): <IB, B>(right: Kleisli<M, IB, E, B>) => <IA, A>(left: Kleisli<M, IA, E, A>) => Kleisli<M, IA & IB, E, A & B> {\n  return <IB, B>(right: Kleisli<M, IB, E, B>) => <IA, A>(\n    left: Kleisli<M, IA, E, A>\n  ): Kleisli<M, IA & IB, E, A & B> => ({\n    decode: (i) =>\n      M.ap(\n        M.map(left.decode(i), (a: A) => (b: B) => intersect_(a, b)),\n        right.decode(i)\n      )\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<IB, B>(right: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, IB, E, B>) => <IA, A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, IA, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, IA & IB, E, A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 266,
        "to": 278
      }
    }
  },
  {
    "name": "fromSum",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function fromSum<M extends URIS2, E>(\n  M: MonadThrow2C<M, E>\n): (\n  onTagError: (tag: string, value: unknown, tags: ReadonlyArray<string>) => E\n) => <T extends string>(\n  tag: T\n) => <MS extends Record<string, Kleisli<M, any, E, any>>>(\n  members: MS\n) => Kleisli<M, InputOf<M, MS[keyof MS]>, E, TypeOf<M, MS[keyof MS]>> {\n  return (onTagError) => (tag) => <I extends Record<string, unknown>, A>(\n    members: { [K in keyof A]: Kleisli<M, I, E, A[K]> }\n  ): Kleisli<M, I, E, A[keyof A]> => {\n    const keys = Object.keys(members)\n    return {\n      decode: (ir) => {\n        const v: any = ir[tag]\n        if (v in members) {\n          return (members as any)[v].decode(ir)\n        }\n        return M.throwError(onTagError(tag, v, keys))\n      }\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onTagError: (tag: string, value: unknown, tags: readonly string[]) => E) => <T extends string>(tag: T) => <MS extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, any, E, any>>>(members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<M, MS[keyof MS]>, E, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<M, MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 284,
        "to": 307
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function lazy<M extends URIS2>(\n  M: Bifunctor2<M>\n): <E>(onError: (id: string, e: E) => E) => <I, A>(id: string, f: () => Kleisli<M, I, E, A>) => Kleisli<M, I, E, A> {\n  return <E>(onError: (id: string, e: E) => E) => <I, A>(\n    id: string,\n    f: () => Kleisli<M, I, E, A>\n  ): Kleisli<M, I, E, A> => {\n    const get = memoize<void, Kleisli<M, I, E, A>>(f)\n    return {\n      decode: (u) => M.mapLeft(get().decode(u), (e) => onError(id, e))\n    }\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onError: (id: string, e: E) => E) => <I, A>(id: string, f: () => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 313,
        "to": 325
      }
    }
  },
  {
    "name": "compose",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function compose<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(ab: Kleisli<M, A, E, B>) => <I>(ia: Kleisli<M, I, E, A>) => Kleisli<M, I, E, B> {\n  return (ab) => (ia) => ({\n    decode: (i) => M.chain(ia.decode(i), ab.decode)\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(ab: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, A, E, B>) => <I>(ia: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, I, E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 331,
        "to": 337
      }
    }
  },
  {
    "name": "id",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.8\n */\nexport function id<M extends URIS2, E>(M: Applicative2C<M, E>): <A>() => Kleisli<M, A, E, A> {\n  return () => ({\n    decode: M.of\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.8\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<M, A, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 343,
        "to": 347
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function map<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <A, B>(f: (a: A) => B) => <I>(ia: Kleisli<F, I, E, A>) => Kleisli<F, I, E, B> {\n  return (f) => (ia) => ({\n    decode: (i) => F.map(ia.decode(i), f)\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <I>(ia: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<F, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<F, I, E, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 353,
        "to": 359
      }
    }
  },
  {
    "name": "alt",
    "text": "\n\n/**\n * @category combinators\n * @since 2.2.7\n */\nexport function alt<F extends URIS2, E>(\n  A: Alt2C<F, E>\n): <I, A>(that: Lazy<Kleisli<F, I, E, A>>) => (me: Kleisli<F, I, E, A>) => Kleisli<F, I, E, A> {\n  return (that) => (me) => ({\n    decode: (i) => A.alt(me.decode(i), () => that().decode(i))\n  })\n}",
    "docs": "/**\n * @category combinators\n * @since 2.2.7\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I, A>(that: any) => (me: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<F, I, E, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").Kleisli<F, I, E, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Kleisli.ts",
      "lines": {
        "from": 365,
        "to": 371
      }
    }
  },
  {
    "name": "failure",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function failure(es: Array<ValidationError>): Array<string> {\n  return es.map(getMessage)\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "es",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").ValidationError[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "string[]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/PathReporter.ts",
      "lines": {
        "from": 34,
        "to": 36
      }
    }
  },
  {
    "name": "success",
    "text": "\n\n/**\n * @since 1.0.0\n */\nexport function success(): Array<string> {\n  return ['No errors!']\n}",
    "docs": "/**\n * @since 1.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "string[]"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/PathReporter.ts",
      "lines": {
        "from": 41,
        "to": 43
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.2.0\n */\nexport function make<A>(schema: Schema<A>): Schema<A> {\n  return memoize(schema)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "schema",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 34,
        "to": 36
      }
    }
  },
  {
    "name": "interpreter",
    "text": "\n\n/**\n * @since 2.2.3\n */\nexport function interpreter<S extends URIS2>(S: Schemable2C<S, unknown>): <A>(schema: Schema<A>) => Kind2<S, unknown, A>",
    "docs": "/**\n * @since 2.2.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schemable\").Schemable2C<S, unknown>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(schema: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "interpreter",
    "text": "\nexport function interpreter<S extends URIS>(S: Schemable1<S>): <A>(schema: Schema<A>) => Kind<S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schemable\").Schemable1<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(schema: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 51,
        "to": 51
      }
    }
  },
  {
    "name": "interpreter",
    "text": "\nexport function interpreter<S>(S: Schemable<S>): <A>(schema: Schema<A>) => HKT<S, A> {\n  return (schema) => schema(S)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schemable\").Schemable<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(schema: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Schema\").Schema<A>) => any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schema.ts",
      "lines": {
        "from": 52,
        "to": 54
      }
    }
  },
  {
    "name": "memoize",
    "text": "\n\n/**\n * @since 2.2.0\n */\nexport function memoize<A, B>(f: (a: A) => B): (a: A) => B {\n  const cache = new Map()\n  return (a) => {\n    if (!cache.has(a)) {\n      const b = f(a)\n      cache.set(a, b)\n      return b\n    }\n    return cache.get(a)\n  }\n}",
    "docs": "/**\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => B"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schemable.ts",
      "lines": {
        "from": 176,
        "to": 186
      }
    }
  },
  {
    "name": "intersect_",
    "text": "const intersect_ = <A, B>(a: A, b: B): A & B => {\n  if (a !== undefined && b !== undefined) {\n    const tx = typeOf(a)\n    const ty = typeOf(b)\n    if (tx === 'object' || ty === 'object') {\n      return Object.assign({}, a, b)\n    }\n  }\n  return b as any\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A & B"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Schemable.ts",
      "lines": {
        "from": 197,
        "to": 206
      }
    }
  },
  {
    "name": "failure",
    "text": "const failure = <A = never>(actual: unknown, message: string): TE.TaskEither<DecodeError, A> =>\n  TE.left(D.error(actual, message))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "message",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 99,
        "to": 100
      }
    }
  },
  {
    "name": "fromDecoder",
    "text": "const fromDecoder = <I, A>(decoder: D.Decoder<I, A>): TaskDecoder<I, A> => ({\n  decode: TE.fromEitherK(decoder.decode)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "decoder",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Decoder\").Decoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "fromRefinement",
    "text": "const fromRefinement = <I, A extends I>(refinement: Refinement<I, A>, expected: string): TaskDecoder<I, A> =>\n  fromDecoder(D.fromRefinement(refinement, expected))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 118,
        "to": 119
      }
    }
  },
  {
    "name": "fromGuard",
    "text": "const fromGuard = <I, A extends I>(guard: G.Guard<I, A>, expected: string): TaskDecoder<I, A> =>\n  fromRefinement(guard.is, expected)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "guard",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Guard\").Guard<I, A>"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 125,
        "to": 126
      }
    }
  },
  {
    "name": "withMessage",
    "text": "const withMessage = <I>(\n  message: (input: I, e: DecodeError) => string\n): (<A>(decoder: TaskDecoder<I, A>) => TaskDecoder<I, A>) =>\n  mapLeftWithInput((input, e) => FS.of(DE.wrap(message(input, e), e)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "message",
          "type": {
            "__tag": "Other",
            "values": "(input: I, e: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/FreeSemigroup\").FreeSemigroup<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/DecodeError\").DecodeError<string>>) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(decoder: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 200,
        "to": 203
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <A, B extends A>(\n  refinement: Refinement<A, B>,\n  id: string\n): (<I>(from: TaskDecoder<I, A>) => TaskDecoder<I, B>) => K.refine(M)(refinement, (a) => error(a, id))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<I>(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 209,
        "to": 212
      }
    }
  },
  {
    "name": "fromStruct",
    "text": "const fromStruct = <P extends Record<string, TaskDecoder<any, any>>>(\n  properties: P\n): TaskDecoder<{ [K in keyof P]: InputOf<P[K]> }, { [K in keyof P]: TypeOf<P[K]> }> =>\n  K.fromStruct(M)((k, e) => FS.of(DE.key(k, DE.required, e)))(properties)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }, { [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, P[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 236,
        "to": 239
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(\n  properties: { [K in keyof A]: TaskDecoder<unknown, A[K]> }\n): TaskDecoder<unknown, { [K in keyof A]: A[K] }> => pipe(UnknownRecord as any, compose(fromStruct(properties)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, { [K in keyof A]: A[K]; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 254,
        "to": 256
      }
    }
  },
  {
    "name": "fromPartial",
    "text": "const fromPartial = <P extends Record<string, TaskDecoder<any, any>>>(\n  properties: P\n): TaskDecoder<Partial<{ [K in keyof P]: InputOf<P[K]> }>, Partial<{ [K in keyof P]: TypeOf<P[K]> }>> =>\n  K.fromPartial(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(properties)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, P[K]>; }>, Partial<{ [K in keyof P]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, P[K]>; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 271,
        "to": 274
      }
    }
  },
  {
    "name": "partial",
    "text": "const partial = <A>(\n  properties: { [K in keyof A]: TaskDecoder<unknown, A[K]> }\n): TaskDecoder<unknown, Partial<{ [K in keyof A]: A[K] }>> =>\n  pipe(UnknownRecord as any, compose(fromPartial(properties)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, Partial<{ [K in keyof A]: A[K]; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 280,
        "to": 283
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <I, A>(item: TaskDecoder<I, A>): TaskDecoder<Array<I>, Array<A>> =>\n  K.fromArray(M)((i, e) => FS.of(DE.index(i, DE.optional, e)))(item)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I[], A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 289,
        "to": 290
      }
    }
  },
  {
    "name": "array",
    "text": "const array = <A>(item: TaskDecoder<unknown, A>): TaskDecoder<unknown, Array<A>> =>\n  pipe(UnknownArray, compose(fromArray(item)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 296,
        "to": 297
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "const fromRecord = <I, A>(codomain: TaskDecoder<I, A>): TaskDecoder<Record<string, I>, Record<string, A>> =>\n  K.fromRecord(M)((k, e) => FS.of(DE.key(k, DE.optional, e)))(codomain)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<I, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<Record<string, I>, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 303,
        "to": 304
      }
    }
  },
  {
    "name": "record",
    "text": "const record = <A>(codomain: TaskDecoder<unknown, A>): TaskDecoder<unknown, Record<string, A>> =>\n  pipe(UnknownRecord, compose(fromRecord(codomain)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 310,
        "to": 311
      }
    }
  },
  {
    "name": "fromTuple",
    "text": "const fromTuple = <C extends ReadonlyArray<TaskDecoder<any, any>>>(\n  ...components: C\n): TaskDecoder<{ [K in keyof C]: InputOf<C[K]> }, { [K in keyof C]: TypeOf<C[K]> }> =>\n  K.fromTuple(M)((i, e) => FS.of(DE.index(i, DE.required, e)))(...components) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<{ [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, C[K]>; }, { [K in keyof C]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, C[K]>; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 317,
        "to": 320
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: TaskDecoder<unknown, A[K]> }\n): TaskDecoder<unknown, A> => pipe(UnknownArray as any, compose(fromTuple(...components))) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 326,
        "to": 328
      }
    }
  },
  {
    "name": "fromSum",
    "text": "const fromSum = <T extends string>(tag: T) => <MS extends Record<string, TaskDecoder<any, any>>>(\n  members: MS\n): TaskDecoder<InputOf<MS[keyof MS]>, TypeOf<MS[keyof MS]>> =>\n  K.fromSum(M)((tag, value, keys) =>\n    FS.of(\n      DE.key(\n        tag,\n        DE.required,\n        error(value, keys.length === 0 ? 'never' : keys.map((k) => JSON.stringify(k)).join(' | '))\n      )\n    )\n  )(tag)(members)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<MS extends Record<string, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<any, any>>>(members: MS) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").InputOf<any, MS[keyof MS]>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Kleisli\").TypeOf<any, MS[keyof MS]>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 354,
        "to": 365
      }
    }
  },
  {
    "name": "sum",
    "text": "const sum = <T extends string>(tag: T) => <A>(\n  members: { [K in keyof A]: TaskDecoder<unknown, A[K] & Record<T, K>> }\n): TaskDecoder<unknown, A[keyof A]> => pipe(UnknownRecord as any, compose(fromSum(tag)(members)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/TaskDecoder\").TaskDecoder<unknown, A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/TaskDecoder.ts",
      "lines": {
        "from": 371,
        "to": 373
      }
    }
  },
  {
    "name": "literal",
    "text": "const literal = <A extends readonly [S.Literal, ...Array<S.Literal>]>(...values: A): Type<A[number]> =>\n  t.union(values.map((v) => t.literal(v as any)) as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 35,
        "to": 36
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <A, B extends A>(refinement: Refinement<A, B>, id: string) => (from: Type<A>): Type<B> =>\n  // tslint:disable-next-line: deprecation\n  t.refinement(from, refinement, id) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "nullable",
    "text": "const nullable = <A>(or: Type<A>): Type<null | A> => t.union([t.null, or])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 97,
        "to": 97
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(properties: { [K in keyof A]: Type<A[K]> }): Type<{ [K in keyof A]: A[K] }> =>\n  t.type(properties) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<{ [K in keyof A]: A[K]; }>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 103,
        "to": 104
      }
    }
  },
  {
    "name": "partial",
    "text": "const partial = <A>(properties: { [K in keyof A]: Type<A[K]> }): Type<Partial<{ [K in keyof A]: A[K] }>> =>\n  t.partial(properties)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<Partial<{ [K in keyof A]: A[K]; }>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 119,
        "to": 120
      }
    }
  },
  {
    "name": "record",
    "text": "const record = <A>(codomain: Type<A>): Type<Record<string, A>> => t.record(t.string, codomain)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 126,
        "to": 126
      }
    }
  },
  {
    "name": "array",
    "text": "const array = <A>(item: Type<A>): Type<Array<A>> => t.array(item)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 132,
        "to": 132
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(...components: { [K in keyof A]: Type<A[K]> }): Type<A> =>\n  t.tuple(components as any) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 138,
        "to": 139
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <B>(right: Type<B>) => <A>(left: Type<A>): Type<A & B> => t.intersection([left, right])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 145,
        "to": 145
      }
    }
  },
  {
    "name": "lazy",
    "text": "const lazy = <A>(id: string, f: () => Type<A>): Type<A> => t.recursion(id, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 151,
        "to": 151
      }
    }
  },
  {
    "name": "sum",
    "text": "const sum = <T extends string>(_tag: T) => <A>(\n  members: { [K in keyof A]: Type<A[K] & Record<T, K>> }\n): Type<A[keyof A]> => t.union(Object.values(members) as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "_tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 163,
        "to": 165
      }
    }
  },
  {
    "name": "union",
    "text": "const union = <A extends readonly [unknown, ...Array<unknown>]>(\n  ...members: { [K in keyof A]: Type<A[K]> }\n): Type<A[number]> => t.union(members as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/Type\").Type<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "src/Type.ts",
      "lines": {
        "from": 171,
        "to": 173
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\nexport function literal<A extends readonly [S.Literal, ...Array<S.Literal>]>(...values: A): Arbitrary<A[number]> {\n  return fc.oneof(...values.map((v) => fc.constant(v)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 18,
        "to": 20
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\nexport function nullable<A>(or: Arbitrary<A>): Arbitrary<null | A> {\n  return fc.oneof(fc.constant(null), or)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 49,
        "to": 51
      }
    }
  },
  {
    "name": "struct",
    "text": "\n\nexport function struct<A>(properties: { [K in keyof A]: Arbitrary<A[K]> }): Arbitrary<A> {\n  return fc.record(properties)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 53,
        "to": 55
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\nexport function partial<A>(properties: { [K in keyof A]: Arbitrary<A[K]> }): Arbitrary<Partial<A>> {\n  const keys = fc.oneof(...Object.keys(properties).map((p) => fc.constant(p)))\n  return keys.chain((key) => {\n    const p: any = { ...properties }\n    delete p[key]\n    return fc.record(p)\n  })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 57,
        "to": 64
      }
    }
  },
  {
    "name": "record",
    "text": "\n\nexport function record<A>(codomain: Arbitrary<A>): Arbitrary<Record<string, A>> {\n  return fc.dictionary(string, codomain)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "array",
    "text": "\n\nexport function array<A>(item: Arbitrary<A>): Arbitrary<Array<A>> {\n  return fc.array(item)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "item",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 70,
        "to": 72
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\nexport function tuple<A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: Arbitrary<A[K]> }\n): Arbitrary<A> {\n  if (components.length === 0) {\n    return fc.constant([]) as any\n  }\n  return (fc.tuple as any)(...components)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 74,
        "to": 81
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\nexport function sum<T extends string>(\n  _tag: T\n): <A>(members: { [K in keyof A]: Arbitrary<A[K] & Record<T, K>> }) => Arbitrary<A[keyof A]> {\n  return (members: Record<string, Arbitrary<any>>) => fc.oneof(...Object.keys(members).map((k) => members[k]))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "_tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 86,
        "to": 90
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\nexport function lazy<A>(f: () => Arbitrary<A>): Arbitrary<A> {\n  const get = S.memoize<void, Arbitrary<A>>(f)\n  return fc.constant(null).chain(() => get())\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 92,
        "to": 95
      }
    }
  },
  {
    "name": "union",
    "text": "\n\nexport function union<A extends [Arbitrary<unknown>, ...Array<Arbitrary<unknown>>]>(\n  ...members: { [K in keyof A]: Arbitrary<A[K]> }\n): Arbitrary<A[number]> {\n  return fc.oneof(...members)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 99,
        "to": 103
      }
    }
  },
  {
    "name": "refine",
    "text": "const refine = <A, B extends A>(refinement: Refinement<A, B>) => (from: Arbitrary<A>): Arbitrary<B> =>\n  from.filter(refinement)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(from: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 46,
        "to": 47
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <B>(right: Arbitrary<B>) => <A>(left: Arbitrary<A>): Arbitrary<A & B> =>\n  fc.tuple(left, right).map(([a, b]) => S.intersect_(a, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/Arbitrary\").Arbitrary<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Arbitrary.ts",
      "lines": {
        "from": 83,
        "to": 84
      }
    }
  },
  {
    "name": "parseJSON",
    "text": "\n\nexport function parseJSON<E>(s: string, onError: (reason: unknown) => E): E.Either<E, Json> {\n  return E.tryCatch(() => JSON.parse(s), onError)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/Codec.ts",
      "lines": {
        "from": 31,
        "to": 33
      }
    }
  },
  {
    "name": "literal",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\nexport function literal<A extends readonly [S.Literal, ...ReadonlyArray<S.Literal>]>(\n  ...values: A\n): JsonSchema<A[number]> {\n  return {\n    compile: () => C.make({ enum: [...values] })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "values",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 20,
        "to": 26
      }
    }
  },
  {
    "name": "nullable",
    "text": "\n\nexport function nullable<A>(or: JsonSchema<A>): JsonSchema<null | A> {\n  return union(nullJsonSchema, or)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "or",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "struct",
    "text": "\n\nexport function struct<A>(properties: { [K in keyof A]: JsonSchema<A[K]> }): JsonSchema<A> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        properties: pipe(\n          properties,\n          R.map<JsonSchema<unknown>, JSONSchema7>((p) => p.compile(lazy))\n        ),\n        required: Object.keys(properties)\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 65,
        "to": 77
      }
    }
  },
  {
    "name": "partial",
    "text": "\n\nexport function partial<A>(properties: { [K in keyof A]: JsonSchema<A[K]> }): JsonSchema<Partial<A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        properties: pipe(\n          properties,\n          R.map<JsonSchema<unknown>, JSONSchema7>((p) => p.compile(lazy))\n        )\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "properties",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<Partial<A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 79,
        "to": 90
      }
    }
  },
  {
    "name": "record",
    "text": "\n\nexport function record<A>(codomain: JsonSchema<A>): JsonSchema<Record<string, A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'object',\n        additionalProperties: codomain.compile(lazy)\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codomain",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<Record<string, A>>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 92,
        "to": 100
      }
    }
  },
  {
    "name": "array",
    "text": "\n\n// tslint:disable-next-line: readonly-array\nexport function array<A>(items: JsonSchema<A>): JsonSchema<Array<A>> {\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'array',\n        items: items.compile(lazy)\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "items",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 103,
        "to": 111
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\nexport function tuple<A extends ReadonlyArray<unknown>>(\n  ...components: { [K in keyof A]: JsonSchema<A[K]> }\n): JsonSchema<A> {\n  const len = components.length\n  return {\n    compile: (lazy) =>\n      C.make({\n        type: 'array',\n        items: len > 0 ? components.map((c) => c.compile(lazy)) : undefined,\n        minItems: len,\n        maxItems: len\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "components",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 113,
        "to": 126
      }
    }
  },
  {
    "name": "sum",
    "text": "\n\nexport function sum<T extends string>(\n  _tag: T\n): <A>(members: { [K in keyof A]: JsonSchema<A[K] & Record<T, K>> }) => JsonSchema<A[keyof A]> {\n  return (members: Record<string, JsonSchema<unknown>>) => {\n    return {\n      compile: (lazy) => C.make({ anyOf: Object.keys(members).map((k) => members[k].compile(lazy)) })\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "_tag",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(members: { [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[K] & Record<T, K>>; }) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[keyof A]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 132,
        "to": 140
      }
    }
  },
  {
    "name": "lazy",
    "text": "\n\nexport function lazy<A>(id: string, f: () => JsonSchema<A>): JsonSchema<A> {\n  const $ref = `#/definitions/${id}`\n  return {\n    compile: (definitions) => {\n      if (definitions !== undefined) {\n        if (definitions.hasOwnProperty(id)) {\n          return C.make({ $ref })\n        }\n        definitions[id] = undefined\n        return (definitions[id] = f().compile(definitions))\n      } else {\n        definitions = { [id]: undefined }\n        definitions[id] = f().compile(definitions)\n        return C.make({\n          definitions,\n          $ref\n        })\n      }\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "id",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 142,
        "to": 162
      }
    }
  },
  {
    "name": "union",
    "text": "\n\nexport function union<A extends readonly [unknown, ...ReadonlyArray<unknown>]>(\n  ...members: { [K in keyof A]: JsonSchema<A[K]> }\n): JsonSchema<A[number]> {\n  return {\n    compile: (lazy) => C.make({ anyOf: members.map((m) => m.compile(lazy)) })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "members",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A[number]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 166,
        "to": 172
      }
    }
  },
  {
    "name": "intersect",
    "text": "const intersect = <B>(right: JsonSchema<B>) => <A>(left: JsonSchema<A>): JsonSchema<A & B> => ({\n  compile: (lazy) => C.make({ allOf: [left.compile(lazy), right.compile(lazy)] })\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(left: import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A>) => import(\"/home/bb8/dev/tsearch/projects/io-ts/test/JsonSchema\").JsonSchema<A & B>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/JsonSchema.ts",
      "lines": {
        "from": 128,
        "to": 130
      }
    }
  },
  {
    "name": "interfaceWithOptionals",
    "text": " // OK!\n\n// ----------------\n\nexport function interfaceWithOptionals<RequiredProps extends t.Props, OptionalProps extends t.Props>(\n  required: RequiredProps,\n  optional: OptionalProps,\n  name?: string\n): t.IntersectionC<[t.TypeC<RequiredProps>, t.PartialC<OptionalProps>]> {\n  return t.intersection([t.type(required), t.partial(optional)], name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "required",
          "type": {
            "__tag": "Other",
            "values": "RequiredProps"
          }
        },
        {
          "name": "optional",
          "type": {
            "__tag": "Other",
            "values": "OptionalProps"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").IntersectionC<[import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeC<RequiredProps>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").PartialC<OptionalProps>]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 515,
        "to": 521
      }
    }
  },
  {
    "name": "maybe",
    "text": "\n\n// ----------------\n\nexport function maybe<RT extends t.Any>(\n  type: RT,\n  name?: string\n): t.UnionType<[RT, t.NullType], t.TypeOf<RT> | null, t.OutputOf<RT> | null, t.InputOf<RT> | null> {\n  return t.union<[RT, t.NullType]>([type, t.null], name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "type",
          "type": {
            "__tag": "Other",
            "values": "RT"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").UnionType<[RT, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").NullType], RT[\"_A\"], RT[\"_O\"], RT[\"_I\"]>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "dtslint/ts3.5/index.ts",
      "lines": {
        "from": 525,
        "to": 530
      }
    }
  },
  {
    "name": "assertStrictEqual",
    "text": "\n\nexport function assertStrictEqual<T>(result: t.Validation<T>, expected: any): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        assert.deepStrictEqual(a, expected)\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Any"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 7,
        "to": 20
      }
    }
  },
  {
    "name": "assertSuccess",
    "text": "\n\nexport function assertSuccess<T>(result: t.Validation<T>, expected?: T): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        if (expected !== undefined) {\n          assert.deepStrictEqual(a, expected)\n        }\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 22,
        "to": 37
      }
    }
  },
  {
    "name": "assertStrictSuccess",
    "text": "\n\nexport function assertStrictSuccess<T>(result: t.Validation<T>, expected: T): void {\n  pipe(\n    result,\n    fold(\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a right`)\n      },\n      (a) => {\n        /* istanbul ignore next */\n        if (expected !== undefined) {\n          assert.strictEqual(a, expected)\n        }\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "result",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 39,
        "to": 55
      }
    }
  },
  {
    "name": "assertFailure",
    "text": "\n\nexport function assertFailure(codec: t.Any, value: unknown, errors: Array<string>): void {\n  const result = codec.decode(value)\n  pipe(\n    result,\n    fold(\n      () => {\n        assert.deepStrictEqual(PathReporter.report(result), errors)\n      },\n      /* istanbul ignore next */\n      () => {\n        throw new Error(`${result} is not a left`)\n      }\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "codec",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Any"
          }
        },
        {
          "name": "value",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "errors",
          "type": {
            "__tag": "Other",
            "values": "string[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 57,
        "to": 71
      }
    }
  },
  {
    "name": "withDefault",
    "text": "\n\nexport function withDefault<T extends t.Mixed>(\n  type: T,\n  defaultValue: t.TypeOf<T>\n): t.Type<t.TypeOf<T>, t.TypeOf<T>, unknown> {\n  return new t.Type(\n    `withDefault(${type.name}, ${JSON.stringify(defaultValue)})`,\n    type.is,\n    (v) => type.decode(v != null ? v : defaultValue),\n    type.encode\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "type",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        },
        {
          "name": "defaultValue",
          "type": {
            "__tag": "Other",
            "values": "T[\"_A\"]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<T[\"_A\"], T[\"_A\"], unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/helpers.ts",
      "lines": {
        "from": 101,
        "to": 111
      }
    }
  },
  {
    "name": "strictInterfaceWithOptionals",
    "text": "\n\nexport function strictInterfaceWithOptionals<R extends t.Props, O extends t.Props>(\n  required: R,\n  optional: O,\n  name?: string\n): t.Type<t.TypeOfProps<R> & t.TypeOfPartialProps<O>, t.OutputOfProps<R> & t.OutputOfPartialProps<O>> {\n  return t.exact(t.intersection([t.type(required), t.partial(optional)]), name)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "required",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        },
        {
          "name": "optional",
          "type": {
            "__tag": "Other",
            "values": "O"
          }
        },
        {
          "name": "name",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").Type<import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeOfProps<R> & import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").TypeOfPartialProps<O>, import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").OutputOfProps<R> & import(\"/home/bb8/dev/tsearch/projects/io-ts/src/index\").OutputOfPartialProps<O>, unknown>"
      }
    },
    "module": "io-ts",
    "location": {
      "path": "test/2.1.x/strictInterfaceWithOptionals.ts",
      "lines": {
        "from": 5,
        "to": 11
      }
    }
  },
  {
    "name": "copyPackageJson",
    "text": "const copyPackageJson: Build<void> = (C) =>\n  pipe(\n    C.readFile(PKG),\n    TE.chain((s) => TE.fromEither(pipe(J.parse(s), E.mapLeft(E.toError)))),\n    TE.map((json) => {\n      const clone = Object.assign({}, json as any)\n\n      delete clone.scripts\n      delete clone.files\n      delete clone.devDependencies\n\n      return clone\n    }),\n    TE.chain((json) => C.writeFile(path.join(OUTPUT_FOLDER, PKG), JSON.stringify(json, null, 2)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/scripts/FileSystem\").FileSystem"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<Error, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 15,
        "to": 29
      }
    }
  },
  {
    "name": "copyFiles",
    "text": "const copyFiles: Build<ReadonlyArray<void>> = (C) =>\n  pipe(\n    FILES,\n    TE.traverseArrayWithIndex((_, from) => C.copyFile(from, path.resolve(OUTPUT_FOLDER, from)))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/scripts/FileSystem\").FileSystem"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<Error, readonly void[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 33,
        "to": 37
      }
    }
  },
  {
    "name": "makeModules",
    "text": "const makeModules: Build<void> = (C) => {\n  const makeSingleModuleC = makeSingleModule(C)\n  return pipe(\n    C.glob(`${OUTPUT_FOLDER}/lib/*.js`),\n    TE.map(getModules),\n    TE.chain(TE.traverseArrayWithIndex((_, a) => makeSingleModuleC(a))),\n    TE.map(() => undefined)\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/scripts/FileSystem\").FileSystem"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<Error, any>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "scripts/build.ts",
      "lines": {
        "from": 39,
        "to": 47
      }
    }
  },
  {
    "name": "run",
    "text": "\n\nexport function run<A>(eff: TaskEither<Error, A>): void {\n  eff()\n    .then(\n      fold(\n        (e) => {\n          throw e\n        },\n        (_) => {\n          process.exitCode = 0\n        }\n      )\n    )\n    .catch((e) => {\n      console.error(e) // tslint:disable-line no-console\n\n      process.exitCode = 1\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eff",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<Error, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "scripts/run.ts",
      "lines": {
        "from": 4,
        "to": 21
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Lift a monoid into 'F', the inner values are concatenated using the provided `Monoid`.\n *\n * @since 2.10.0\n */\nexport function getApplicativeMonoid<F extends URIS4>(\n  F: Applicative4<F>\n): <A, S, R, E>(M: Monoid<A>) => Monoid<Kind4<F, S, R, E, A>>",
    "docs": "/**\n * Lift a monoid into 'F', the inner values are concatenated using the provided `Monoid`.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F extends URIS3>(\n  F: Applicative3<F>\n): <A, R, E>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <A, R>(M: Monoid<A>) => Monoid<Kind3<F, R, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F extends URIS2>(\n  F: Applicative2<F>\n): <A, E>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 104,
        "to": 106
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A>(M: Monoid<A>) => Monoid<Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F extends URIS>(F: Applicative1<F>): <A>(M: Monoid<A>) => Monoid<Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 110,
        "to": 110
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F>(F: Applicative<F>): <A>(M: Monoid<A>) => Monoid<HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 111,
        "to": 111
      }
    }
  },
  {
    "name": "getApplicativeMonoid",
    "text": "\nexport function getApplicativeMonoid<F>(F: Applicative<F>): <A>(M: Monoid<A>) => Monoid<HKT<F, A>> {\n  const f = getApplySemigroup(F)\n  return <A>(M: Monoid<A>) => ({\n    concat: f(M).concat,\n    empty: F.of(M.empty)\n  })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 112,
        "to": 118
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n\n/**\n * Use [`ap`](./Apply.ts.html#ap) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>",
    "docs": "/**\n * Use [`ap`](./Apply.ts.html#ap) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 243,
        "to": 246
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2>(\n  F: Applicative2<F>,\n  G: Applicative2<G>\n): ApplicativeComposition22<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 248,
        "to": 251
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS2, G extends URIS2, E>(\n  F: Applicative2<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition22C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 253,
        "to": 256
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS2, G extends URIS>(\n  F: Applicative2<F>,\n  G: Applicative1<G>\n): ApplicativeComposition21<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 258,
        "to": 261
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS, G extends URIS2>(\n  F: Applicative1<F>,\n  G: Applicative2<G>\n): ApplicativeComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 263,
        "to": 266
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS, G extends URIS2, E>(\n  F: Applicative1<F>,\n  G: Applicative2C<G, E>\n): ApplicativeComposition12C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 268,
        "to": 271
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F extends URIS, G extends URIS>(\n  F: Applicative1<F>,\n  G: Applicative1<G>\n): ApplicativeComposition11<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 273,
        "to": 276
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F, G extends URIS2>(\n  F: Applicative<F>,\n  G: Applicative2<G>\n): ApplicativeCompositionHKT2<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT2<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 278,
        "to": 281
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F, G extends URIS2, E>(\n  F: Applicative<F>,\n  G: Applicative2C<G, E>\n): ApplicativeCompositionHKT2C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT2C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 283,
        "to": 286
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F, G extends URIS>(\n  F: Applicative<F>,\n  G: Applicative1<G>\n): ApplicativeCompositionHKT1<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeCompositionHKT1<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 288,
        "to": 291
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F, G>(F: Applicative<F>, G: Applicative<G>): ApplicativeComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 293,
        "to": 293
      }
    }
  },
  {
    "name": "getApplicativeComposition",
    "text": "\n/** @deprecated */\nexport function getApplicativeComposition<F, G>(F: Applicative<F>, G: Applicative<G>): ApplicativeComposition<F, G> {\n  const map = getFunctorComposition(F, G).map\n  const _ap = ap(F, G)\n  return {\n    map,\n    of: (a) => F.of(G.of(a)),\n    ap: (fgab, fga) => pipe(fgab, _ap(fga))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").ApplicativeComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Applicative.ts",
      "lines": {
        "from": 295,
        "to": 303
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `ap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function ap<F extends URIS2, G extends URIS2, E>(\n  F: Apply2<F>,\n  G: Apply2C<G, E>\n): <FE, A>(\n  fa: Kind2<F, FE, Kind2<G, E, A>>\n) => <B>(fab: Kind2<F, FE, Kind2<G, E, (a: A) => B>>) => Kind2<F, FE, Kind2<G, E, B>>",
    "docs": "/**\n * `ap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 113,
        "to": 118
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS, G extends URIS2, E>(\n  F: Apply1<F>,\n  G: Apply2C<G, E>\n): <A>(fa: Kind<F, Kind2<G, E, A>>) => <B>(fab: Kind<F, Kind2<G, E, (a: A) => B>>) => Kind<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 119,
        "to": 122
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, G extends URIS2>(\n  F: Apply<F>,\n  G: Apply2<G>\n): <E, A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 123,
        "to": 126
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, G extends URIS2, E>(\n  F: Apply<F>,\n  G: Apply2C<G, E>\n): <A>(fa: HKT<F, Kind2<G, E, A>>) => <B>(fab: HKT<F, Kind2<G, E, (a: A) => B>>) => HKT<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 127,
        "to": 130
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, G extends URIS>(\n  F: Apply<F>,\n  G: Apply1<G>\n): <A>(fa: HKT<F, Kind<G, A>>) => <B>(fab: HKT<F, Kind<G, (a: A) => B>>) => HKT<F, Kind<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 131,
        "to": 134
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, G>(\n  F: Apply<F>,\n  G: Apply<G>\n): <A>(fa: HKT<F, HKT<G, A>>) => <B>(fab: HKT<F, HKT<G, (a: A) => B>>) => HKT<F, HKT<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, G>(\n  F: Apply<F>,\n  G: Apply<G>\n): <A>(fa: HKT<F, HKT<G, A>>) => <B>(fab: HKT<F, HKT<G, (a: A) => B>>) => HKT<F, HKT<G, B>> {\n  return <A>(fa: HKT<F, HKT<G, A>>) => <B>(fab: HKT<F, HKT<G, (a: A) => B>>): HKT<F, HKT<G, B>> =>\n    F.ap(\n      F.map(fab, (gab) => (ga: HKT<G, A>) => G.ap(gab, ga)),\n      fa\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 139,
        "to": 148
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function apFirst<F extends URIS4>(\n  A: Apply4<F>\n): <S, R, E, B>(second: Kind4<F, S, R, E, B>) => <A>(first: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, A>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 154,
        "to": 156
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F extends URIS3>(\n  A: Apply3<F>\n): <R, E, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 157,
        "to": 159
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F extends URIS3, E>(\n  A: Apply3C<F, E>\n): <R, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 160,
        "to": 162
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F extends URIS2>(\n  A: Apply2<F>\n): <E, B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 163,
        "to": 165
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F extends URIS2, E>(\n  A: Apply2C<F, E>\n): <B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 166,
        "to": 168
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F extends URIS>(A: Apply1<F>): <B>(second: Kind<F, B>) => <A>(first: Kind<F, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 169,
        "to": 169
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 170,
        "to": 170
      }
    }
  },
  {
    "name": "apFirst",
    "text": "\nexport function apFirst<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, A> {\n  return (second) => (first) =>\n    A.ap(\n      A.map(first, (a) => () => a),\n      second\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 171,
        "to": 177
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function apSecond<F extends URIS4>(\n  A: Apply4<F>\n): <S, R, E, B>(second: Kind4<F, S, R, E, B>) => <A>(first: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 183,
        "to": 185
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F extends URIS3>(\n  A: Apply3<F>\n): <R, E, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 186,
        "to": 188
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F extends URIS3, E>(\n  A: Apply3C<F, E>\n): <R, B>(second: Kind3<F, R, E, B>) => <A>(first: Kind3<F, R, E, A>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 189,
        "to": 191
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F extends URIS2>(\n  A: Apply2<F>\n): <E, B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 192,
        "to": 194
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F extends URIS2, E>(\n  A: Apply2C<F, E>\n): <B>(second: Kind2<F, E, B>) => <A>(first: Kind2<F, E, A>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 195,
        "to": 197
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F extends URIS>(A: Apply1<F>): <B>(second: Kind<F, B>) => <A>(first: Kind<F, A>) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 198,
        "to": 198
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 199,
        "to": 199
      }
    }
  },
  {
    "name": "apSecond",
    "text": "\nexport function apSecond<F>(A: Apply<F>): <B>(second: HKT<F, B>) => <A>(first: HKT<F, A>) => HKT<F, B> {\n  return <B>(second: HKT<F, B>) => (first) =>\n    A.ap(\n      A.map(first, () => (b: B) => b),\n      second\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <A>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 200,
        "to": 206
      }
    }
  },
  {
    "name": "apS",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function apS<F extends URIS4>(\n  F: Apply4<F>\n): <N extends string, A, S, R, E, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind4<F, S, R, E, B>\n) => (fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 212,
        "to": 217
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F extends URIS3>(\n  F: Apply3<F>\n): <N extends string, A, R, E, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind3<F, R, E, B>\n) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, R, E, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 218,
        "to": 223
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <N extends string, A, R, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind3<F, R, E, B>\n) => (fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, R, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 224,
        "to": 229
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F extends URIS2>(\n  F: Apply2<F>\n): <N extends string, A, E, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind2<F, E, B>\n) => (fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, E, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 230,
        "to": 235
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind2<F, E, B>\n) => (fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 236,
        "to": 241
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F extends URIS>(\n  F: Apply1<F>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  fb: Kind<F, B>\n) => (fa: Kind<F, A>) => Kind<F, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 242,
        "to": 247
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F>(\n  F: Apply<F>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  fb: HKT<F, B>\n) => (fa: HKT<F, A>) => HKT<F, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 248,
        "to": 253
      }
    }
  },
  {
    "name": "apS",
    "text": "\nexport function apS<F>(\n  F: Apply<F>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  fb: HKT<F, B>\n) => (fa: HKT<F, A>) => HKT<F, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }> {\n  return <B>(name: string, fb: HKT<F, B>) => (fa) =>\n    F.ap(\n      F.map(fa, (a) => (b: B) => Object.assign({}, a, { [name]: b }) as any),\n      fb\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, fb: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 254,
        "to": 265
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Lift a semigroup into 'F', the inner values are concatenated using the provided `Semigroup`.\n *\n * @since 2.10.0\n */\nexport function getApplySemigroup<F extends URIS4>(\n  F: Apply4<F>\n): <A, S, R, E>(S: Semigroup<A>) => Semigroup<Kind4<F, S, R, E, A>>",
    "docs": "/**\n * Lift a semigroup into 'F', the inner values are concatenated using the provided `Semigroup`.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 276,
        "to": 278
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F extends URIS3>(\n  F: Apply3<F>\n): <A, R, E>(S: Semigroup<A>) => Semigroup<Kind3<F, R, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 279,
        "to": 281
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <A, R>(S: Semigroup<A>) => Semigroup<Kind3<F, R, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 282,
        "to": 284
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F extends URIS2>(F: Apply2<F>): <A, E>(S: Semigroup<A>) => Semigroup<Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 285,
        "to": 285
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <A>(S: Semigroup<A>) => Semigroup<Kind2<F, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 286,
        "to": 288
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F extends URIS>(F: Apply1<F>): <A>(S: Semigroup<A>) => Semigroup<Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 289,
        "to": 289
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F>(F: Apply<F>): <A>(S: Semigroup<A>) => Semigroup<HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 290,
        "to": 290
      }
    }
  },
  {
    "name": "getApplySemigroup",
    "text": "\nexport function getApplySemigroup<F>(F: Apply<F>): <A>(S: Semigroup<A>) => Semigroup<HKT<F, A>> {\n  return <A>(S: Semigroup<A>) => ({\n    concat: (first: HKT<F, A>, second: HKT<F, A>) =>\n      F.ap(\n        F.map(first, (x: A) => (y: A) => S.concat(x, y)),\n        second\n      )\n  })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 291,
        "to": 299
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\n\n/**\n * Tuple sequencing, i.e., take a tuple of monadic actions and does them from left-to-right, returning the resulting tuple.\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as O from 'fp-ts/Option'\n *\n * const sequenceTOption = sequenceT(O.Apply)\n * assert.deepStrictEqual(sequenceTOption(O.some(1)), O.some([1]))\n * assert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2')), O.some([1, '2']))\n * assert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2'), O.none), O.none)\n *\n * @since 2.0.0\n */\nexport function sequenceT<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, T extends Array<Kind4<F, S, R, E, any>>>(\n  ...t: T & { readonly 0: Kind4<F, S, R, E, any> }\n) => Kind4<F, S, R, E, { [K in keyof T]: [T[K]] extends [Kind4<F, S, R, E, infer A>] ? A : never }>",
    "docs": "/**\n * Tuple sequencing, i.e., take a tuple of monadic actions and does them from left-to-right, returning the resulting tuple.\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as O from 'fp-ts/Option'\n *\n * const sequenceTOption = sequenceT(O.Apply)\n * assert.deepStrictEqual(sequenceTOption(O.some(1)), O.some([1]))\n * assert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2')), O.some([1, '2']))\n * assert.deepStrictEqual(sequenceTOption(O.some(1), O.some('2'), O.none), O.none)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 341,
        "to": 345
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS3>(\n  F: Apply3<F>\n): <R, E, T extends Array<Kind3<F, R, E, any>>>(\n  ...t: T & { readonly 0: Kind3<F, R, E, any> }\n) => Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 346,
        "to": 350
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <R, T extends Array<Kind3<F, R, E, any>>>(\n  ...t: T & { readonly 0: Kind3<F, R, E, any> }\n) => Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [Kind3<F, R, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 351,
        "to": 355
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS2>(\n  F: Apply2<F>\n): <E, T extends Array<Kind2<F, E, any>>>(\n  ...t: T & { readonly 0: Kind2<F, E, any> }\n) => Kind2<F, E, { [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 356,
        "to": 360
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <T extends Array<Kind2<F, E, any>>>(\n  ...t: T & { readonly 0: Kind2<F, E, any> }\n) => Kind2<F, E, { [K in keyof T]: [T[K]] extends [Kind2<F, E, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 361,
        "to": 365
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F extends URIS>(\n  F: Apply1<F>\n): <T extends Array<Kind<F, any>>>(\n  ...t: T & { readonly 0: Kind<F, any> }\n) => Kind<F, { [K in keyof T]: [T[K]] extends [Kind<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 366,
        "to": 370
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F>(\n  F: Apply<F>\n): <T extends Array<HKT<F, any>>>(\n  ...t: T & { readonly 0: HKT<F, any> }\n) => HKT<F, { [K in keyof T]: [T[K]] extends [HKT<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<T extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>[]>(...t: T & { readonly 0: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>; }) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { [K in keyof T]: [T[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 371,
        "to": 375
      }
    }
  },
  {
    "name": "sequenceT",
    "text": "\nexport function sequenceT<F>(F: Apply<F>): any {\n  return <A>(...args: Array<HKT<F, A>>) => {\n    const len = args.length\n    const f = getTupleConstructor(len)\n    let fas = F.map(args[0], f)\n    for (let i = 1; i < len; i++) {\n      fas = F.ap(fas, args[i])\n    }\n    return fas\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Any"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 376,
        "to": 386
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\n\n/**\n * Like `Apply.sequenceT` but works with structs instead of tuples.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { sequenceS } from 'fp-ts/Apply'\n *\n * const ado = sequenceS(E.Apply)\n *\n * assert.deepStrictEqual(\n *   ado({\n *     a: E.right(1),\n *     b: E.right(true)\n *   }),\n *   E.right({ a: 1, b: true })\n * )\n * assert.deepStrictEqual(\n *   ado({\n *     a: E.right(1),\n *     b: E.left('error')\n *   }),\n *   E.left('error')\n * )\n *\n * @since 2.0.0\n */\nexport function sequenceS<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, NER extends Record<string, Kind4<F, S, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind4<F, S, R, E, any>>\n) => Kind4<F, S, R, E, { [K in keyof NER]: [NER[K]] extends [Kind4<F, any, any, any, infer A>] ? A : never }>",
    "docs": "/**\n * Like `Apply.sequenceT` but works with structs instead of tuples.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { sequenceS } from 'fp-ts/Apply'\n *\n * const ado = sequenceS(E.Apply)\n *\n * assert.deepStrictEqual(\n *   ado({\n *     a: E.right(1),\n *     b: E.right(true)\n *   }),\n *   E.right({ a: 1, b: true })\n * )\n * assert.deepStrictEqual(\n *   ado({\n *     a: E.right(1),\n *     b: E.left('error')\n *   }),\n *   E.left('error')\n * )\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, any, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 455,
        "to": 459
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS3>(\n  F: Apply3<F>\n): <R, E, NER extends Record<string, Kind3<F, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>\n) => Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 460,
        "to": 464
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <R, NER extends Record<string, Kind3<F, R, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind3<F, R, E, any>>\n) => Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [Kind3<F, any, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, any, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 465,
        "to": 469
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS2>(\n  F: Apply2<F>\n): <E, NER extends Record<string, Kind2<F, E, any>>>(\n  r: EnforceNonEmptyRecord<NER> & Record<string, Kind2<F, E, any>>\n) => Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER> & Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 470,
        "to": 474
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <NER extends Record<string, Kind2<F, E, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [Kind2<F, any, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, any, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 475,
        "to": 479
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F extends URIS>(\n  F: Apply1<F>\n): <NER extends Record<string, Kind<F, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => Kind<F, { [K in keyof NER]: [NER[K]] extends [Kind<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 480,
        "to": 484
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F>(\n  F: Apply<F>\n): <NER extends Record<string, HKT<F, any>>>(\n  r: EnforceNonEmptyRecord<NER>\n) => HKT<F, { [K in keyof NER]: [NER[K]] extends [HKT<F, infer A>] ? A : never }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<NER extends Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>>>(r: EnforceNonEmptyRecord<NER>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { [K in keyof NER]: [NER[K]] extends [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, infer A>] ? A : never; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 485,
        "to": 489
      }
    }
  },
  {
    "name": "sequenceS",
    "text": "\nexport function sequenceS<F>(F: Apply<F>): (r: Record<string, HKT<F, any>>) => HKT<F, Record<string, any>> {\n  return (r) => {\n    const keys = Object.keys(r)\n    const len = keys.length\n    const f = getRecordConstructor(keys)\n    let fr = F.map(r[keys[0]], f)\n    for (let i = 1; i < len; i++) {\n      fr = F.ap(fr, r[keys[i]])\n    }\n    return fr\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, any>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, any>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Apply.ts",
      "lines": {
        "from": 490,
        "to": 501
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Array<B>",
    "docs": "/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 379,
        "to": 379
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 380,
        "to": 380
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: Array<A>) => Array<A> {\n  return (as) => {\n    const out: Array<A> = []\n    for (const a of as) {\n      if (!predicate(a)) {\n        break\n      }\n      out.push(a)\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 381,
        "to": 392
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\n\n/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Spanned<B, A>",
    "docs": "/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Array\").Spanned<B, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 428,
        "to": 428
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: Array<A>) => Spanned<A, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Array\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 429,
        "to": 429
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: Array<A>) => Spanned<A, A> {\n  return (as) => {\n    const [init, rest] = splitAt(spanLeftIndex(as, predicate))(as)\n    return { init, rest }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Array\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 430,
        "to": 435
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\n\n/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findFirst((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option<B>",
    "docs": "/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findFirst((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 514,
        "to": 514
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 515,
        "to": 515
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A> {\n  return RA.findFirst(predicate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 516,
        "to": 518
      }
    }
  },
  {
    "name": "findLast",
    "text": "\n\n/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findLast((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: Array<A>) => Option<B>",
    "docs": "/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findLast((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 559,
        "to": 559
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 560,
        "to": 560
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: Array<A>) => Option<A> {\n  return RA.findLast(predicate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 561,
        "to": 563
      }
    }
  },
  {
    "name": "zip",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], zip(['a', 'b', 'c', 'd'])), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function zip<B>(bs: Array<B>): <A>(as: Array<A>) => Array<[A, B]>",
    "docs": "/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], zip(['a', 'b', 'c', 'd'])), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => [A, B][]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 782,
        "to": 782
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(as: Array<A>, bs: Array<B>): Array<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A, B][]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 783,
        "to": 783
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(as: Array<A>, bs?: Array<B>): Array<[A, B]> | ((bs: Array<B>) => Array<[B, A]>) {\n  if (bs === undefined) {\n    return (bs) => zip(bs, as)\n  }\n  return zipWith(as, bs, (a, b) => [a, b])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A, B][] | ((bs: B[]) => [B, A][])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 784,
        "to": 789
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\n\n/**\n * `Array` comprehension.\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/Array'\n * import { tuple } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function comprehension<A, B, C, D, R>(\n  input: [Array<A>, Array<B>, Array<C>, Array<D>],\n  f: (a: A, b: B, c: C, d: D) => R,\n  g?: (a: A, b: B, c: C, d: D) => boolean\n): Array<R>",
    "docs": "/**\n * `Array` comprehension.\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/Array'\n * import { tuple } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[], C[], D[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1021,
        "to": 1025
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, C, R>(\n  input: [Array<A>, Array<B>, Array<C>],\n  f: (a: A, b: B, c: C) => R,\n  g?: (a: A, b: B, c: C) => boolean\n): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[], C[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1026,
        "to": 1030
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, R>(\n  input: [Array<A>, Array<B>],\n  f: (a: A, b: B) => R,\n  g?: (a: A, b: B) => boolean\n): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[], B[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1031,
        "to": 1035
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(input: [Array<A>], f: (a: A) => R, g?: (a: A) => boolean): Array<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "[A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1036,
        "to": 1036
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(\n  input: Array<Array<A>>,\n  f: (...xs: Array<A>) => R,\n  g: (...xs: Array<A>) => boolean = () => true\n): Array<R> {\n  const go = (scope: Array<A>, input: Array<Array<A>>): Array<R> =>\n    isNonEmpty(input)\n      ? pipe(\n          NEA.head(input),\n          chain((x) => go(pipe(scope, append(x)), NEA.tail(input)))\n        )\n      : g(...scope)\n      ? [f(...scope)]\n      : []\n  return go([], input)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "A[][]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...xs: A[]) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(...xs: A[]) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1037,
        "to": 1052
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], union(N.Eq)([2, 3])), [1, 2, 3])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function union<A>(\n  E: Eq<A>\n): {\n  (xs: Array<A>): (ys: Array<A>) => Array<A>\n  (xs: Array<A>, ys: Array<A>): Array<A>\n}",
    "docs": "/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], union(N.Eq)([2, 3])), [1, 2, 3])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: A[]): (ys: A[]) => A[]; (xs: A[], ys: A[]): A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1068,
        "to": 1073
      }
    }
  },
  {
    "name": "union",
    "text": "\nexport function union<A>(E: Eq<A>): (xs: Array<A>, ys?: Array<A>) => Array<A> | ((ys: Array<A>) => Array<A>) {\n  const unionE = NEA.union(E)\n  return (first, second?) => {\n    if (second === undefined) {\n      const unionE = union(E)\n      return (ys) => unionE(ys, first)\n    }\n    return isNonEmpty(first) && isNonEmpty(second)\n      ? unionE(first, second)\n      : isNonEmpty(first)\n      ? copy(first)\n      : copy(second)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: A[], ys?: A[]) => A[] | ((ys: A[]) => A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1074,
        "to": 1087
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], intersection(N.Eq)([2, 3])), [2])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function intersection<A>(\n  E: Eq<A>\n): {\n  (xs: Array<A>): (ys: Array<A>) => Array<A>\n  (xs: Array<A>, ys: Array<A>): Array<A>\n}",
    "docs": "/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], intersection(N.Eq)([2, 3])), [2])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: A[]): (ys: A[]) => A[]; (xs: A[], ys: A[]): A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1104,
        "to": 1109
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A>(E: Eq<A>): (xs: Array<A>, ys?: Array<A>) => Array<A> | ((ys: Array<A>) => Array<A>) {\n  const elemE = elem(E)\n  return (xs, ys?) => {\n    if (ys === undefined) {\n      const intersectionE = intersection(E)\n      return (ys) => intersectionE(ys, xs)\n    }\n    return xs.filter((a) => elemE(a, ys))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: A[], ys?: A[]) => A[] | ((ys: A[]) => A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1110,
        "to": 1119
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], difference(N.Eq)([2, 3])), [1])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function difference<A>(\n  E: Eq<A>\n): {\n  (xs: Array<A>): (ys: Array<A>) => Array<A>\n  (xs: Array<A>, ys: Array<A>): Array<A>\n}",
    "docs": "/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], difference(N.Eq)([2, 3])), [1])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: A[]): (ys: A[]) => A[]; (xs: A[], ys: A[]): A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1136,
        "to": 1141
      }
    }
  },
  {
    "name": "difference",
    "text": "\nexport function difference<A>(E: Eq<A>): (xs: Array<A>, ys?: Array<A>) => Array<A> | ((ys: Array<A>) => Array<A>) {\n  const elemE = elem(E)\n  return (xs, ys?) => {\n    if (ys === undefined) {\n      const differenceE = difference(E)\n      return (ys) => differenceE(ys, xs)\n    }\n    return xs.filter((a) => !elemE(a, ys))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: A[], ys?: A[]) => A[] | ((ys: A[]) => A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1142,
        "to": 1151
      }
    }
  },
  {
    "name": "makeBy",
    "text": "const makeBy = <A>(n: number, f: (i: number) => A): Array<A> => (n <= 0 ? [] : NEA.makeBy(n, f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 85,
        "to": 85
      }
    }
  },
  {
    "name": "range",
    "text": "const range = (start: number, end: number): Array<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : [start]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "start",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "number[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 98,
        "to": 99
      }
    }
  },
  {
    "name": "replicate",
    "text": "const replicate = <A>(n: number, a: A): Array<A> => makeBy(n, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 114,
        "to": 114
      }
    }
  },
  {
    "name": "matchLeft",
    "text": "const matchLeft = <B, A>(onEmpty: Lazy<B>, onNonEmpty: (head: A, tail: Array<A>) => B) => (as: Array<A>): B =>\n  isNonEmpty(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onEmpty",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        },
        {
          "name": "onNonEmpty",
          "type": {
            "__tag": "Other",
            "values": "(head: A, tail: A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 132,
        "to": 133
      }
    }
  },
  {
    "name": "matchRight",
    "text": "const matchRight = <B, A>(onEmpty: Lazy<B>, onNonEmpty: (init: Array<A>, last: A) => B) => (as: Array<A>): B =>\n  isNonEmpty(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onEmpty",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        },
        {
          "name": "onNonEmpty",
          "type": {
            "__tag": "Other",
            "values": "(init: A[], last: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 152,
        "to": 153
      }
    }
  },
  {
    "name": "chainWithIndex",
    "text": "const chainWithIndex = <A, B>(f: (i: number, a: A) => Array<B>) => (as: Array<A>): Array<B> => {\n  const out: Array<B> = []\n  for (let i = 0; i < as.length; i++) {\n    out.push(...f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 174,
        "to": 180
      }
    }
  },
  {
    "name": "scanLeft",
    "text": "const scanLeft = <A, B>(b: B, f: (b: B, a: A) => B) => (as: Array<A>): NonEmptyArray<B> => {\n  const len = as.length\n  const out = new Array(len + 1) as NonEmptyArray<B>\n  out[0] = b\n  for (let i = 0; i < len; i++) {\n    out[i + 1] = f(out[i], as[i])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 193,
        "to": 201
      }
    }
  },
  {
    "name": "scanRight",
    "text": "const scanRight = <A, B>(b: B, f: (a: A, b: B) => B) => (as: Array<A>): NonEmptyArray<B> => {\n  const len = as.length\n  const out = new Array(len + 1) as NonEmptyArray<B>\n  out[len] = b\n  for (let i = len - 1; i >= 0; i--) {\n    out[i] = f(as[i], out[i + 1])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 214,
        "to": 222
      }
    }
  },
  {
    "name": "size",
    "text": "const size = <A>(as: Array<A>): number => as.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 249,
        "to": 249
      }
    }
  },
  {
    "name": "tail",
    "text": "const tail = <A>(as: Array<A>): Option<Array<A>> => (isNonEmpty(as) ? O.some(NEA.tail(as)) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 320,
        "to": 320
      }
    }
  },
  {
    "name": "init",
    "text": "const init = <A>(as: Array<A>): Option<Array<A>> => (isNonEmpty(as) ? O.some(NEA.init(as)) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 335,
        "to": 335
      }
    }
  },
  {
    "name": "takeLeft",
    "text": "const takeLeft = (n: number) => <A>(as: Array<A>): Array<A> => (isOutOfBound(n, as) ? copy(as) : as.slice(0, n))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 350,
        "to": 350
      }
    }
  },
  {
    "name": "takeRight",
    "text": "const takeRight = (n: number) => <A>(as: Array<A>): Array<A> =>\n  isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 365,
        "to": 366
      }
    }
  },
  {
    "name": "dropLeft",
    "text": "const dropLeft = (n: number) => <A>(as: Array<A>): Array<A> =>\n  n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 450,
        "to": 451
      }
    }
  },
  {
    "name": "dropRight",
    "text": "const dropRight = (n: number) => <A>(as: Array<A>): Array<A> =>\n  n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 466,
        "to": 467
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "const dropLeftWhile = <A>(predicate: Predicate<A>) => (as: Array<A>): Array<A> =>\n  as.slice(spanLeftIndex(as, predicate))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 480,
        "to": 481
      }
    }
  },
  {
    "name": "copy",
    "text": "const copy = <A>(as: Array<A>): Array<A> => as.slice()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 611,
        "to": 611
      }
    }
  },
  {
    "name": "insertAt",
    "text": "const insertAt = <A>(i: number, a: A) => (as: Array<A>): Option<NonEmptyArray<A>> =>\n  i < 0 || i > as.length ? O.none : O.some(unsafeInsertAt(i, a, as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 624,
        "to": 625
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(i: number, a: A): ((as: Array<A>) => Option<Array<A>>) => modifyAt(i, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 639,
        "to": 639
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "const deleteAt = (i: number) => <A>(as: Array<A>): Option<Array<A>> =>\n  isOutOfBound(i, as) ? O.none : O.some(unsafeDeleteAt(i, as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 653,
        "to": 654
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(i: number, f: (a: A) => A) => (as: Array<A>): Option<Array<A>> =>\n  isOutOfBound(i, as) ? O.none : O.some(unsafeUpdateAt(i, f(as[i]), as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 670,
        "to": 671
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(as: Array<A>): Array<A> => (isEmpty(as) ? [] : as.slice().reverse())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 684,
        "to": 684
      }
    }
  },
  {
    "name": "rights",
    "text": "const rights = <E, A>(as: Array<Either<E, A>>): Array<A> => {\n  const r: Array<A> = []\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    if (a._tag === 'Right') {\n      r.push(a.right)\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 698,
        "to": 707
      }
    }
  },
  {
    "name": "lefts",
    "text": "const lefts = <E, A>(as: Array<Either<E, A>>): Array<E> => {\n  const r: Array<E> = []\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    if (a._tag === 'Left') {\n      r.push(a.left)\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "E[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 721,
        "to": 730
      }
    }
  },
  {
    "name": "sort",
    "text": "const sort = <B>(O: Ord<B>) => <A extends B>(as: Array<A>): Array<A> =>\n  as.length <= 1 ? copy(as) : as.slice().sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 744,
        "to": 745
      }
    }
  },
  {
    "name": "zipWith",
    "text": "const zipWith = <A, B, C>(fa: Array<A>, fb: Array<B>, f: (a: A, b: B) => C): Array<C> => {\n  const fc: Array<C> = []\n  const len = Math.min(fa.length, fb.length)\n  for (let i = 0; i < len; i++) {\n    fc[i] = f(fa[i], fb[i])\n  }\n  return fc\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 759,
        "to": 766
      }
    }
  },
  {
    "name": "unzip",
    "text": "const unzip = <A, B>(as: Array<[A, B]>): [Array<A>, Array<B>] => {\n  const fa: Array<A> = []\n  const fb: Array<B> = []\n  for (let i = 0; i < as.length; i++) {\n    fa[i] = as[i][0]\n    fb[i] = as[i][1]\n  }\n  return [fa, fb]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "[A, B][]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A[], B[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 801,
        "to": 809
      }
    }
  },
  {
    "name": "prependAll",
    "text": "const prependAll = <A>(middle: A): ((as: Array<A>) => Array<A>) => {\n  const f = NEA.prependAll(middle)\n  return (as) => (isNonEmpty(as) ? f(as) : [])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 822,
        "to": 825
      }
    }
  },
  {
    "name": "intersperse",
    "text": "const intersperse = <A>(middle: A): ((as: Array<A>) => Array<A>) => {\n  const f = NEA.intersperse(middle)\n  return (as) => (isNonEmpty(as) ? f(as) : copy(as))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 838,
        "to": 841
      }
    }
  },
  {
    "name": "rotate",
    "text": "const rotate = (n: number): (<A>(as: Array<A>) => Array<A>) => {\n  const f = NEA.rotate(n)\n  return (as) => (isNonEmpty(as) ? f(as) : copy(as))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 854,
        "to": 857
      }
    }
  },
  {
    "name": "uniq",
    "text": "const uniq = <A>(E: Eq<A>): ((as: Array<A>) => Array<A>) => {\n  const f = NEA.uniq(E)\n  return (as) => (isNonEmpty(as) ? f(as) : copy(as))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 894,
        "to": 897
      }
    }
  },
  {
    "name": "sortBy",
    "text": "const sortBy = <B>(ords: Array<Ord<B>>): (<A extends B>(as: Array<A>) => Array<A>) => {\n  const f = NEA.sortBy(ords)\n  return (as) => (isNonEmpty(as) ? f(as) : copy(as))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 930,
        "to": 933
      }
    }
  },
  {
    "name": "chop",
    "text": "const chop = <A, B>(f: (as: NonEmptyArray<A>) => [B, Array<A>]): ((as: Array<A>) => Array<B>) => {\n  const g = NEA.chop(f)\n  return (as) => (isNonEmpty(as) ? g(as) : [])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => [B, A[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 957,
        "to": 960
      }
    }
  },
  {
    "name": "splitAt",
    "text": "const splitAt = (n: number) => <A>(as: Array<A>): [Array<A>, Array<A>] =>\n  n >= 1 && isNonEmpty(as) ? NEA.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => [A[], A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 973,
        "to": 974
      }
    }
  },
  {
    "name": "chunksOf",
    "text": "const chunksOf = (n: number): (<A>(as: Array<A>) => Array<NonEmptyArray<A>>) => {\n  const f = NEA.chunksOf(n)\n  return (as) => (isNonEmpty(as) ? f(as) : [])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 995,
        "to": 998
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero: Alternative1<URI>['zero'] = () => []",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "any[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1257,
        "to": 1257
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Array<A>) => Array<B> = (f) => (fa) => fa.map((a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1266,
        "to": 1266
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Array<A>) => <B>(fab: Array<(a: A) => B>) => Array<B> = (fa) => chain((f) => pipe(fa, map(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: ((a: A) => B)[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1274,
        "to": 1274
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Array<B>) => (ma: Array<A>) => Array<B> = (f) => (ma) =>\n  pipe(\n    ma,\n    chainWithIndex((_, a) => f(a))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1282,
        "to": 1286
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (fa: Array<A>) => Array<B> = (f) => (fa) =>\n  fa.map((a, i) => f(i, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1302,
        "to": 1303
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "const filterMapWithIndex = <A, B>(f: (i: number, a: A) => Option<B>) => (fa: Array<A>): Array<B> => {\n  const out: Array<B> = []\n  for (let i = 0; i < fa.length; i++) {\n    const optionB = f(i, fa[i])\n    if (O.isSome(optionB)) {\n      out.push(optionB.value)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1309,
        "to": 1318
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: Array<A>) => Array<B> = (f) =>\n  filterMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1324,
        "to": 1325
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <A, B>(fa: Array<Either<A, B>>): Separated<Array<A>, Array<B>> => {\n  const left: Array<A> = []\n  const right: Array<B> = []\n  for (const e of fa) {\n    if (e._tag === 'Left') {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<A[], B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1339,
        "to": 1350
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Array<A>) => Array<B>\n  <A>(predicate: Predicate<A>): (fa: Array<A>) => Array<A>\n} = <A>(predicate: Predicate<A>) => (fa: Array<A>) => fa.filter(predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1356,
        "to": 1359
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Array<A>) => Separated<Array<A>, Array<B>>\n  <A>(predicate: Predicate<A>): (fa: Array<A>) => Separated<Array<A>, Array<A>>\n} = <A>(predicate: Predicate<A>): ((fa: Array<A>) => Separated<Array<A>, Array<A>>) =>\n  partitionWithIndex((_, a) => predicate(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<A[], A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1365,
        "to": 1369
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "const partitionWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (\n    fa: Array<A>\n  ) => Separated<Array<A>, Array<B>>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: Array<A>) => Separated<Array<A>, Array<A>>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (fa: Array<A>): Separated<Array<A>, Array<A>> => {\n  const left: Array<A> = []\n  const right: Array<A> = []\n  for (let i = 0; i < fa.length; i++) {\n    const a = fa[i]\n    if (predicateWithIndex(i, a)) {\n      right.push(a)\n    } else {\n      left.push(a)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<A[], A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1375,
        "to": 1392
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(f: (a: A) => Either<B, C>) => (fa: Array<A>) => Separated<Array<B>, Array<C>> = (\n  f\n) => partitionMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<B[], C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1398,
        "to": 1400
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "const partitionMapWithIndex = <A, B, C>(f: (i: number, a: A) => Either<B, C>) => (\n  fa: Array<A>\n): Separated<Array<B>, Array<C>> => {\n  const left: Array<B> = []\n  const right: Array<C> = []\n  for (let i = 0; i < fa.length; i++) {\n    const e = f(i, fa[i])\n    if (e._tag === 'Left') {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<B[], C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1406,
        "to": 1420
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW = <B>(that: Lazy<Array<B>>) => <A>(fa: Array<A>): Array<A | B> => (fa as Array<A | B>).concat(that())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B[]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: A[]) => (B | A)[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1428,
        "to": 1428
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (fa: Array<A>) => Array<B>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: Array<A>) => Array<A>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (fa: Array<A>): Array<A> =>\n  fa.filter((a, i) => predicateWithIndex(i, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1443,
        "to": 1447
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (fa: Array<A>) => B) => (wa: Array<A>) => Array<B> = (f) => (wa) =>\n  wa.map((_, i) => f(wa.slice(i)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(fa: A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1453,
        "to": 1454
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Array<A>) => HKT<F, Array<B>>) => {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1508,
        "to": 1513
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: ApplicativeHKT<F>) => <A>(\n  ta: Array<HKT<F, A>>\n): HKT<F, Array<A>> => {\n  return _reduce(ta, F.of(zero()), (fas, fa) =>\n    F.ap(\n      F.map(fas, (as) => (a: A) => pipe(as, append(a))),\n      fa\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1519,
        "to": 1528
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "const traverseWithIndex: PipeableTraverseWithIndex1<URI, number> = <F>(F: ApplicativeHKT<F>) => <A, B>(\n  f: (i: number, a: A) => HKT<F, B>\n): ((ta: Array<A>) => HKT<F, Array<B>>) =>\n  reduceWithIndex(F.of(zero()), (i, fbs, a) =>\n    F.ap(\n      F.map(fbs, (bs) => (b: B) => pipe(bs, append(b))),\n      f(i, a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1534,
        "to": 1542
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (fa: Array<A>) => HKT<F, Array<B>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), compact)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1548,
        "to": 1553
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (fa: Array<A>) => HKT<F, Separated<Array<B>, Array<C>>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), separate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (fa: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<B[], C[]>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1559,
        "to": 1564
      }
    }
  },
  {
    "name": "unfold",
    "text": "const unfold = <A, B>(b: B, f: (b: B) => Option<readonly [A, B]>): Array<A> => {\n  const out: Array<A> = []\n  let bb: B = b\n  while (true) {\n    const mt = f(bb)\n    if (O.isSome(mt)) {\n      const [a, b] = mt.value\n      out.push(a)\n      bb = b\n    } else {\n      break\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, B]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1570,
        "to": 1584
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A = never>(): Semigroup<Array<A>> => ({\n  concat: (first, second) => first.concat(second)\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1618,
        "to": 1620
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <A = never>(): Monoid<Array<A>> => ({\n  concat: getSemigroup<A>().concat,\n  empty: []\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1634,
        "to": 1637
      }
    }
  },
  {
    "name": "unsafeUpdateAt",
    "text": "const unsafeUpdateAt = <A>(i: number, a: A, as: Array<A>): Array<A> =>\n  isNonEmpty(as) ? NEA.unsafeUpdateAt(i, a, as) : []",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1977,
        "to": 1978
      }
    }
  },
  {
    "name": "unsafeDeleteAt",
    "text": "const unsafeDeleteAt = <A>(i: number, as: Array<A>): Array<A> => {\n  const xs = as.slice()\n  xs.splice(i, 1)\n  return xs\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 1984,
        "to": 1988
      }
    }
  },
  {
    "name": "some",
    "text": "const some = <A>(predicate: Predicate<A>) => (as: Array<A>): as is NonEmptyArray<A> => as.some(predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => as is import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Array.ts",
      "lines": {
        "from": 2002,
        "to": 2002
      }
    }
  },
  {
    "name": "matchW",
    "text": "const matchW = <A, B>(onFalse: Lazy<A>, onTrue: Lazy<B>) => (value: boolean): A | B =>\n  value ? onTrue() : onFalse()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        },
        {
          "name": "onTrue",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(value: boolean) => A | B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/boolean.ts",
      "lines": {
        "from": 22,
        "to": 23
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(B: BooleanAlgebra<A>): BooleanAlgebra<A> => ({\n  meet: (x, y) => B.join(x, y),\n  join: (x, y) => B.meet(x, y),\n  zero: B.one,\n  one: B.zero,\n  implies: (x, y) => B.join(B.not(x), y),\n  not: B.not\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/BooleanAlgebra.ts",
      "lines": {
        "from": 36,
        "to": 43
      }
    }
  },
  {
    "name": "getMinMaxBoundedDistributiveLattice",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function getMinMaxBoundedDistributiveLattice<A>(O: Ord<A>): (min: A, max: A) => BoundedDistributiveLattice<A> {\n  const L = getMinMaxDistributiveLattice(O)\n  return (min, max) => ({\n    join: L.join,\n    meet: L.meet,\n    zero: min,\n    one: max\n  })\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(min: A, max: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BoundedDistributiveLattice\").BoundedDistributiveLattice<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/BoundedDistributiveLattice.ts",
      "lines": {
        "from": 28,
        "to": 36
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function chainFirst<M extends URIS4>(\n  M: Chain4<M>\n): <A, S, R, E, B>(f: (a: A) => Kind4<M, S, R, E, B>) => (first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 84,
        "to": 86
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M extends URIS3>(\n  M: Chain3<M>\n): <A, R, E, B>(f: (a: A) => Kind3<M, R, E, B>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <A, R, B>(f: (a: A) => Kind3<M, R, E, B>) => (first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 90,
        "to": 92
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M extends URIS2>(\n  M: Chain2<M>\n): <A, E, B>(f: (a: A) => Kind2<M, E, B>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Kind2<M, E, B>) => (first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 96,
        "to": 98
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M extends URIS>(\n  M: Chain1<M>\n): <A, B>(f: (a: A) => Kind<M, B>) => (first: Kind<M, A>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 99,
        "to": 101
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M>(M: Chain<M>): <A, B>(f: (a: A) => HKT<M, B>) => (first: HKT<M, A>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 102,
        "to": 102
      }
    }
  },
  {
    "name": "chainFirst",
    "text": "\nexport function chainFirst<M>(M: Chain<M>): <A, B>(f: (a: A) => HKT<M, B>) => (first: HKT<M, A>) => HKT<M, A> {\n  return (f) => (first) => M.chain(first, (a) => M.map(f(a), () => a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 103,
        "to": 105
      }
    }
  },
  {
    "name": "bind",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function bind<M extends URIS4>(\n  M: Chain4<M>\n): <N extends string, A, S, R, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind4<M, S, R, E, B>\n) => (ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, S, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 114,
        "to": 119
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M extends URIS3>(\n  M: Chain3<M>\n): <N extends string, A, R, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, R, E, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 120,
        "to": 125
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <N extends string, A, R, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, A>) => Kind3<M, R, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, R, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 126,
        "to": 131
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M extends URIS2>(\n  M: Chain2<M>\n): <N extends string, A, E, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, A>) => Kind2<M, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, E, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 132,
        "to": 137
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, A>) => Kind2<M, E, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 138,
        "to": 143
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M extends URIS>(\n  M: Chain1<M>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Kind<M, B>\n) => (ma: Kind<M, A>) => Kind<M, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 144,
        "to": 149
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M>(\n  M: Chain<M>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => HKT<M, B>\n) => (ma: HKT<M, A>) => HKT<M, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 150,
        "to": 155
      }
    }
  },
  {
    "name": "bind",
    "text": "\nexport function bind<M>(\n  M: Chain<M>\n): <N extends string, A, B>(\n  name: Exclude<N, keyof A>,\n  f: (a: A) => HKT<M, B>\n) => (ma: HKT<M, A>) => HKT<M, { readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }> {\n  return (name, f) => (ma) => M.chain(ma, (a) => M.map(f(a), (b) => Object.assign({}, a, { [name]: b }) as any))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, { readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Chain.ts",
      "lines": {
        "from": 156,
        "to": 163
      }
    }
  },
  {
    "name": "tailRec",
    "text": "const tailRec = <A, B>(startWith: A, f: (a: A) => Either<A, B>): B => {\n  let ab = f(startWith)\n  while (ab._tag === 'Left') {\n    ab = f(ab.left)\n  }\n  return ab.right\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "startWith",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ChainRec.ts",
      "lines": {
        "from": 71,
        "to": 77
      }
    }
  },
  {
    "name": "split",
    "text": "\n\n/**\n * Compose a value acting on a sum from two values, each acting on one of\n * the components of the sum.\n *\n * Specializing `split` to function application would look like this:\n *\n * ```purescript\n * split :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which\n * takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like\n * `bimap` would do for the `Bifunctor` instance of `Either`.\n *\n * @since 2.10.0\n */\nexport function split<P extends URIS4>(\n  P: Choice4<P>,\n  C: Category4<P>\n): <S, R, A, B, C, D>(\n  pab: Kind4<P, S, R, A, B>,\n  pcd: Kind4<P, S, R, C, D>\n) => Kind4<P, S, R, Either<A, C>, Either<B, D>>",
    "docs": "/**\n * Compose a value acting on a sum from two values, each acting on one of\n * the components of the sum.\n *\n * Specializing `split` to function application would look like this:\n *\n * ```purescript\n * split :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which\n * takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like\n * `bimap` would do for the `Bifunctor` instance of `Either`.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice4<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 93,
        "to": 99
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<P extends URIS3>(\n  P: Choice3<P>,\n  C: Category3<P>\n): <R, A, B, C, D>(pab: Kind3<P, R, A, B>, pcd: Kind3<P, R, C, D>) => Kind3<P, R, Either<A, C>, Either<B, D>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 100,
        "to": 103
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<P extends URIS2>(\n  P: Choice2<P>,\n  C: Category2<P>\n): <A, B, C, D>(pab: Kind2<P, A, B>, pcd: Kind2<P, C, D>) => Kind2<P, Either<A, C>, Either<B, D>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 104,
        "to": 107
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<P>(\n  P: Choice<P>,\n  C: Category<P>\n): <A, B, C, D>(pab: HKT2<P, A, B>, pcd: HKT2<P, C, D>) => HKT2<P, Either<A, C>, Either<B, D>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 108,
        "to": 111
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<P>(\n  P: Choice<P>,\n  C: Category<P>\n): <A, B, C, D>(pab: HKT2<P, A, B>, pcd: HKT2<P, C, D>) => HKT2<P, Either<A, C>, Either<B, D>> {\n  return <A, B, C, D>(pab: HKT2<P, A, B>, pcd: HKT2<P, C, D>) => C.compose(P.right<B, C, D>(pcd), P.left<A, B, C>(pab))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 112,
        "to": 117
      }
    }
  },
  {
    "name": "fanIn",
    "text": "\n\n/**\n * Compose a value which eliminates a sum from two values, each eliminating\n * one side of the sum.\n *\n * This combinator is useful when assembling values from smaller components,\n * because it provides a way to support two different types of input.\n *\n * Specializing `fanIn` to function application would look like this:\n *\n * ```purescript\n * fanIn :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n * ```\n *\n * We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a\n * single function which takes an `Either` value with the parameter type of `f` on the left side and\n * the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on\n * whether the `Either` value is a `Left` or a `Right`.\n * This allows us to bundle two different computations which both have the same result type into one\n * function which will run the appropriate computation based on the parameter supplied in the `Either` value.\n *\n * @since 2.10.0\n */\nexport function fanIn<P extends URIS4>(\n  P: Choice4<P>,\n  C: Category4<P>\n): <S, R, A, B, C>(pac: Kind4<P, S, R, A, C>, pbc: Kind4<P, S, R, B, C>) => Kind4<P, S, R, Either<A, B>, C>",
    "docs": "/**\n * Compose a value which eliminates a sum from two values, each eliminating\n * one side of the sum.\n *\n * This combinator is useful when assembling values from smaller components,\n * because it provides a way to support two different types of input.\n *\n * Specializing `fanIn` to function application would look like this:\n *\n * ```purescript\n * fanIn :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n * ```\n *\n * We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a\n * single function which takes an `Either` value with the parameter type of `f` on the left side and\n * the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on\n * whether the `Either` value is a `Left` or a `Right`.\n * This allows us to bundle two different computations which both have the same result type into one\n * function which will run the appropriate computation based on the parameter supplied in the `Either` value.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice4<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<P, S, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 141,
        "to": 144
      }
    }
  },
  {
    "name": "fanIn",
    "text": "\nexport function fanIn<P extends URIS3>(\n  P: Choice3<P>,\n  C: Category3<P>\n): <R, A, B, C>(pac: Kind3<P, R, A, C>, pbc: Kind3<P, R, B, C>) => Kind3<P, R, Either<A, B>, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<P, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 145,
        "to": 148
      }
    }
  },
  {
    "name": "fanIn",
    "text": "\nexport function fanIn<P extends URIS2>(\n  P: Choice2<P>,\n  C: Category2<P>\n): <A, B, C>(pac: Kind2<P, A, C>, pbc: Kind2<P, B, C>) => Kind2<P, Either<A, B>, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 149,
        "to": 152
      }
    }
  },
  {
    "name": "fanIn",
    "text": "\nexport function fanIn<P>(\n  P: Choice<P>,\n  C: Category<P>\n): <A, B, C>(pac: HKT2<P, A, C>, pbc: HKT2<P, B, C>) => HKT2<P, Either<A, B>, C>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 153,
        "to": 156
      }
    }
  },
  {
    "name": "fanIn",
    "text": "\nexport function fanIn<P>(\n  P: Choice<P>,\n  C: Category<P>\n): <A, B, C>(pac: HKT2<P, A, C>, pbc: HKT2<P, B, C>) => HKT2<P, Either<A, B>, C> {\n  const splitPC = split(P, C)\n  return <A, B, C>(pac: HKT2<P, A, C>, pbc: HKT2<P, B, C>): HKT2<P, Either<A, B>, C> =>\n    C.compose(\n      P.promap(C.id<C>(), (cc: Either<C, C>) => (cc._tag === 'Left' ? cc.left : cc.right), identity),\n      splitPC(pac, pbc)\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "P",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<P>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<P, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 157,
        "to": 167
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n/**\n * Use [`split`](#split) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function splitChoice<F extends URIS3>(\n  F: Category3<F> & Choice3<F>\n): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, Either<A, C>, Either<B, D>>",
    "docs": "/**\n * Use [`split`](#split) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 179,
        "to": 181
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\n/** @deprecated */\nexport function splitChoice<F extends URIS2>(\n  F: Category2<F> & Choice2<F>\n): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, Either<A, C>, Either<B, D>>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 183,
        "to": 185
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\n/** @deprecated */\nexport function splitChoice<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, Either<A, C>, Either<B, D>>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 187,
        "to": 189
      }
    }
  },
  {
    "name": "splitChoice",
    "text": "\nexport function splitChoice<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, Either<A, C>, Either<B, D>> {\n  return split(F, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, D>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 190,
        "to": 194
      }
    }
  },
  {
    "name": "fanin",
    "text": "\n\n/**\n * Use [`fanIn`](#fanIn) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function fanin<F extends URIS3>(\n  F: Category3<F> & Choice3<F>\n): <R, A, B, C>(pac: Kind3<F, R, A, C>, pbc: Kind3<F, R, B, C>) => Kind3<F, R, Either<A, B>, C>",
    "docs": "/**\n * Use [`fanIn`](#fanIn) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 202,
        "to": 204
      }
    }
  },
  {
    "name": "fanin",
    "text": "\n/** @deprecated */\nexport function fanin<F extends URIS2>(\n  F: Category2<F> & Choice2<F>\n): <A, B, C>(pac: Kind2<F, A, C>, pbc: Kind2<F, B, C>) => Kind2<F, Either<A, B>, C>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 206,
        "to": 208
      }
    }
  },
  {
    "name": "fanin",
    "text": "\n/** @deprecated */\nexport function fanin<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, C>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 210,
        "to": 212
      }
    }
  },
  {
    "name": "fanin",
    "text": "\nexport function fanin<F>(\n  F: Category<F> & Choice<F>\n): <A, B, C>(pac: HKT2<F, A, C>, pbc: HKT2<F, B, C>) => HKT2<F, Either<A, B>, C> {\n  return fanIn(F, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Choice\").Choice<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>, pbc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, B, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Choice.ts",
      "lines": {
        "from": 213,
        "to": 217
      }
    }
  },
  {
    "name": "compact",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `compact` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function compact<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Compactable2C<G, E>\n): <FE, A>(fa: Kind2<F, FE, Kind2<G, E, Option<A>>>) => Kind2<F, FE, Kind2<G, E, A>>",
    "docs": "/**\n * `compact` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 131,
        "to": 134
      }
    }
  },
  {
    "name": "compact",
    "text": "\nexport function compact<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Compactable2C<G, E>\n): <A>(fa: Kind<F, Kind2<G, E, Option<A>>>) => Kind<F, Kind2<G, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "compact",
    "text": "\nexport function compact<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Compactable1<G>\n): <A>(fa: Kind<F, Kind<G, Option<A>>>) => Kind<F, Kind<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 139,
        "to": 142
      }
    }
  },
  {
    "name": "compact",
    "text": "\nexport function compact<F, G>(F: Functor<F>, G: Compactable<G>): <A>(fa: HKT<F, HKT<G, Option<A>>>) => HKT<F, HKT<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 143,
        "to": 143
      }
    }
  },
  {
    "name": "compact",
    "text": "\nexport function compact<F, G>(\n  F: Functor<F>,\n  G: Compactable<G>\n): <A>(fa: HKT<F, HKT<G, Option<A>>>) => HKT<F, HKT<G, A>> {\n  return (fga) => F.map(fga, G.compact)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 144,
        "to": 149
      }
    }
  },
  {
    "name": "separate",
    "text": "\n\n/**\n * `separate` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function separate<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  C: Compactable2C<G, E>,\n  G: Functor2<G>\n): <FE, A, B>(\n  fge: Kind2<F, FE, Kind2<G, E, Either<A, B>>>\n) => S.Separated<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, B>>>",
    "docs": "/**\n * `separate` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A, B>(fge: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 157,
        "to": 163
      }
    }
  },
  {
    "name": "separate",
    "text": "\nexport function separate<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  C: Compactable2C<G, E>,\n  G: Functor2<G>\n): <A, B>(fge: Kind<F, Kind2<G, E, Either<A, B>>>) => S.Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fge: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 164,
        "to": 168
      }
    }
  },
  {
    "name": "separate",
    "text": "\nexport function separate<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  C: Compactable1<G>,\n  G: Functor1<G>\n): <A, B>(fge: Kind<F, Kind<G, Either<A, B>>>) => S.Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fge: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 169,
        "to": 173
      }
    }
  },
  {
    "name": "separate",
    "text": "\nexport function separate<F, G>(\n  F: Functor<F>,\n  C: Compactable<G>,\n  G: Functor<G>\n): <A, B>(fge: HKT<F, HKT<G, Either<A, B>>>) => S.Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fge: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 174,
        "to": 178
      }
    }
  },
  {
    "name": "separate",
    "text": "\nexport function separate<F, G>(\n  F: Functor<F>,\n  C: Compactable<G>,\n  G: Functor<G>\n): <A, B>(fge: HKT<F, HKT<G, Either<A, B>>>) => S.Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, B>>> {\n  const _compact = compact(F, C)\n  const _map = map(F, G)\n  return (fge) => S.separated(_compact(pipe(fge, _map(getLeft))), _compact(pipe(fge, _map(getRight))))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fge: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 179,
        "to": 187
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n\n/**\n * Use [`compact`](#compact) and [`separate`](#separate) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getCompactableComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Compactable3C<G, E> & Functor3C<G, E>\n): CompactableComposition23C<F, G, E>",
    "docs": "/**\n * Use [`compact`](#compact) and [`separate`](#separate) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 317,
        "to": 320
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition22C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 322,
        "to": 325
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition22<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 327,
        "to": 330
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition2C1<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 332,
        "to": 335
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition21<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 337,
        "to": 340
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Compactable2C<G, E> & Functor2C<G, E>\n): CompactableComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<G, E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 342,
        "to": 345
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Compactable2<G> & Functor2<G>\n): CompactableComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 347,
        "to": 350
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Compactable1<G> & Functor1<G>\n): CompactableComposition11<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 352,
        "to": 355
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F, G>(\n  F: Functor<F>,\n  G: Compactable<G> & Functor<G>\n): CompactableComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 357,
        "to": 360
      }
    }
  },
  {
    "name": "getCompactableComposition",
    "text": "\n/** @deprecated */\nexport function getCompactableComposition<F, G>(\n  F: Functor<F>,\n  G: Compactable<G> & Functor<G>\n): CompactableComposition<F, G> {\n  const map = getFunctorComposition(F, G).map\n  return {\n    map,\n    compact: compact(F, G),\n    separate: separate(F, G, G)\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<G> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").CompactableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Compactable.ts",
      "lines": {
        "from": 362,
        "to": 372
      }
    }
  },
  {
    "name": "log",
    "text": "const log = <A>(a: A): IO<void> => () => console.log(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 9,
        "to": 9
      }
    }
  },
  {
    "name": "warn",
    "text": "const warn = <A>(a: A): IO<void> => () => console.warn(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 14,
        "to": 14
      }
    }
  },
  {
    "name": "error",
    "text": "const error = <A>(a: A): IO<void> => () => console.error(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 19,
        "to": 19
      }
    }
  },
  {
    "name": "info",
    "text": "const info = <A>(a: A): IO<void> => () => console.info(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Console.ts",
      "lines": {
        "from": 24,
        "to": 24
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(S: Show<E>): Show<Const<E, A>> {\n  return {\n    show: (c) => `make(${S.show(c)})`\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 47,
        "to": 51
      }
    }
  },
  {
    "name": "getApply",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply<E>(S: Semigroup<E>): Apply2C<URI, E> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => make(S.concat(fab, fa))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"Const\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 111,
        "to": 118
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative<E>(M: Monoid<E>): Applicative2C<URI, E> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    of: () => make(M.empty)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"Const\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 124,
        "to": 133
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => <E>(fa: Const<E, A>) => Const<E, B> = () => unsafeCoerce",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 155,
        "to": 155
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Const<E, A>) => Const<E, B> = () => unsafeCoerce",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 164,
        "to": 164
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Const<E, A>) => Const<G, B> = (f) => (fa) =>\n  make(f(fa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 172,
        "to": 173
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Const<E, A>) => Const<G, A> = (f) => (fa) => make(f(fa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Const\").Const<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Const.ts",
      "lines": {
        "from": 181,
        "to": 181
      }
    }
  },
  {
    "name": "create",
    "text": "const create: IO<Date> = () => new Date()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "Date"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Date.ts",
      "lines": {
        "from": 65,
        "to": 65
      }
    }
  },
  {
    "name": "now",
    "text": "const now: IO<number> = () => new Date().getTime()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Date.ts",
      "lines": {
        "from": 72,
        "to": 72
      }
    }
  },
  {
    "name": "getMinMaxDistributiveLattice",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function getMinMaxDistributiveLattice<A>(O: Ord<A>): DistributiveLattice<A> {\n  return {\n    meet: min(O),\n    join: max(O)\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/DistributiveLattice\").DistributiveLattice<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/DistributiveLattice.ts",
      "lines": {
        "from": 30,
        "to": 35
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function swap<E, A>(ma: Either<E, A>): Either<A, E> {\n  return isLeft(ma) ? right(ma.left) : left(ma.right)\n}",
    "docs": "/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 412,
        "to": 414
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(SE: Show<E>, SA: Show<A>): Show<Either<E, A>> {\n  return {\n    show: (ma) => (isLeft(ma) ? `left(${SE.show(ma.left)})` : `right(${SA.show(ma.right)})`)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 817,
        "to": 821
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<E, A>(EL: Eq<E>, EA: Eq<A>): Eq<Either<E, A>> {\n  return {\n    equals: (x, y) =>\n      x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EL",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 827,
        "to": 832
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(S: Semigroup<A>): Semigroup<Either<E, A>> {\n  return {\n    concat: (x, y) => (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right)))\n  }\n}",
    "docs": "/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 851,
        "to": 855
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.10.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E> {\n  const empty = left(M.empty)\n\n  const { compact, separate } = getCompactable(M)\n\n  const filter = <A>(ma: Either<E, A>, predicate: Predicate<A>): Either<E, A> =>\n    isLeft(ma) ? ma : predicate(ma.right) ? ma : empty\n\n  const partition = <A>(ma: Either<E, A>, p: Predicate<A>): Separated<Either<E, A>, Either<E, A>> => {\n    return isLeft(ma)\n      ? separated(ma, ma)\n      : p(ma.right)\n      ? separated(empty, right(ma.right))\n      : separated(right(ma.right), empty)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact,\n    separate,\n    filter,\n    filterMap: (ma, f) => {\n      if (isLeft(ma)) {\n        return ma\n      }\n      const ob = f(ma.right)\n      return ob._tag === 'None' ? empty : right(ob.value)\n    },\n    partition,\n    partitionMap: (ma, f) => {\n      if (isLeft(ma)) {\n        return separated(ma, ma)\n      }\n      const e = f(ma.right)\n      return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right))\n    }\n  }\n}",
    "docs": "/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 884,
        "to": 923
      }
    }
  },
  {
    "name": "getWitherable",
    "text": "\n\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getWitherable<E>(M: Monoid<E>): Witherable2C<URI, E> {\n  const F_ = getFilterable(M)\n\n  const wither = <F>(\n    F: ApplicativeHKT<F>\n  ): (<A, B>(ma: Either<E, A>, f: (a: A) => HKT<F, Option<B>>) => HKT<F, Either<E, B>>) => {\n    const traverseF = _traverse(F)\n    return (ma, f) => F.map(traverseF(ma, f), F_.compact)\n  }\n\n  const wilt = <F>(\n    F: ApplicativeHKT<F>\n  ): (<A, B, C>(\n    ma: Either<E, A>,\n    f: (a: A) => HKT<F, Either<B, C>>\n  ) => HKT<F, Separated<Either<E, B>, Either<E, C>>>) => {\n    const traverseF = _traverse(F)\n    return (ma, f) => F.map(traverseF(ma, f), F_.separate)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact: F_.compact,\n    separate: F_.separate,\n    filter: F_.filter,\n    filterMap: F_.filterMap,\n    partition: F_.partition,\n    partitionMap: F_.partitionMap,\n    traverse: _traverse,\n    sequence,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    wither,\n    wilt\n  }\n}",
    "docs": "/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Witherable\").Witherable2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 931,
        "to": 969
      }
    }
  },
  {
    "name": "getApplicativeValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeValidation<E>(SE: Semigroup<E>): Applicative2C<URI, E> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) =>\n      isLeft(fab)\n        ? isLeft(fa)\n          ? left(SE.concat(fab.left, fa.left))\n          : fab\n        : isLeft(fa)\n        ? fa\n        : right(fab.right(fa.right)),\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 975,
        "to": 990
      }
    }
  },
  {
    "name": "getAltValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltValidation<E>(SE: Semigroup<E>): Alt2C<URI, E> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    alt: (me, that) => {\n      if (isRight(me)) {\n        return me\n      }\n      const ea = that()\n      return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 996,
        "to": 1009
      }
    }
  },
  {
    "name": "toError",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e: unknown): Error {\n  return e instanceof Error ? e : new Error(String(e))\n}",
    "docs": "/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Unknown"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Error"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1230,
        "to": 1232
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): <E>(a: A, ma: Either<E, A>) => boolean {\n  return (a, ma) => (isLeft(ma) ? false : E.equals(a, ma.right))\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(a: A, ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1237,
        "to": 1239
      }
    }
  },
  {
    "name": "exists",
    "text": "\n\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport function exists<A>(predicate: Predicate<A>): <E>(ma: Either<E, A>) => boolean {\n  return (ma) => (isLeft(ma) ? false : predicate(ma.right))\n}",
    "docs": "/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1255,
        "to": 1257
      }
    }
  },
  {
    "name": "parseJSON",
    "text": "\n\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport function parseJSON<E>(s: string, onError: (reason: unknown) => E): Either<E, Json> {\n  return tryCatch(() => JSON.parse(s), onError)\n}",
    "docs": "/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Json>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1397,
        "to": 1399
      }
    }
  },
  {
    "name": "getValidation",
    "text": "\n\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation<E>(\n  SE: Semigroup<E>\n): Monad2C<URI, E> &\n  Foldable2<URI> &\n  Traversable2<URI> &\n  Bifunctor2<URI> &\n  Alt2C<URI, E> &\n  Extend2<URI> &\n  ChainRec2C<URI, E> &\n  MonadThrow2C<URI, E> {\n  const ap = getApplicativeValidation(SE).ap\n  const alt = getAltValidation(SE).alt\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    extend: _extend,\n    traverse: _traverse,\n    sequence,\n    chainRec: _chainRec,\n    throwError,\n    ap,\n    alt\n  }\n}",
    "docs": "/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2<\"Either\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ChainRec\").ChainRec2C<\"Either\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1502,
        "to": 1533
      }
    }
  },
  {
    "name": "isRight",
    "text": "const isRight = <E, A>(ma: Either<E, A>): ma is Right<A> => ma._tag === 'Right'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 95,
        "to": 95
      }
    }
  },
  {
    "name": "left",
    "text": "const left = <E = never, A = never>(e: E): Either<E, A> => ({ _tag: 'Left', left: e })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 108,
        "to": 108
      }
    }
  },
  {
    "name": "right",
    "text": "const right = <E = never, A = never>(a: A): Either<E, A> => ({ _tag: 'Right', right: a })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 117,
        "to": 117
      }
    }
  },
  {
    "name": "fromOption",
    "text": "const fromOption: <E>(onNone: Lazy<E>) => <A>(ma: Option<A>) => Either<E, A> = (onNone) => (ma) =>\n  ma._tag === 'None' ? left(onNone()) : right(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 143,
        "to": 144
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "const fromPredicate: {\n  <E, A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Either<E, B>\n  <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Either<E, A>\n} = <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (a: A) => (predicate(a) ? right(a) : left(onFalse(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Right<A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Left<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 175,
        "to": 178
      }
    }
  },
  {
    "name": "matchW",
    "text": "const matchW = <E, B, A, C>(onLeft: (e: E) => B, onRight: (a: A) => C) => (ma: Either<E, A>): B | C =>\n  isLeft(ma) ? onLeft(ma.left) : onRight(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        },
        {
          "name": "onRight",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B | C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 190,
        "to": 191
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <E, B>(onLeft: (e: E) => B) => <A>(ma: Either<E, A>): A | B =>\n  isLeft(ma) ? onLeft(ma.left) : ma.right",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B | A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 251,
        "to": 252
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "const fromNullable = <E>(e: E) => <A>(a: A): Either<E, NonNullable<A>> =>\n  a == null ? left(e) : right(a as NonNullable<A>)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, NonNullable<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 301,
        "to": 302
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch = <E, A>(f: Lazy<A>, onThrow: (e: unknown) => E): Either<E, A> => {\n  try {\n    return right(f())\n  } catch (e) {\n    return left(onThrow(e))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        },
        {
          "name": "onThrow",
          "type": {
            "__tag": "Other",
            "values": "(e: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 329,
        "to": 335
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "const tryCatchK = <A extends ReadonlyArray<unknown>, B, E>(\n  f: (...a: A) => B,\n  onThrow: (error: unknown) => E\n): ((...a: A) => Either<E, B>) => (...a) => tryCatch(() => f(...a), onThrow)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "onThrow",
          "type": {
            "__tag": "Other",
            "values": "(error: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 343,
        "to": 346
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "const fromNullableK = <E>(\n  e: E\n): (<A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => Either<E, NonNullable<B>>) => {\n  const from = fromNullable(e)\n  return (f) => flow(f, from)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, NonNullable<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 352,
        "to": 359
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "const chainNullableK = <E>(\n  e: E\n): (<A, B>(f: (a: A) => B | null | undefined) => (ma: Either<E, A>) => Either<E, NonNullable<B>>) => {\n  const from = fromNullableK(e)\n  return (f) => chain(from(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, NonNullable<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 365,
        "to": 370
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "const fromOptionK = <E>(\n  onNone: Lazy<E>\n): (<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => Either<E, B>) => {\n  const from = fromOption(onNone)\n  return (f) => flow(f, from)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 388,
        "to": 393
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "const chainOptionK = <E>(\n  onNone: Lazy<E>\n): (<A, B>(f: (a: A) => Option<B>) => (ma: Either<E, A>) => Either<E, B>) => {\n  const from = fromOptionK(onNone)\n  return (f) => chain(from(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 399,
        "to": 404
      }
    }
  },
  {
    "name": "orElseW",
    "text": "const orElseW = <E1, E2, B>(onLeft: (e: E1) => Either<E2, B>) => <A>(ma: Either<E1, A>): Either<E2, A | B> =>\n  isLeft(ma) ? onLeft(ma.left) : ma",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 422,
        "to": 423
      }
    }
  },
  {
    "name": "filterOrElseW",
    "text": "const filterOrElseW: {\n  <A, B extends A, E2>(refinement: Refinement<A, B>, onFalse: (a: A) => E2): <E1>(\n    ma: Either<E1, A>\n  ) => Either<E1 | E2, B>\n  <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): <E1>(ma: Either<E1, A>) => Either<E1 | E2, A>\n} = <A, E2>(predicate: Predicate<A>, onFalse: (a: A) => E2): (<E1>(ma: Either<E1, A>) => Either<E1 | E2, A>) =>\n  chainW((a) => (predicate(a) ? right(a) : left(onFalse(a))))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        },
        {
          "name": "onFalse",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => E2"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2 | E1, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 439,
        "to": 445
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Either<E, A>) => Either<E, B> = (f) => (fa) =>\n  isLeft(fa) ? fa : right(f(fa.right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 536,
        "to": 537
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Either<E, A>) => Either<G, B> = (f, g) => (\n  fa\n) => (isLeft(fa) ? left(f(fa.left)) : right(g(fa.right)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 545,
        "to": 547
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Either<E, A>) => Either<G, A> = (f) => (fa) =>\n  isLeft(fa) ? left(f(fa.left)) : fa",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 555,
        "to": 556
      }
    }
  },
  {
    "name": "apW",
    "text": "const apW: <E2, A>(fa: Either<E2, A>) => <E1, B>(fab: Either<E1, (a: A) => B>) => Either<E1 | E2, B> = (fa) => (\n  fab\n) => (isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 564,
        "to": 566
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW = <E2, A, B>(f: (a: A) => Either<E2, B>) => <E1>(ma: Either<E1, A>): Either<E1 | E2, B> =>\n  isLeft(ma) ? ma : f(ma.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 588,
        "to": 589
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW: <E2, B>(that: Lazy<Either<E2, B>>) => <E1, A>(fa: Either<E1, A>) => Either<E2, A | B> = (that) => (\n  fa\n) => (isLeft(fa) ? that() : fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Right<A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Left<E2> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Right<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 624,
        "to": 626
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: Either<E, A>) => B) => (wa: Either<E, A>) => Either<E, B> = (f) => (wa) =>\n  isLeft(wa) ? wa : right(f(wa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 641,
        "to": 642
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: Either<E, A>) => B = (b, f) => (fa) =>\n  isLeft(fa) ? b : f(b, fa.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 677,
        "to": 678
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: Either<E, A>) => M = (M) => (f) => (fa) =>\n  isLeft(fa) ? M.empty : f(fa.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 703,
        "to": 704
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: Either<E, A>) => B = (b, f) => (fa) =>\n  isLeft(fa) ? b : f(fa.right, b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 729,
        "to": 730
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(F: ApplicativeHKT<F>) => <A, B>(f: (a: A) => HKT<F, B>) => <E>(\n  ta: Either<E, A>\n): HKT<F, Either<E, B>> => (isLeft(ta) ? F.of(left(ta.left)) : F.map<B, Either<E, B>>(f(ta.right), right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 754,
        "to": 756
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: ApplicativeHKT<F>) => <E, A>(\n  ma: Either<E, HKT<F, A>>\n): HKT<F, Either<E, A>> => {\n  return isLeft(ma) ? F.of(left(ma.left)) : F.map<A, Either<E, A>>(ma.right, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 779,
        "to": 783
      }
    }
  },
  {
    "name": "getCompactable",
    "text": "const getCompactable = <E>(M: Monoid<E>): Compactable2C<URI, E> => {\n  const empty = left(M.empty)\n  return {\n    URI,\n    _E: undefined as any,\n    compact: (ma) => (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)),\n    separate: (ma) =>\n      isLeft(ma)\n        ? separated(ma, ma)\n        : isLeft(ma.right)\n        ? separated(right(ma.right.left), empty)\n        : separated(empty, right(ma.right.right))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<\"Either\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 863,
        "to": 876
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <E, A, B>(f: (index: number, a: A) => Either<E, B>) => (\n  as: ReadonlyArray<A>\n): Either<E, ReadonlyArray<B>> => {\n  const out = []\n  for (let i = 0; i < as.length; i++) {\n    const e = f(i, as[i])\n    if (isLeft(e)) {\n      return e\n    }\n    out.push(e.right)\n  }\n  return right(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1324,
        "to": 1336
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <E, A, B>(\n  f: (a: A) => Either<E, B>\n): ((as: ReadonlyArray<A>) => Either<E, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1343,
        "to": 1345
      }
    }
  },
  {
    "name": "stringifyJSON",
    "text": "const stringifyJSON = <E>(u: unknown, onError: (reason: unknown) => E): Either<E, string> =>\n  tryCatch(() => {\n    const s = JSON.stringify(u)\n    if (typeof s !== 'string') {\n      throw new Error('Converting unsupported structure to JSON')\n    }\n    return s\n  }, onError)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "u",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "onError",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, string>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1408,
        "to": 1415
      }
    }
  },
  {
    "name": "getValidationSemigroup",
    "text": "const getValidationSemigroup = <E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<Either<E, A>> =>\n  getApplySemigroup_(getApplicativeValidation(SE))(SA)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1482,
        "to": 1483
      }
    }
  },
  {
    "name": "getValidationMonoid",
    "text": "const getValidationMonoid = <E, A>(SE: Semigroup<E>, MA: Monoid<A>): Monoid<Either<E, A>> =>\n  getApplicativeMonoid(getApplicativeValidation(SE))(MA)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "MA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Either.ts",
      "lines": {
        "from": 1492,
        "to": 1493
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function right<F extends URIS3>(F: Pointed3<F>): <A, R, FE, E = never>(a: A) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FE, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 24,
        "to": 24
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS3, FE>(\n  F: Pointed3C<F, FE>\n): <A, R, E = never>(a: A) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS2>(F: Pointed2<F>): <A, FE, E = never>(a: A) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, FE, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 28,
        "to": 28
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, E = never>(a: A) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 29,
        "to": 29
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS>(F: Pointed1<F>): <A, E = never>(a: A) => Kind<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 30,
        "to": 30
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 31,
        "to": 31
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, Either<E, A>> {\n  return flow(E.right, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 32,
        "to": 34
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function left<F extends URIS3>(F: Pointed3<F>): <E, R, FE, A = never>(e: E) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, FE, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 39,
        "to": 39
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS3, FE>(F: Pointed3C<F, FE>): <E, R, A = never>(e: E) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 40,
        "to": 40
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS2>(F: Pointed2<F>): <E, FE, A = never>(e: E) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, FE, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 41,
        "to": 41
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS2, FE>(F: Pointed2C<F, FE>): <E, A = never>(e: E) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 42,
        "to": 42
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS>(F: Pointed1<F>): <E, A = never>(e: E) => Kind<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 43,
        "to": 43
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 44,
        "to": 44
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, Either<E, A>> {\n  return flow(E.left, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 45,
        "to": 47
      }
    }
  },
  {
    "name": "rightF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function rightF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 52,
        "to": 54
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 55,
        "to": 57
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS2>(\n  F: Functor2<F>\n): <FE, A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 58,
        "to": 60
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS>(F: Functor1<F>): <A, E = never>(fa: Kind<F, A>) => Kind<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 64,
        "to": 64
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 65,
        "to": 65
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, Either<E, A>> {\n  return (fa) => F.map(fa, E.right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "leftF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function leftF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 73,
        "to": 75
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 76,
        "to": 78
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS2>(\n  F: Functor2<F>\n): <FE, E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 79,
        "to": 81
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 85,
        "to": 85
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 86,
        "to": 86
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, Either<E, A>> {\n  return (fe) => F.map(fe, E.left)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 87,
        "to": 89
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <R, FE, E>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, FE, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <FE, E>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <FE, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 104,
        "to": 106
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 107,
        "to": 109
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS>(\n  F: Functor1<F>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind<F, Either<E, A>>) => Kind<F, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Either<E, A>>) => HKT<F, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 113,
        "to": 113
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Either<E, A>>) => HKT<F, Either<E, B>> {\n  return map_(F, E.Functor)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 114,
        "to": 116
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function ap<F extends URIS3>(\n  F: Apply3<F>\n): <R, FE, E, A>(\n  fa: Kind3<F, R, FE, Either<E, A>>\n) => <B>(fab: Kind3<F, R, FE, Either<E, (a: A) => B>>) => Kind3<F, R, FE, Either<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 121,
        "to": 125
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3, FE>(\n  F: Apply3C<F, FE>\n): <R, E, A>(\n  fa: Kind3<F, R, FE, Either<E, A>>\n) => <B>(fab: Kind3<F, R, FE, Either<E, (a: A) => B>>) => Kind3<F, R, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 126,
        "to": 130
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2>(\n  F: Apply2<F>\n): <FE, E, A>(\n  fa: Kind2<F, FE, Either<E, A>>\n) => <B>(fab: Kind2<F, FE, Either<E, (a: A) => B>>) => Kind2<F, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 131,
        "to": 135
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2, FE>(\n  F: Apply2C<F, FE>\n): <E, A>(\n  fa: Kind2<F, FE, Either<E, A>>\n) => <B>(fab: Kind2<F, FE, Either<E, (a: A) => B>>) => Kind2<F, FE, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 136,
        "to": 140
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS>(\n  F: Apply1<F>\n): <E, A>(fa: Kind<F, Either<E, A>>) => <B>(fab: Kind<F, Either<E, (a: A) => B>>) => Kind<F, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 141,
        "to": 143
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <E, A>(fa: HKT<F, Either<E, A>>) => <B>(fab: HKT<F, Either<E, (a: A) => B>>) => HKT<F, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 144,
        "to": 146
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <E, A>(fa: HKT<F, Either<E, A>>) => <B>(fab: HKT<F, Either<E, (a: A) => B>>) => HKT<F, Either<E, B>> {\n  return ap_(F, E.Apply)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 147,
        "to": 151
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chain<M extends URIS3>(\n  M: Monad3<M>\n): <A, R, ME, E, B>(\n  f: (a: A) => Kind3<M, R, ME, Either<E, B>>\n) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, ME, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 156,
        "to": 160
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3, ME>(\n  M: Monad3C<M, ME>\n): <A, R, E, B>(\n  f: (a: A) => Kind3<M, R, ME, Either<E, B>>\n) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 161,
        "to": 165
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2>(\n  M: Monad2<M>\n): <A, ME, E, B>(\n  f: (a: A) => Kind2<M, ME, Either<E, B>>\n) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, ME, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 166,
        "to": 170
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, ME>(\n  M: Monad2C<M, ME>\n): <A, E, B>(f: (a: A) => Kind2<M, ME, Either<E, B>>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 171,
        "to": 173
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS>(\n  M: Monad1<M>\n): <A, E, B>(f: (a: A) => Kind<M, Either<E, B>>) => (ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 174,
        "to": 176
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Monad<M>\n): <A, E, B>(f: (a: A) => HKT<M, Either<E, B>>) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 177,
        "to": 179
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Monad<M>\n): <A, E, B>(f: (a: A) => HKT<M, Either<E, B>>) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, B>> {\n  return (f) => (ma) => M.chain(ma, (e) => (E.isLeft(e) ? M.of(e) : f(e.right)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 180,
        "to": 184
      }
    }
  },
  {
    "name": "alt",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function alt<M extends URIS3>(\n  M: Monad3<M>\n): <R, ME, E, A>(\n  second: Lazy<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, ME, E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 189,
        "to": 193
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS3, ME>(\n  M: Monad3C<M, ME>\n): <R, E, A>(\n  second: Lazy<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 194,
        "to": 198
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS2>(\n  M: Monad2<M>\n): <ME, E, A>(\n  second: Lazy<Kind2<M, ME, Either<E, A>>>\n) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<ME, E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 199,
        "to": 203
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS2, ME>(\n  M: Monad2C<M, ME>\n): <E, A>(second: Lazy<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 204,
        "to": 206
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS>(\n  M: Monad1<M>\n): <E, A>(second: Lazy<Kind<M, Either<E, A>>>) => (first: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 207,
        "to": 209
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M>(\n  M: Monad<M>\n): <E, A>(second: Lazy<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 210,
        "to": 212
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M>(\n  M: Monad<M>\n): <E, A>(second: Lazy<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>> {\n  return (second) => (first) => M.chain(first, (e) => (E.isLeft(e) ? second() : M.of(e)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 213,
        "to": 217
      }
    }
  },
  {
    "name": "bimap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function bimap<F extends URIS3>(\n  F: Functor3<F>\n): <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <R, FE>(fea: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R, FE>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 222,
        "to": 227
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <R>(fea: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 228,
        "to": 233
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS2>(\n  F: Functor2<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(fea: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 234,
        "to": 236
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 237,
        "to": 239
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS>(\n  F: Functor1<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind<F, Either<E, A>>) => Kind<F, Either<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 240,
        "to": 242
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F>(\n  F: Functor<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT<F, Either<E, A>>) => HKT<F, Either<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 243,
        "to": 245
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F>(\n  F: Functor<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT<F, Either<E, A>>) => HKT<F, Either<G, B>> {\n  return (f, g) => (fea) => F.map(fea, E.bimap(f, g))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 246,
        "to": 250
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function mapLeft<F extends URIS3>(\n  F: Functor3<F>\n): <E, G>(f: (e: E) => G) => <R, FE, A>(fea: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <R, FE, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 255,
        "to": 257
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, G>(f: (e: E) => G) => <R, A>(fea: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <R, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 258,
        "to": 260
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS2>(\n  F: Functor2<F>\n): <E, G>(f: (e: E) => G) => <FE, A>(fea: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <FE, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 261,
        "to": 263
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, G>(f: (e: E) => G) => <A>(fea: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 264,
        "to": 266
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS>(\n  F: Functor1<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: Kind<F, Either<E, A>>) => Kind<F, Either<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 267,
        "to": 269
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F>(\n  F: Functor<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: HKT<F, Either<E, A>>) => HKT<F, Either<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 270,
        "to": 272
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F>(\n  F: Functor<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: HKT<F, Either<E, A>>) => HKT<F, Either<G, A>> {\n  return (f) => (fea) => F.map(fea, E.mapLeft(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 273,
        "to": 277
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function altValidation<M extends URIS3, E>(\n  M: Monad3<M>,\n  S: Semigroup<E>\n): <R, ME, A>(\n  second: Lazy<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, ME, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 282,
        "to": 287
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M extends URIS3, ME, E>(\n  M: Monad3C<M, ME>,\n  S: Semigroup<E>\n): <R, A>(\n  second: Lazy<Kind3<M, R, ME, Either<E, A>>>\n) => (first: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 288,
        "to": 293
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M extends URIS2, E>(\n  M: Monad2<M>,\n  S: Semigroup<E>\n): <ME, A>(\n  second: Lazy<Kind2<M, ME, Either<E, A>>>\n) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<ME, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 294,
        "to": 299
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M extends URIS2, ME, E>(\n  M: Monad2C<M, ME>,\n  S: Semigroup<E>\n): <A>(second: Lazy<Kind2<M, ME, Either<E, A>>>) => (first: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 300,
        "to": 303
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M extends URIS, E>(\n  M: Monad1<M>,\n  S: Semigroup<E>\n): <A>(second: Lazy<Kind<M, Either<E, A>>>) => (first: Kind<M, Either<E, A>>) => Kind<M, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 304,
        "to": 307
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M, E>(\n  M: Monad<M>,\n  S: Semigroup<E>\n): <A>(second: Lazy<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 308,
        "to": 311
      }
    }
  },
  {
    "name": "altValidation",
    "text": "\nexport function altValidation<M, E>(\n  M: Monad<M>,\n  S: Semigroup<E>\n): <A>(second: Lazy<HKT<M, Either<E, A>>>) => (first: HKT<M, Either<E, A>>) => HKT<M, Either<E, A>> {\n  return (second) => (first) =>\n    M.chain(\n      first,\n      E.match(\n        (e1) =>\n          M.map(\n            second(),\n            E.mapLeft((e2) => S.concat(e1, e2))\n          ),\n        right(M)\n      )\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 312,
        "to": 328
      }
    }
  },
  {
    "name": "match",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 3.0.0\n */\nexport function match<F extends URIS3>(\n  F: Functor3<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B\n) => <R, ME>(ma: Kind3<F, R, ME, Either<E, A>>) => Kind3<F, R, ME, B>",
    "docs": "/**\n * @since 3.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R, ME>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, ME, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 337,
        "to": 342
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 343,
        "to": 345
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS2>(\n  F: Functor2<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <FE>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => <FE>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 346,
        "to": 348
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 349,
        "to": 351
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS>(\n  F: Functor1<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: Kind<F, Either<E, A>>) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 352,
        "to": 354
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: HKT<F, Either<E, A>>) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 355,
        "to": 357
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: HKT<F, Either<E, A>>) => HKT<F, B> {\n  return (onLeft, onRight) => (ma) => F.map(ma, E.match(onLeft, onRight))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 358,
        "to": 362
      }
    }
  },
  {
    "name": "matchE",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function matchE<M extends URIS3>(\n  M: Chain3<M>\n): <E, R, FE, B, A>(\n  onLeft: (e: E) => Kind3<M, R, FE, B>,\n  onRight: (a: A) => Kind3<M, R, FE, B>\n) => (ma: Kind3<M, R, FE, Either<E, A>>) => Kind3<M, R, FE, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, FE, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 367,
        "to": 372
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS3, FE>(\n  M: Chain3C<M, FE>\n): <E, R, B, A>(\n  onLeft: (e: E) => Kind3<M, R, FE, B>,\n  onRight: (a: A) => Kind3<M, R, FE, B>\n) => (ma: Kind3<M, R, FE, Either<E, A>>) => Kind3<M, R, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 373,
        "to": 378
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2>(\n  M: Chain2<M>\n): <E, FE, B, A>(\n  onLeft: (e: E) => Kind2<M, FE, B>,\n  onRight: (a: A) => Kind2<M, FE, B>\n) => (ma: Kind2<M, FE, Either<E, A>>) => Kind2<M, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, FE, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 379,
        "to": 384
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2, FE>(\n  M: Chain2C<M, FE>\n): <E, B, A>(\n  onLeft: (e: E) => Kind2<M, FE, B>,\n  onRight: (a: A) => Kind2<M, FE, B>\n) => (ma: Kind2<M, FE, Either<E, A>>) => Kind2<M, FE, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 385,
        "to": 390
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS>(\n  M: Chain1<M>\n): <E, B, A>(onLeft: (e: E) => Kind<M, B>, onRight: (a: A) => Kind<M, B>) => (ma: Kind<M, Either<E, A>>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 391,
        "to": 393
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <E, B, A>(onLeft: (e: E) => HKT<M, B>, onRight: (a: A) => HKT<M, B>) => (ma: HKT<M, Either<E, A>>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 394,
        "to": 396
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <E, B, A>(onLeft: (e: E) => HKT<M, B>, onRight: (a: A) => HKT<M, B>) => (ma: HKT<M, Either<E, A>>) => HKT<M, B> {\n  return (onLeft, onRight) => (ma) => M.chain(ma, E.match(onLeft, onRight))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 397,
        "to": 401
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function getOrElse<M extends URIS3>(\n  M: Monad3<M>\n): <E, R, ME, A>(onLeft: (e: E) => Kind3<M, R, ME, A>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, ME, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 406,
        "to": 408
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS3, ME>(\n  M: Monad3C<M, ME>\n): <E, R, A>(onLeft: (e: E) => Kind3<M, R, ME, A>) => (ma: Kind3<M, R, ME, Either<E, A>>) => Kind3<M, R, ME, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 409,
        "to": 411
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS2>(\n  M: Monad2<M>\n): <E, ME, A>(onLeft: (e: E) => Kind2<M, ME, A>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, ME, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 412,
        "to": 414
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS2, ME>(\n  M: Monad2C<M, ME>\n): <E, A>(onLeft: (e: E) => Kind2<M, ME, A>) => (ma: Kind2<M, ME, Either<E, A>>) => Kind2<M, ME, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 415,
        "to": 417
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS>(\n  M: Monad1<M>\n): <E, A>(onLeft: (e: E) => Kind<M, A>) => (ma: Kind<M, Either<E, A>>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 418,
        "to": 420
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M>(\n  M: Monad<M>\n): <E, A>(onLeft: (e: E) => HKT<M, A>) => (ma: HKT<M, Either<E, A>>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 421,
        "to": 423
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M>(\n  M: Monad<M>\n): <E, A>(onLeft: (e: E) => HKT<M, A>) => (ma: HKT<M, Either<E, A>>) => HKT<M, A> {\n  return (onLeft) => (ma) => M.chain(ma, E.match(onLeft, M.of))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 424,
        "to": 428
      }
    }
  },
  {
    "name": "orElse",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function orElse<M extends URIS3>(\n  M: Monad3<M>\n): <E1, R, ME, E2, A>(\n  onLeft: (e: E1) => Kind3<M, R, ME, Either<E2, A>>\n) => (ma: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, R, ME, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 437,
        "to": 441
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M extends URIS3, ME>(\n  M: Monad3C<M, ME>\n): <E1, R, E2, A>(\n  onLeft: (e: E1) => Kind3<M, R, ME, Either<E2, A>>\n) => (ma: Kind3<M, R, ME, Either<E1, A>>) => Kind3<M, R, ME, Either<E2, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, R, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 442,
        "to": 446
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M extends URIS2>(\n  M: Monad2<M>\n): <E1, ME, E2, A>(\n  onLeft: (e: E1) => Kind2<M, ME, Either<E2, A>>\n) => (ma: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, ME, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 447,
        "to": 451
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M extends URIS2, ME>(\n  M: Monad2C<M, ME>\n): <E1, E2, A>(\n  onLeft: (e: E1) => Kind2<M, ME, Either<E2, A>>\n) => (ma: Kind2<M, ME, Either<E1, A>>) => Kind2<M, ME, Either<E2, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 452,
        "to": 456
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M extends URIS>(\n  M: Monad1<M>\n): <E1, E2, A>(onLeft: (e: E1) => Kind<M, Either<E2, A>>) => (ma: Kind<M, Either<E1, A>>) => Kind<M, Either<E2, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 457,
        "to": 459
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M>(\n  M: Monad<M>\n): <E1, E2, A>(onLeft: (e: E1) => HKT<M, Either<E2, A>>) => (ma: HKT<M, Either<E1, A>>) => HKT<M, Either<E2, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 460,
        "to": 462
      }
    }
  },
  {
    "name": "orElse",
    "text": "\nexport function orElse<M>(\n  M: Monad<M>\n): <E1, E2, A>(onLeft: (e: E1) => HKT<M, Either<E2, A>>) => (ma: HKT<M, Either<E1, A>>) => HKT<M, Either<E2, A>> {\n  return (onLeft) => (ma) => M.chain(ma, (e) => (E.isLeft(e) ? onLeft(e.left) : M.of(e)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1, E2, A>(onLeft: (e: E1) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E1, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E2, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 463,
        "to": 467
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function swap<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<A, E>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 476,
        "to": 478
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, E, A>(ma: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, Either<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 479,
        "to": 481
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS2>(\n  F: Functor2<F>\n): <FE, E, A>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 482,
        "to": 484
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A>(ma: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, Either<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 485,
        "to": 487
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS>(F: Functor1<F>): <E, A>(ma: Kind<F, Either<E, A>>) => Kind<F, Either<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 488,
        "to": 488
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F>(F: Functor<F>): <E, A>(ma: HKT<F, Either<E, A>>) => HKT<F, Either<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 489,
        "to": 489
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F>(F: Functor<F>): <E, A>(ma: HKT<F, Either<E, A>>) => HKT<F, Either<A, E>> {\n  return (ma) => F.map(ma, E.swap)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 490,
        "to": 492
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function toUnion<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, E | A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 497,
        "to": 499
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, E, A>(fa: Kind3<F, R, FE, Either<E, A>>) => Kind3<F, R, FE, E | A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 500,
        "to": 502
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F extends URIS2>(\n  F: Functor2<F>\n): <FE, E, A>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, E | A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 503,
        "to": 505
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A>(fa: Kind2<F, FE, Either<E, A>>) => Kind2<F, FE, E | A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 506,
        "to": 508
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F extends URIS>(F: Functor1<F>): <E, A>(fa: Kind<F, Either<E, A>>) => Kind<F, E | A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 509,
        "to": 509
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F>(F: Functor<F>): <E, A>(fa: HKT<F, Either<E, A>>) => HKT<F, E | A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 510,
        "to": 510
      }
    }
  },
  {
    "name": "toUnion",
    "text": "\nexport function toUnion<F>(F: Functor<F>): <E, A>(fa: HKT<F, Either<E, A>>) => HKT<F, E | A> {\n  return (fa) => F.map(fa, E.toUnion)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 511,
        "to": 513
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport function getEitherM<M extends URIS2>(M: Monad2<M>): EitherM2<M>",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 614,
        "to": 614
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\n/** @deprecated  */\nexport function getEitherM<M extends URIS>(M: Monad1<M>): EitherM1<M>",
    "docs": "/** @deprecated  */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 616,
        "to": 616
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\n/** @deprecated  */\nexport function getEitherM<M>(M: Monad<M>): EitherM<M>",
    "docs": "/** @deprecated  */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 618,
        "to": 618
      }
    }
  },
  {
    "name": "getEitherM",
    "text": "\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM<M>(M: Monad<M>): EitherM<M> {\n  const _ap = ap(M)\n  const _map = map(M)\n  const _chain = chain(M)\n  const _alt = alt(M)\n  const _bimap = bimap(M)\n  const _mapLeft = mapLeft(M)\n  const _fold = matchE(M)\n  const _getOrElse = getOrElse(M)\n  const _orElse = orElse(M)\n\n  return {\n    map: (fa, f) => pipe(fa, _map(f)),\n    ap: (fab, fa) => pipe(fab, _ap(fa)),\n    of: right(M),\n    chain: (ma, f) => pipe(ma, _chain(f)),\n    alt: (fa, that) => pipe(fa, _alt(that)),\n    bimap: (fea, f, g) => pipe(fea, _bimap(f, g)),\n    mapLeft: (fea, f) => pipe(fea, _mapLeft(f)),\n    fold: (fa, onLeft, onRight) => pipe(fa, _fold(onLeft, onRight)),\n    getOrElse: (fa, onLeft) => pipe(fa, _getOrElse(onLeft)),\n    orElse: (fa, f) => pipe(fa, _orElse(f)),\n    swap: swap(M),\n    rightM: rightF(M),\n    leftM: leftF(M),\n    left: left(M)\n  }\n}",
    "docs": "/** @deprecated  */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/EitherT\").EitherM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/EitherT.ts",
      "lines": {
        "from": 621,
        "to": 648
      }
    }
  },
  {
    "name": "fromEquals",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromEquals<A>(equals: (x: A, y: A) => boolean): Eq<A> {\n  return {\n    equals: (x, y) => x === y || equals(x, y)\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "equals",
          "type": {
            "__tag": "Other",
            "values": "(x: A, y: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 38,
        "to": 42
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(eqs: { [K in keyof A]: Eq<A[K]> }): Eq<{ readonly [K in keyof A]: A[K] }> =>\n  fromEquals((first, second) => {\n    for (const key in eqs) {\n      if (!eqs[key].equals(first[key], second[key])) {\n        return false\n      }\n    }\n    return true\n  })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eqs",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<{ readonly [K in keyof A]: A[K]; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 52,
        "to": 60
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(...eqs: { [K in keyof A]: Eq<A[K]> }): Eq<Readonly<A>> =>\n  fromEquals((first, second) => eqs.every((E, i) => E.equals(first[i], second[i])))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "eqs",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 80,
        "to": 81
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => (fa: Eq<A>) => Eq<B> = (f) => (fa) =>\n  fromEquals((x, y) => fa.equals(f(x), f(y)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 98,
        "to": 99
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A>(): Semigroup<Eq<A>> => ({\n  concat: (x, y) => fromEquals((a, b) => x.equals(a, b) && y.equals(a, b))\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 139,
        "to": 141
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <A>(): Monoid<Eq<A>> => ({\n  concat: getSemigroup<A>().concat,\n  empty\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Eq.ts",
      "lines": {
        "from": 147,
        "to": 150
      }
    }
  },
  {
    "name": "gcd",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * The *greatest common divisor* of two values\n *\n * @since 2.0.0\n */\nexport function gcd<A>(E: Eq<A>, field: Field<A>): (x: A, y: A) => A {\n  const zero = field.zero\n  const f = (x: A, y: A): A => (E.equals(y, zero) ? x : f(y, field.mod(x, y)))\n  return f\n}",
    "docs": "/**\n * The *greatest common divisor* of two values\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        },
        {
          "name": "field",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Field\").Field<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Field.ts",
      "lines": {
        "from": 32,
        "to": 36
      }
    }
  },
  {
    "name": "lcm",
    "text": "\n\n/**\n * The *least common multiple* of two values\n *\n * @since 2.0.0\n */\nexport function lcm<A>(E: Eq<A>, F: Field<A>): (x: A, y: A) => A {\n  const zero = F.zero\n  const gcdSF = gcd(E, F)\n  return (x, y) => (E.equals(x, zero) || E.equals(y, zero) ? zero : F.div(F.mul(x, y), gcdSF(x, y)))\n}",
    "docs": "/**\n * The *least common multiple* of two values\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Field\").Field<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Field.ts",
      "lines": {
        "from": 43,
        "to": 47
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `filter` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function filter<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): <A>(predicate: Predicate<A>) => <FE>(fga: Kind2<F, FE, Kind2<G, E, A>>) => Kind2<F, FE, Kind2<G, E, A>>",
    "docs": "/**\n * `filter` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => <FE>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 288,
        "to": 291
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): <A>(predicate: Predicate<A>) => (fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 292,
        "to": 295
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): <A>(predicate: Predicate<A>) => (fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 296,
        "to": 299
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A>(predicate: Predicate<A>) => (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 300,
        "to": 303
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A>(predicate: Predicate<A>) => (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, A>> {\n  return (predicate) => (fga) => F.map(fga, (ga) => G.filter(ga, predicate))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 304,
        "to": 309
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\n\n/**\n * `filterMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function filterMap<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): <A, B>(f: (a: A) => Option<B>) => <FE>(fga: Kind2<F, FE, Kind2<G, E, A>>) => Kind2<F, FE, Kind2<G, E, B>>",
    "docs": "/**\n * `filterMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <FE>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 317,
        "to": 320
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\nexport function filterMap<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): <A, B>(f: (a: A) => Option<B>) => (fga: Kind<F, Kind2<G, E, A>>) => Kind<F, Kind2<G, E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 321,
        "to": 324
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\nexport function filterMap<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): <A, B>(f: (a: A) => Option<B>) => (fga: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 325,
        "to": 328
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\nexport function filterMap<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A, B>(f: (a: A) => Option<B>) => (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 329,
        "to": 332
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\nexport function filterMap<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A, B>(f: (a: A) => Option<B>) => (fga: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>> {\n  return (f) => (fga) => F.map(fga, (ga) => G.filterMap(ga, f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 333,
        "to": 338
      }
    }
  },
  {
    "name": "partition",
    "text": "\n\n/**\n * `partition` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function partition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): <A>(\n  predicate: Predicate<A>\n) => <FE>(fga: Kind2<F, FE, Kind2<G, E, A>>) => Separated<Kind2<F, FE, Kind2<G, E, A>>, Kind2<F, FE, Kind2<G, E, A>>>",
    "docs": "/**\n * `partition` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => <FE>(fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 346,
        "to": 351
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): <A>(\n  predicate: Predicate<A>\n) => (fga: Kind<F, Kind2<G, E, A>>) => Separated<Kind<F, Kind2<G, E, A>>, Kind<F, Kind2<G, E, A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 352,
        "to": 357
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): <A>(predicate: Predicate<A>) => (fga: Kind<F, Kind<G, A>>) => Separated<Kind<F, Kind<G, A>>, Kind<F, Kind<G, A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 358,
        "to": 361
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A>(predicate: Predicate<A>) => (fga: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 362,
        "to": 365
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A>(predicate: Predicate<A>) => (fga: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, A>>, HKT<F, HKT<G, A>>> {\n  const _filter = filter(F, G)\n  return (predicate) => (fga) =>\n    separated(\n      pipe(\n        fga,\n        _filter((a) => !predicate(a))\n      ),\n      pipe(fga, _filter(predicate))\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 366,
        "to": 379
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\n\n/**\n * `partitionMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function partitionMap<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <FE>(fa: Kind2<F, FE, Kind2<G, E, A>>) => Separated<Kind2<F, FE, Kind2<G, E, B>>, Kind2<F, FE, Kind2<G, E, C>>>",
    "docs": "/**\n * `partitionMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => <FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 387,
        "to": 392
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\nexport function partitionMap<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Kind<F, Kind2<G, E, A>>) => Separated<Kind<F, Kind2<G, E, B>>, Kind<F, Kind2<G, E, C>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 393,
        "to": 398
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\nexport function partitionMap<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Kind<F, Kind<G, A>>) => Separated<Kind<F, Kind<G, B>>, Kind<F, Kind<G, C>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 399,
        "to": 404
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\nexport function partitionMap<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, B>>, HKT<F, HKT<G, C>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 405,
        "to": 408
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\nexport function partitionMap<F, G>(\n  F: Functor<F>,\n  G: Filterable<G>\n): <A, B, C>(f: (a: A) => Either<B, C>) => (fa: HKT<F, HKT<G, A>>) => Separated<HKT<F, HKT<G, B>>, HKT<F, HKT<G, C>>> {\n  const _filterMap = filterMap(F, G)\n  return (f) => (fga) =>\n    separated(\n      pipe(\n        fga,\n        _filterMap((a) => getLeft(f(a)))\n      ),\n      pipe(\n        fga,\n        _filterMap((a) => getRight(f(a)))\n      )\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 409,
        "to": 425
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n\n/**\n * Use\n *\n * - [`filter`](#filter)\n * - [`filterMap`](#filtermap)\n * - [`partition`](#partition)\n * - [`partitionMap`](#partitionmap)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getFilterableComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Filterable3C<G, E>\n): FilterableComposition23C<F, G, E>",
    "docs": "/**\n * Use\n *\n * - [`filter`](#filter)\n * - [`filterMap`](#filtermap)\n * - [`partition`](#partition)\n * - [`partitionMap`](#partitionmap)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 630,
        "to": 633
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Filterable2C<G, E>\n): FilterableComposition22C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 635,
        "to": 638
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Filterable2<G>\n): FilterableComposition22<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 640,
        "to": 643
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Filterable1<G>\n): FilterableComposition2C1<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 645,
        "to": 648
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Filterable1<G>\n): FilterableComposition21<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 650,
        "to": 653
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Filterable2C<G, E>\n): FilterableComposition12C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 655,
        "to": 658
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Filterable2<G>\n): FilterableComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 660,
        "to": 663
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Filterable1<G>\n): FilterableComposition11<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 665,
        "to": 668
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F, G>(F: Functor<F>, G: Filterable<G>): FilterableComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 670,
        "to": 670
      }
    }
  },
  {
    "name": "getFilterableComposition",
    "text": "\n/** @deprecated */\nexport function getFilterableComposition<F, G>(F: Functor<F>, G: Filterable<G>): FilterableComposition<F, G> {\n  const map = getFunctorComposition(F, G).map\n  const _compact = compact(F, G)\n  const _separate = separate(F, G, G)\n  const _filter = filter(F, G)\n  const _filterMap = filterMap(F, G)\n  const _partition = partition(F, G)\n  const _partitionMap = partitionMap(F, G)\n  return {\n    map,\n    compact: _compact,\n    separate: _separate,\n    filter: (fga, f) => pipe(fga, _filter(f)),\n    filterMap: (fga, f) => pipe(fga, _filterMap(f)),\n    partition: (fga, p) => pipe(fga, _partition(p)),\n    partitionMap: (fga, f) => pipe(fga, _partitionMap(f))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").FilterableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Filterable.ts",
      "lines": {
        "from": 672,
        "to": 689
      }
    }
  },
  {
    "name": "reduce",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `reduce` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function reduce<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B",
    "docs": "/**\n * `reduce` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 103,
        "to": 106
      }
    }
  },
  {
    "name": "reduce",
    "text": "\nexport function reduce<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 107,
        "to": 110
      }
    }
  },
  {
    "name": "reduce",
    "text": "\nexport function reduce<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B {\n  return (b, f) => (fga) => F.reduce(fga, b, (b, ga) => G.reduce(ga, b, f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 111,
        "to": 116
      }
    }
  },
  {
    "name": "foldMap",
    "text": "\n\n/**\n * `foldMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function foldMap<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M",
    "docs": "/**\n * `foldMap` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 124,
        "to": 127
      }
    }
  },
  {
    "name": "foldMap",
    "text": "\nexport function foldMap<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 128,
        "to": 131
      }
    }
  },
  {
    "name": "foldMap",
    "text": "\nexport function foldMap<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M {\n  return (M) => {\n    const foldMapF = F.foldMap(M)\n    const foldMapG = G.foldMap(M)\n    return (f) => (fga) => foldMapF(fga, (ga) => foldMapG(ga, f))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 132,
        "to": 141
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "\n\n/**\n * `reduceRight` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function reduceRight<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B",
    "docs": "/**\n * `reduceRight` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 149,
        "to": 152
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "\nexport function reduceRight<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 153,
        "to": 156
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "\nexport function reduceRight<F, G>(\n  F: Foldable<F>,\n  G: Foldable<G>\n): <B, A>(b: B, f: (a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B {\n  return (b, f) => (fga) => F.reduceRight(fga, b, (ga, b) => G.reduceRight(ga, b, f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 157,
        "to": 162
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Similar to 'reduce', but the result is encapsulated in a monad.\n *\n * Note: this function is not generally stack-safe, e.g., for monads which build up thunks a la `IO`.\n *\n * @example\n * import { reduceM } from 'fp-ts/Foldable'\n * import { Monad, some } from 'fp-ts/Option'\n * import { make, Foldable } from 'fp-ts/Tree'\n * import { pipe } from 'fp-ts/function'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(pipe(t, reduceM(Monad, Foldable)(0, (b, a) => (a > 2 ? some(b + a) : some(b)))), some(7))\n *\n * @since 2.8.0\n */\nexport function reduceM<M extends URIS3, F extends URIS>(\n  M: Monad3<M>,\n  F: Foldable1<F>\n): <B, A, R, E>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>",
    "docs": "/**\n * Similar to 'reduce', but the result is encapsulated in a monad.\n *\n * Note: this function is not generally stack-safe, e.g., for monads which build up thunks a la `IO`.\n *\n * @example\n * import { reduceM } from 'fp-ts/Foldable'\n * import { Monad, some } from 'fp-ts/Option'\n * import { make, Foldable } from 'fp-ts/Tree'\n * import { pipe } from 'fp-ts/function'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(pipe(t, reduceM(Monad, Foldable)(0, (b, a) => (a > 2 ? some(b + a) : some(b)))), some(7))\n *\n * @since 2.8.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A, R, E>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 184,
        "to": 187
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M extends URIS3, F extends URIS, E>(\n  M: Monad3C<M, E>,\n  F: Foldable1<F>\n): <B, A, R>(b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => (fa: Kind<F, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A, R>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 188,
        "to": 191
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Foldable1<F>\n): <B, A, E>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A, E>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 192,
        "to": 195
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M extends URIS2, F extends URIS, E>(\n  M: Monad2C<M, E>,\n  F: Foldable1<F>\n): <B, A>(b: B, f: (b: B, a: A) => Kind2<M, E, B>) => (fa: Kind<F, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 196,
        "to": 199
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Foldable1<F>\n): <B, A>(b: B, f: (b: B, a: A) => Kind<M, B>) => (fa: Kind<F, A>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 200,
        "to": 203
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <B, A>(b: B, f: (b: B, a: A) => HKT<M, B>) => (fa: HKT<F, A>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 204,
        "to": 207
      }
    }
  },
  {
    "name": "reduceM",
    "text": "\nexport function reduceM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <B, A>(b: B, f: (b: B, a: A) => HKT<M, B>) => (fa: HKT<F, A>) => HKT<M, B> {\n  return (b, f) => (fa) => F.reduce(fa, M.of(b), (mb, a) => M.chain(mb, (b) => f(b, a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 208,
        "to": 213
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\n\n// TODO: curry in v3\n/**\n * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator\n *\n * @example\n * import { intercalate } from 'fp-ts/Foldable'\n * import * as S from 'fp-ts/string'\n * import { make, Foldable } from 'fp-ts/Tree'\n *\n * const t = make('a', [make('b', []), make('c', []), make('d', [])])\n * assert.strictEqual(intercalate(S.Monoid, Foldable)('|', t), 'a|b|c|d')\n *\n * @since 2.0.0\n */\nexport function intercalate<M, F extends URIS3>(\n  M: Monoid<M>,\n  F: Foldable3<F>\n): <R, E>(sep: M, fm: Kind3<F, R, E, M>) => M",
    "docs": "/**\n * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator\n *\n * @example\n * import { intercalate } from 'fp-ts/Foldable'\n * import * as S from 'fp-ts/string'\n * import { make, Foldable } from 'fp-ts/Tree'\n *\n * const t = make('a', [make('b', []), make('c', []), make('d', [])])\n * assert.strictEqual(intercalate(S.Monoid, Foldable)('|', t), 'a|b|c|d')\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 229,
        "to": 232
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS2>(M: Monoid<M>, F: Foldable2<F>): <E>(sep: M, fm: Kind2<F, E, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 233,
        "to": 233
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS2, E>(M: Monoid<M>, F: Foldable2C<F, E>): (sep: M, fm: Kind2<F, E, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 234,
        "to": 234
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (sep: M, fm: Kind<F, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 235,
        "to": 235
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 236,
        "to": 236
      }
    }
  },
  {
    "name": "intercalate",
    "text": "\nexport function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M {\n  interface Acc<M> {\n    readonly init: boolean\n    readonly acc: M\n  }\n  return (sep, fm) => {\n    const go = ({ init, acc }: Acc<M>, x: M): Acc<M> =>\n      init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, sep), x) }\n    return F.reduce(fm, { init: true, acc: M.empty }, go).acc\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(sep: M, fm: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, M>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 237,
        "to": 247
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\n\n/**\n * Transforms a `Foldable` into a `toReadonlyArray`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/Foldable'\n * import { Foldable, make } from 'fp-ts/Tree'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(toReadonlyArray(Foldable)(t), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport function toReadonlyArray<F extends URIS4>(\n  F: Foldable4<F>\n): <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => ReadonlyArray<A>",
    "docs": "/**\n * Transforms a `Foldable` into a `toReadonlyArray`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/Foldable'\n * import { Foldable, make } from 'fp-ts/Tree'\n *\n * const t = make(1, [make(2, []), make(3, []), make(4, [])])\n * assert.deepStrictEqual(toReadonlyArray(Foldable)(t), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 261,
        "to": 263
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F extends URIS3>(F: Foldable3<F>): <R, E, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 264,
        "to": 264
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F extends URIS3, E>(\n  F: Foldable3C<F, E>\n): <R, A>(fa: Kind3<F, R, E, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 265,
        "to": 267
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F extends URIS2>(F: Foldable2<F>): <E, A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 268,
        "to": 268
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F extends URIS2, E>(F: Foldable2C<F, E>): <A>(fa: Kind2<F, E, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 269,
        "to": 269
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F extends URIS>(F: Foldable1<F>): <A>(fa: Kind<F, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 270,
        "to": 270
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F>(F: Foldable<F>): <A>(fa: HKT<F, A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 271,
        "to": 271
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "\nexport function toReadonlyArray<F>(F: Foldable<F>): <A>(fa: HKT<F, A>) => ReadonlyArray<A> {\n  return <A>(fa: HKT<F, A>) =>\n    F.reduce(fa, [], (acc: Array<A>, a) => {\n      acc.push(a)\n      return acc\n    })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 272,
        "to": 278
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\n\n/**\n * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the\n * final result.\n *\n * @example\n * import { Foldable } from 'fp-ts/Array'\n * import { traverse_ } from 'fp-ts/Foldable'\n * import { Applicative } from 'fp-ts/IO'\n *\n * let log = ''\n * const append = (s: string) => () => (log += s)\n * traverse_(Applicative, Foldable)(['a', 'b', 'c'], append)()\n * assert.strictEqual(log, 'abc')\n *\n * @since 2.0.0\n */\nexport function traverse_<M extends URIS3, F extends URIS>(\n  M: Applicative3<M>,\n  F: Foldable1<F>\n): <R, E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, void>",
    "docs": "/**\n * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the\n * final result.\n *\n * @example\n * import { Foldable } from 'fp-ts/Array'\n * import { traverse_ } from 'fp-ts/Foldable'\n * import { Applicative } from 'fp-ts/IO'\n *\n * let log = ''\n * const append = (s: string) => () => (log += s)\n * traverse_(Applicative, Foldable)(['a', 'b', 'c'], append)()\n * assert.strictEqual(log, 'abc')\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 296,
        "to": 299
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS2, F extends URIS>(\n  M: Applicative2<M>,\n  F: Foldable1<F>\n): <E, A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 300,
        "to": 303
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS2, F extends URIS, E>(\n  M: Applicative2C<M, E>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind2<M, E, B>) => Kind2<M, E, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 304,
        "to": 307
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M extends URIS, F extends URIS>(\n  M: Applicative1<M>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, f: (a: A) => Kind<M, B>) => Kind<M, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 308,
        "to": 311
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M, F>(\n  M: Applicative<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<M, B>) => HKT<M, void>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 312,
        "to": 315
      }
    }
  },
  {
    "name": "traverse_",
    "text": "\nexport function traverse_<M, F>(\n  M: Applicative<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, f: (a: A) => HKT<M, B>) => HKT<M, void> {\n  const applyFirst = <B>(mu: HKT<M, void>, mb: HKT<M, B>): HKT<M, void> => M.ap(M.map(mu, constant), mb)\n  const mu: HKT<M, void> = M.of(undefined)\n  return (fa, f) => F.reduce(fa, mu, (mu, a) => applyFirst(mu, f(a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 316,
        "to": 323
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n// tslint:disable: deprecation\n\n/**\n * Use [`reduceM`](#reducem) instead\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function foldM<M extends URIS3, F extends URIS>(\n  M: Monad3<M>,\n  F: Foldable1<F>\n): <R, E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>",
    "docs": "/**\n * Use [`reduceM`](#reducem) instead\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 337,
        "to": 340
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n/** @deprecated */\nexport function foldM<M extends URIS3, F extends URIS, E>(\n  M: Monad3C<M, E>,\n  F: Foldable1<F>\n): <R, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind3<M, R, E, B>) => Kind3<M, R, E, B>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 342,
        "to": 345
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n/** @deprecated */\nexport function foldM<M extends URIS2, F extends URIS>(\n  M: Monad2<M>,\n  F: Foldable1<F>\n): <E, A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 347,
        "to": 350
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n/** @deprecated */\nexport function foldM<M extends URIS2, F extends URIS, E>(\n  M: Monad2C<M, E>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind2<M, E, B>) => Kind2<M, E, B>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 352,
        "to": 355
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n/** @deprecated */\nexport function foldM<M extends URIS, F extends URIS>(\n  M: Monad1<M>,\n  F: Foldable1<F>\n): <A, B>(fa: Kind<F, A>, b: B, f: (b: B, a: A) => Kind<M, B>) => Kind<M, B>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 357,
        "to": 360
      }
    }
  },
  {
    "name": "foldM",
    "text": "\n/** @deprecated */\nexport function foldM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => HKT<M, B>) => HKT<M, B>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 362,
        "to": 365
      }
    }
  },
  {
    "name": "foldM",
    "text": "\nexport function foldM<M, F>(\n  M: Monad<M>,\n  F: Foldable<F>\n): <A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => HKT<M, B>) => HKT<M, B> {\n  return (fa, b, f) => F.reduce(fa, M.of(b), (mb, a) => M.chain(mb, (b) => f(b, a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, b: B, f: (b: B, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 366,
        "to": 371
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n\n/**\n * Use\n *\n * - [reduce](#reduce)\n * - [foldMap](#foldmap)\n * - [reduceRight](#reduceright)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getFoldableComposition<F extends URIS2, G extends URIS2, E>(\n  F: Foldable2<F>,\n  G: Foldable2C<G, E>\n): FoldableComposition22C<F, G, E>",
    "docs": "/**\n * Use\n *\n * - [reduce](#reduce)\n * - [foldMap](#foldmap)\n * - [reduceRight](#reduceright)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 473,
        "to": 476
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS2, G extends URIS2>(\n  F: Foldable2<F>,\n  G: Foldable2<G>\n): FoldableComposition22<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 478,
        "to": 481
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS2, G extends URIS, E>(\n  F: Foldable2C<F, E>,\n  G: Foldable1<G>\n): FoldableComposition2C1<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 483,
        "to": 486
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS2, G extends URIS>(\n  F: Foldable2<F>,\n  G: Foldable1<G>\n): FoldableComposition21<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 488,
        "to": 491
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS, G extends URIS2, E>(\n  F: Foldable1<F>,\n  G: Foldable2C<G, E>\n): FoldableComposition12C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 493,
        "to": 496
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS, G extends URIS2>(\n  F: Foldable1<F>,\n  G: Foldable2<G>\n): FoldableComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 498,
        "to": 501
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F extends URIS, G extends URIS>(\n  F: Foldable1<F>,\n  G: Foldable1<G>\n): FoldableComposition11<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 503,
        "to": 506
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F, G>(F: Foldable<F>, G: Foldable<G>): FoldableComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 508,
        "to": 508
      }
    }
  },
  {
    "name": "getFoldableComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableComposition<F, G>(F: Foldable<F>, G: Foldable<G>): FoldableComposition<F, G> {\n  const _reduce = reduce(F, G)\n  const _foldMap = foldMap(F, G)\n  const _reduceRight = reduceRight(F, G)\n  return {\n    reduce: (fga, b, f) => pipe(fga, _reduce(b, f)),\n    foldMap: (M) => {\n      const foldMapM = _foldMap(M)\n      return (fga, f) => pipe(fga, foldMapM(f))\n    },\n    reduceRight: (fga, b, f) => pipe(fga, _reduceRight(b, f))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").FoldableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Foldable.ts",
      "lines": {
        "from": 510,
        "to": 522
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `reduceWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function reduceWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: Kind<F, Kind<G, A>>) => B",
    "docs": "/**\n * `reduceWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 119,
        "to": 122
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\nexport function reduceWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 123,
        "to": 126
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\nexport function reduceWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: HKT<F, HKT<G, A>>) => B {\n  return (b, f) => (fga) =>\n    F.reduceWithIndex(fga, b, (i, b, ga) => G.reduceWithIndex(ga, b, (j, b, a) => f([i, j], b, a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], b: B, a: A) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 127,
        "to": 133
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\n\n/**\n * `foldMapWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function foldMapWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: Kind<F, Kind<G, A>>) => M",
    "docs": "/**\n * `foldMapWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 141,
        "to": 144
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\nexport function foldMapWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 145,
        "to": 148
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\nexport function foldMapWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <M>(M: Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: HKT<F, HKT<G, A>>) => M {\n  return (M) => {\n    const foldMapWithIndexF = F.foldMapWithIndex(M)\n    const foldMapWithIndexG = G.foldMapWithIndex(M)\n    return (f) => (fga) => foldMapWithIndexF(fga, (i, ga) => foldMapWithIndexG(ga, (j, a) => f([i, j], a)))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<M>(M: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>) => <A>(f: (ij: readonly [I, J], a: A) => M) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 149,
        "to": 158
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\n\n/**\n * `reduceRightWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function reduceRightWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FoldableWithIndex1<F, I>,\n  G: FoldableWithIndex1<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: Kind<F, Kind<G, A>>) => B",
    "docs": "/**\n * `reduceRightWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 166,
        "to": 169
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\nexport function reduceRightWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 170,
        "to": 173
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\nexport function reduceRightWithIndex<F, I, G, J>(\n  F: FoldableWithIndex<F, I>,\n  G: FoldableWithIndex<G, J>\n): <B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: HKT<F, HKT<G, A>>) => B {\n  return (b, f) => (fga) =>\n    F.reduceRightWithIndex(fga, b, (i, ga, b) => G.reduceRightWithIndex(ga, b, (j, a, b) => f([i, j], a, b)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(b: B, f: (ij: readonly [I, J], a: A, b: B) => B) => (fga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 174,
        "to": 180
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n\n/**\n * Use\n *\n * - [reduceWithIndex](#reducewithindex)\n * - [foldMapWithIndex](#foldmapwithindex)\n * - [reduceRightWithIndex](#reducerightwithindex)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2C<G, GI, E>\n): FoldableWithIndexComposition22C<F, FI, G, GI, E>",
    "docs": "/**\n * Use\n *\n * - [reduceWithIndex](#reducewithindex)\n * - [foldMapWithIndex](#foldmapwithindex)\n * - [reduceRightWithIndex](#reducerightwithindex)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<G, GI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition22C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 305,
        "to": 308
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition22<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition22<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 310,
        "to": 313
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FoldableWithIndex2C<F, FI, E>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition2C1<F, FI, G, GI, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<F, FI, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition2C1<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 315,
        "to": 318
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FoldableWithIndex2<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition21<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition21<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 320,
        "to": 323
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 325,
        "to": 328
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex2<G, GI>\n): FoldableWithIndexComposition12<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 330,
        "to": 333
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FoldableWithIndex1<F, FI>,\n  G: FoldableWithIndex1<G, GI>\n): FoldableWithIndexComposition11<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition11<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 335,
        "to": 338
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F, FI, G, GI>(\n  F: FoldableWithIndex<F, FI>,\n  G: FoldableWithIndex<G, GI>\n): FoldableWithIndexComposition<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 340,
        "to": 343
      }
    }
  },
  {
    "name": "getFoldableWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFoldableWithIndexComposition<F, FI, G, GI>(\n  F: FoldableWithIndex<F, FI>,\n  G: FoldableWithIndex<G, GI>\n): FoldableWithIndexComposition<F, FI, G, GI> {\n  const FC = getFoldableComposition(F, G)\n  const _reduceWithIndex = reduceWithIndex(F, G)\n  const _foldMapWithIndex = foldMapWithIndex(F, G)\n  const _reduceRightWithIndex = reduceRightWithIndex(F, G)\n  return {\n    reduce: FC.reduce,\n    foldMap: FC.foldMap,\n    reduceRight: FC.reduceRight,\n    reduceWithIndex: (fga, b, f: any) => pipe(fga, _reduceWithIndex(b, f)),\n    foldMapWithIndex: (M) => {\n      const foldMapWithIndexM = _foldMapWithIndex(M)\n      return (fga, f: any) => pipe(fga, foldMapWithIndexM(f))\n    },\n    reduceRightWithIndex: (fga, b, f: any) => pipe(fga, _reduceRightWithIndex(b, f))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FoldableWithIndex.ts",
      "lines": {
        "from": 345,
        "to": 364
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function fromOption<F extends URIS4>(\n  F: FromEither4<F>\n): <E>(onNone: Lazy<E>) => <A, S, R>(ma: Option<A>) => Kind4<F, S, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F extends URIS3>(\n  F: FromEither3<F>\n): <E>(onNone: Lazy<E>) => <A, R>(ma: Option<A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): (onNone: Lazy<E>) => <A, R>(ma: Option<A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 88,
        "to": 90
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F extends URIS2>(\n  F: FromEither2<F>\n): <E>(onNone: Lazy<E>) => <A>(ma: Option<A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 91,
        "to": 93
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): (onNone: Lazy<E>) => <A>(ma: Option<A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 94,
        "to": 96
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F>(F: FromEither<F>): <E>(onNone: Lazy<E>) => <A>(ma: Option<A>) => HKT2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 97,
        "to": 97
      }
    }
  },
  {
    "name": "fromOption",
    "text": "\nexport function fromOption<F>(F: FromEither<F>): <E>(onNone: Lazy<E>) => <A>(ma: Option<A>) => HKT2<F, E, A> {\n  return (onNone) => flow(E.fromOption(onNone), F.fromEither)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromPredicate<F extends URIS4>(\n  F: FromEither4<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => Kind4<F, S, R, E, A>\n}",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <S, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <S, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 105,
        "to": 110
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS3>(\n  F: FromEither3<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 111,
        "to": 116
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => Kind3<F, R, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 117,
        "to": 122
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS2>(\n  F: FromEither2<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 123,
        "to": 128
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => Kind2<F, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 129,
        "to": 134
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F>(\n  F: FromEither<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 135,
        "to": 140
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F>(\n  F: FromEither<F>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (a: A) => HKT2<F, E, A>\n} {\n  return <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E) =>\n    flow(E.fromPredicate(predicate, onFalse), F.fromEither)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 141,
        "to": 149
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function fromOptionK<F extends URIS4>(\n  F: FromEither4<F>\n): <E>(\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 158,
        "to": 162
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS3>(\n  F: FromEither3<F>\n): <E>(\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 163,
        "to": 167
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): (\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 168,
        "to": 172
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS2>(\n  F: FromEither2<F>\n): <E>(\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 173,
        "to": 177
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): (onNone: Lazy<E>) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 178,
        "to": 180
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F>(\n  F: FromEither<F>\n): <E>(\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => HKT2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 181,
        "to": 185
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F>(\n  F: FromEither<F>\n): <E>(\n  onNone: Lazy<E>\n) => <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => HKT2<F, E, B> {\n  const fromOptionF = fromOption(F)\n  return (onNone) => {\n    const from = fromOptionF(onNone)\n    return (f) => flow(f, from)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 186,
        "to": 196
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chainOptionK<F extends URIS4>(\n  F: FromEither4<F>,\n  M: Chain4<F>\n): <E>(onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => <S, R>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<F>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 201,
        "to": 204
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F extends URIS3>(\n  F: FromEither3<F>,\n  M: Chain3<F>\n): <E>(onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<F>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 205,
        "to": 208
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F extends URIS3, E>(\n  F: FromEither3C<F, E>,\n  M: Chain3C<F, E>\n): (onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => <R>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<F, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 209,
        "to": 212
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F extends URIS2>(\n  F: FromEither2<F>,\n  M: Chain2<F>\n): <E>(onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 213,
        "to": 216
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F extends URIS2, E>(\n  F: FromEither2C<F, E>,\n  M: Chain2C<F, E>\n): (onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<F, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 217,
        "to": 220
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F>(\n  F: FromEither<F>,\n  M: Chain<F>\n): <E>(onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: HKT2<F, E, A>) => HKT2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 221,
        "to": 224
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<F extends URIS2>(\n  F: FromEither2<F>,\n  M: Chain2<F>\n): <E>(onNone: Lazy<E>) => <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<F, E, A>) => Kind2<F, E, B> {\n  const fromOptionKF = fromOptionK(F)\n  return (onNone) => {\n    const from = fromOptionKF(onNone)\n    return (f) => (ma) => M.chain(ma, from(f))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 225,
        "to": 234
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromEitherK<F extends URIS4>(\n  F: FromEither4<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => <S, R>(...a: A) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], E, B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 239,
        "to": 241
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F extends URIS3>(\n  F: FromEither3<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], E, B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 242,
        "to": 244
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F extends URIS3, E>(\n  F: FromEither3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 245,
        "to": 247
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F extends URIS2>(\n  F: FromEither2<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], E, B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 248,
        "to": 250
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F extends URIS2, E>(\n  F: FromEither2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Either<E, B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 251,
        "to": 253
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F>(\n  F: FromEither<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => (...a: A) => HKT2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], E, B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 254,
        "to": 256
      }
    }
  },
  {
    "name": "fromEitherK",
    "text": "\nexport function fromEitherK<F>(\n  F: FromEither<F>\n): <A extends ReadonlyArray<unknown>, E, B>(f: (...a: A) => Either<E, B>) => (...a: A) => HKT2<F, E, B> {\n  return (f) => flow(f, F.fromEither)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], E, B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 257,
        "to": 261
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chainEitherK<M extends URIS4>(\n  F: FromEither4<M>,\n  M: Chain4<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 266,
        "to": 269
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M extends URIS3>(\n  F: FromEither3<M>,\n  M: Chain3<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 270,
        "to": 273
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M extends URIS3, E>(\n  F: FromEither3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 274,
        "to": 277
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 278,
        "to": 281
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M extends URIS2, E>(\n  F: FromEither2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 282,
        "to": 285
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M>(\n  F: FromEither<M>,\n  M: Chain<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 286,
        "to": 289
      }
    }
  },
  {
    "name": "chainEitherK",
    "text": "\nexport function chainEitherK<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, B> {\n  const fromEitherKF = fromEitherK(F)\n  return (f) => (ma) => M.chain(ma, fromEitherKF(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 290,
        "to": 296
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function filterOrElse<M extends URIS4>(\n  F: FromEither4<M>,\n  M: Chain4<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <S, R>(\n    ma: Kind4<M, S, R, E, A>\n  ) => Kind4<M, S, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>\n}",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 301,
        "to": 309
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS3>(\n  F: FromEither3<M>,\n  M: Chain3<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(\n    ma: Kind3<M, R, E, A>\n  ) => Kind3<M, R, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 310,
        "to": 318
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS3, E>(\n  F: FromEither3C<M, E>,\n  M: Chain3C<M, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 319,
        "to": 325
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 326,
        "to": 332
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS2, E>(\n  F: FromEither2C<M, E>,\n  M: Chain2C<M, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, B>\n  <A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 333,
        "to": 339
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS2>(\n  F: FromEither<M>,\n  M: Chain<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: HKT2<M, E, A>) => HKT2<M, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: HKT2<M, E, A>) => HKT2<M, E, A>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<M, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 340,
        "to": 346
      }
    }
  },
  {
    "name": "filterOrElse",
    "text": "\nexport function filterOrElse<M extends URIS2>(\n  F: FromEither2<M>,\n  M: Chain2<M>\n): {\n  <A, B extends A, E>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, B>\n  <A, E>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Kind2<M, E, A>) => Kind2<M, E, A>\n} {\n  return <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E) => (ma: Kind2<M, E, A>): Kind2<M, E, A> =>\n    M.chain(ma, flow(E.fromPredicate(predicate, onFalse), F.fromEither))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromEither\").FromEither2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A, E>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>; <A, E>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>, onFalse: (a: A) => E): (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromEither.ts",
      "lines": {
        "from": 347,
        "to": 356
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function fromIOK<F extends URIS4>(\n  F: FromIO4<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <S, R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 88,
        "to": 90
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F extends URIS3>(\n  F: FromIO3<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 91,
        "to": 93
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F extends URIS3, E>(\n  F: FromIO3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 94,
        "to": 96
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F extends URIS2>(\n  F: FromIO2<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => <E>(...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 97,
        "to": 99
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F extends URIS2, E>(\n  F: FromIO2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 100,
        "to": 102
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F extends URIS>(\n  F: FromIO1<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 103,
        "to": 105
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F>(\n  F: FromIO<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "fromIOK",
    "text": "\nexport function fromIOK<F>(\n  F: FromIO<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => IO<B>) => (...a: A) => HKT<F, B> {\n  return (f) => flow(f, F.fromIO)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 109,
        "to": 113
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function chainIOK<M extends URIS4>(\n  F: FromIO4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <S, R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 119,
        "to": 122
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M extends URIS3>(\n  F: FromIO3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 123,
        "to": 126
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M extends URIS3, E>(\n  F: FromIO3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 127,
        "to": 130
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M extends URIS2>(\n  F: FromIO2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 131,
        "to": 134
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M extends URIS2, E>(\n  F: FromIO2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M extends URIS>(\n  F: FromIO1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO1<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 139,
        "to": 142
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M>(F: FromIO<M>, M: Chain<M>): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 143,
        "to": 143
      }
    }
  },
  {
    "name": "chainIOK",
    "text": "\nexport function chainIOK<M>(F: FromIO<M>, M: Chain<M>): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, B> {\n  return (f) => {\n    const g = flow(f, F.fromIO)\n    return (first) => M.chain(first, g)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 144,
        "to": 149
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function chainFirstIOK<M extends URIS4>(\n  F: FromIO4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => IO<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <S, R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 155,
        "to": 158
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M extends URIS3>(\n  F: FromIO3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 159,
        "to": 162
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M extends URIS3, E>(\n  F: FromIO3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 163,
        "to": 166
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M extends URIS2>(\n  F: FromIO2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 167,
        "to": 170
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M extends URIS2, E>(\n  F: FromIO2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => IO<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 171,
        "to": 174
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M extends URIS>(\n  F: FromIO1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: Kind<M, A>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO1<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 175,
        "to": 178
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M>(\n  F: FromIO<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 179,
        "to": 182
      }
    }
  },
  {
    "name": "chainFirstIOK",
    "text": "\nexport function chainFirstIOK<M>(\n  F: FromIO<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => IO<B>) => (first: HKT<M, A>) => HKT<M, A> {\n  const chainFirstM = chainFirst(M)\n  return (f) => chainFirstM(flow(f, F.fromIO))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromIO\").FromIO<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromIO.ts",
      "lines": {
        "from": 183,
        "to": 189
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function fromTaskK<F extends URIS4>(\n  F: FromTask4<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <S, R, E>(...a: A) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <S, R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F extends URIS3>(\n  F: FromTask3<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R, E>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 83,
        "to": 85
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F extends URIS3, E>(\n  F: FromTask3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <R>(...a: A) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F extends URIS2>(\n  F: FromTask2<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => <E>(...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F extends URIS2, E>(\n  F: FromTask2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F extends URIS>(\n  F: FromTask1<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F>(\n  F: FromTask<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "fromTaskK",
    "text": "\nexport function fromTaskK<F>(\n  F: FromTask<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Task<B>) => (...a: A) => HKT<F, B> {\n  return (f) => flow(f, F.fromTask)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 101,
        "to": 105
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function chainTaskK<M extends URIS4>(\n  F: FromTask4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <S, R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 111,
        "to": 114
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M extends URIS3>(\n  F: FromTask3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 115,
        "to": 118
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M extends URIS3, E>(\n  F: FromTask3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 119,
        "to": 122
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M extends URIS2>(\n  F: FromTask2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 123,
        "to": 126
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M extends URIS2, E>(\n  F: FromTask2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 127,
        "to": 130
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M extends URIS>(\n  F: FromTask1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask1<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 131,
        "to": 134
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "chainTaskK",
    "text": "\nexport function chainTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, B> {\n  return (f) => {\n    const g = flow(f, F.fromTask)\n    return (first) => M.chain(first, g)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 139,
        "to": 147
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function chainFirstTaskK<M extends URIS4>(\n  F: FromTask4<M>,\n  M: Chain4<M>\n): <A, B>(f: (a: A) => Task<B>) => <S, R, E>(first: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask4<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <S, R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 153,
        "to": 156
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M extends URIS3>(\n  F: FromTask3<M>,\n  M: Chain3<M>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 157,
        "to": 160
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M extends URIS3, E>(\n  F: FromTask3C<M, E>,\n  M: Chain3C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <R, E>(first: Kind3<M, R, E, A>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask3C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <R, E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 161,
        "to": 164
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M extends URIS2>(\n  F: FromTask2<M>,\n  M: Chain2<M>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 165,
        "to": 168
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M extends URIS2, E>(\n  F: FromTask2C<M, E>,\n  M: Chain2C<M, E>\n): <A, B>(f: (a: A) => Task<B>) => <E>(first: Kind2<M, E, A>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask2C<M, E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => <E>(first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 169,
        "to": 172
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M extends URIS>(\n  F: FromTask1<M>,\n  M: Chain1<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: Kind<M, A>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask1<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 173,
        "to": 176
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 177,
        "to": 180
      }
    }
  },
  {
    "name": "chainFirstTaskK",
    "text": "\nexport function chainFirstTaskK<M>(\n  F: FromTask<M>,\n  M: Chain<M>\n): <A, B>(f: (a: A) => Task<B>) => (first: HKT<M, A>) => HKT<M, A> {\n  const chainFirstM = chainFirst(M)\n  return (f) => chainFirstM(flow(f, F.fromTask))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FromTask\").FromTask<M>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FromTask.ts",
      "lines": {
        "from": 181,
        "to": 187
      }
    }
  },
  {
    "name": "identity",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function identity<A>(a: A): A {\n  return a\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 171,
        "to": 173
      }
    }
  },
  {
    "name": "not",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function not<A>(predicate: Predicate<A>): Predicate<A> {\n  return (a) => !predicate(a)\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 183,
        "to": 185
      }
    }
  },
  {
    "name": "constant",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function constant<A>(a: A): Lazy<A> {\n  return () => a\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 190,
        "to": 192
      }
    }
  },
  {
    "name": "flip",
    "text": "\n\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nexport function flip<A, B, C>(f: (a: A, b: B) => C): (b: B, a: A) => C {\n  return (b, a) => f(a, b)\n}",
    "docs": "/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(b: B, a: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 242,
        "to": 244
      }
    }
  },
  {
    "name": "flow",
    "text": "\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from 'fp-ts/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>, B>(ab: (...a: A) => B): (...a: A) => B",
    "docs": "/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from 'fp-ts/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 263,
        "to": 263
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 264,
        "to": 264
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): (...a: A) => D",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 265,
        "to": 269
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 270,
        "to": 275
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => F"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 276,
        "to": 282
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => G"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 283,
        "to": 290
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => H"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 291,
        "to": 299
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => I"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 300,
        "to": 309
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => J"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 310,
        "to": 320
      }
    }
  },
  {
    "name": "flow",
    "text": "\nexport function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return ab\n    case 2:\n      return function (this: unknown) {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n      return function (this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n      }\n    case 4:\n      return function (this: unknown) {\n        return de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return function (this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n      }\n    case 6:\n      return function (this: unknown) {\n        return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n      return function (this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n      }\n    case 8:\n      return function (this: unknown) {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n      }\n    case 9:\n      return function (this: unknown) {\n        return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n  }\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Unknown"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 321,
        "to": 369
      }
    }
  },
  {
    "name": "tuple",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function tuple<T extends ReadonlyArray<any>>(...t: T): T {\n  return t\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "t",
          "type": {
            "__tag": "Other",
            "values": "T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "T"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 374,
        "to": 376
      }
    }
  },
  {
    "name": "increment",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function increment(n: number): number {\n  return n + 1\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 381,
        "to": 383
      }
    }
  },
  {
    "name": "decrement",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function decrement(n: number): number {\n  return n - 1\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 388,
        "to": 390
      }
    }
  },
  {
    "name": "absurd",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function absurd<A>(_: never): A {\n  throw new Error('Called `absurd` function which should be uncallable')\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "_",
          "type": {
            "__tag": "Never"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 395,
        "to": 397
      }
    }
  },
  {
    "name": "tupled",
    "text": "\n\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B {\n  return (a) => f(...a)\n}",
    "docs": "/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 411,
        "to": 413
      }
    }
  },
  {
    "name": "untupled",
    "text": "\n\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled<A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B {\n  return (...a) => f(a)\n}",
    "docs": "/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 420,
        "to": 422
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * See also [`flow`](#flow).\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * // without pipe\n * assert.strictEqual(double(len('aaa')), 6)\n *\n * // with pipe\n * assert.strictEqual(pipe('aaa', len, double), 6)\n *\n * @since 2.6.3\n */\nexport function pipe<A>(a: A): A",
    "docs": "/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * See also [`flow`](#flow).\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * // without pipe\n * assert.strictEqual(double(len('aaa')), 6)\n *\n * // with pipe\n * assert.strictEqual(pipe('aaa', len, double), 6)\n *\n * @since 2.6.3\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 443,
        "to": 443
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B>(a: A, ab: (a: A) => B): B",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 444,
        "to": 444
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 445,
        "to": 445
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 446,
        "to": 446
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 447,
        "to": 447
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): F",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "F"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 448,
        "to": 455
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): G",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "G"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 456,
        "to": 464
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "H"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 465,
        "to": 474
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "I"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 475,
        "to": 485
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): J",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "J"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 486,
        "to": 497
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K\n): K",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "K"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 498,
        "to": 510
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L\n): L",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "L"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 511,
        "to": 524
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M\n): M",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 525,
        "to": 539
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N\n): N",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "N"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 540,
        "to": 555
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O\n): O",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "O"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 556,
        "to": 572
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P\n): P",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "(o: O) => P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "P"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 574,
        "to": 591
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q\n): Q",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "(o: O) => P"
          }
        },
        {
          "name": "pq",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => Q"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Q"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 593,
        "to": 611
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R\n): R",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "(o: O) => P"
          }
        },
        {
          "name": "pq",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => Q"
          }
        },
        {
          "name": "qr",
          "type": {
            "__tag": "Other",
            "values": "(q: Q) => R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "R"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 613,
        "to": 632
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S\n): S",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "(o: O) => P"
          }
        },
        {
          "name": "pq",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => Q"
          }
        },
        {
          "name": "qr",
          "type": {
            "__tag": "Other",
            "values": "(q: Q) => R"
          }
        },
        {
          "name": "rs",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 634,
        "to": 654
      }
    }
  },
  {
    "name": "pipe",
    "text": "\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S,\n  st: (s: S) => T\n): T",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => C"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "(c: C) => D"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => F"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "(f: F) => G"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "(g: G) => H"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "(h: H) => I"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "(i: I) => J"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "(j: J) => K"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "(k: K) => L"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "(l: L) => M"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "(m: M) => N"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "(n: N) => O"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "(o: O) => P"
          }
        },
        {
          "name": "pq",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => Q"
          }
        },
        {
          "name": "qr",
          "type": {
            "__tag": "Other",
            "values": "(q: Q) => R"
          }
        },
        {
          "name": "rs",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => S"
          }
        },
        {
          "name": "st",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => T"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "T"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 656,
        "to": 677
      }
    }
  },
  {
    "name": "pipe",
    "text": "\nexport function pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function,\n  jk?: Function,\n  kl?: Function,\n  lm?: Function,\n  mn?: Function,\n  no?: Function,\n  op?: Function,\n  pq?: Function,\n  qr?: Function,\n  rs?: Function,\n  st?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    case 10:\n      return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))\n    case 11:\n      return jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))))\n    case 12:\n      return kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))))\n    case 13:\n      return lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))))))\n    case 14:\n      return mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))))))\n    case 15:\n      return no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))))))))\n    case 16:\n      return op!(no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))))))))\n    case 17:\n      return pq!(op!(no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))))))))))\n    case 18:\n      return qr!(pq!(op!(no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))))))))))\n    case 19:\n      return rs!(qr!(pq!(op!(no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))))))))))))\n    case 20:\n      return st!(rs!(qr!(pq!(op!(no!(mn!(lm!(kl!(jk!(ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))))))))))))))\n  }\n  return\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "bc",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "cd",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "de",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ef",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "fg",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "gh",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "hi",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "ij",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "jk",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "kl",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "lm",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "mn",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "no",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "op",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "pq",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "qr",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "rs",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        },
        {
          "name": "st",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Unknown"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 678,
        "to": 743
      }
    }
  },
  {
    "name": "getBooleanAlgebra",
    "text": "const getBooleanAlgebra = <B>(B: BooleanAlgebra<B>) => <A = never>(): BooleanAlgebra<(a: A) => B> => ({\n  meet: (x, y) => (a) => B.meet(x(a), y(a)),\n  join: (x, y) => (a) => B.join(x(a), y(a)),\n  zero: () => B.zero,\n  one: () => B.one,\n  implies: (x, y) => (a) => B.implies(x(a), y(a)),\n  not: (x) => (a) => B.not(x(a))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/BooleanAlgebra\").BooleanAlgebra<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 18,
        "to": 25
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <S>(S: Semigroup<S>) => <A = never>(): Semigroup<(a: A) => S> => ({\n  concat: (f, g) => (a) => S.concat(f(a), g(a))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<(a: A) => S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <M>(M: Monoid<M>): (<A = never>() => Monoid<(a: A) => M>) => {\n  const getSemigroupM = getSemigroup(M)\n  return <A>() => ({\n    concat: getSemigroupM<A>().concat,\n    empty: () => M.empty\n  })\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A = never>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<(a: A) => M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 77,
        "to": 83
      }
    }
  },
  {
    "name": "getSemiring",
    "text": "const getSemiring = <A, B>(S: Semiring<B>): Semiring<(a: A) => B> => ({\n  add: (f, g) => (x) => S.add(f(x), g(x)),\n  zero: () => S.zero,\n  mul: (f, g) => (x) => S.mul(f(x), g(x)),\n  one: () => S.one\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semiring\").Semiring<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semiring\").Semiring<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 89,
        "to": 94
      }
    }
  },
  {
    "name": "getRing",
    "text": "const getRing = <A, B>(R: Ring<B>): Ring<(a: A) => B> => {\n  const S = getSemiring<A, B>(R)\n  return {\n    add: S.add,\n    mul: S.mul,\n    one: S.one,\n    zero: S.zero,\n    sub: (f, g) => (x) => R.sub(f(x), g(x))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "R",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<(a: A) => B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 100,
        "to": 109
      }
    }
  },
  {
    "name": "getEndomorphismMonoid",
    "text": "const getEndomorphismMonoid = <A = never>(): Monoid<Endomorphism<A>> => ({\n  concat: (x, y) => (a) => y(x(a)),\n  empty: identity\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/function.ts",
      "lines": {
        "from": 117,
        "to": 120
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `map` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function map<F, G extends URIS2>(\n  F: Functor<F>,\n  G: Functor2<G>\n): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, Kind2<G, E, A>>) => HKT<F, Kind2<G, E, B>>",
    "docs": "/**\n * `map` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<G, E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 96,
        "to": 99
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F, G extends URIS>(\n  F: Functor<F>,\n  G: Functor1<G>\n): <A, B>(f: (a: A) => B) => (fa: HKT<F, Kind<G, A>>) => HKT<F, Kind<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 100,
        "to": 103
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F, G>(\n  F: Functor<F>,\n  G: Functor<G>\n): <A, B>(f: (a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 104,
        "to": 107
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F, G>(\n  F: Functor<F>,\n  G: Functor<G>\n): <A, B>(f: (a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>> {\n  return (f) => (fa) => F.map(fa, (ga) => G.map(ga, f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 108,
        "to": 113
      }
    }
  },
  {
    "name": "flap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.10.0\n */\nexport function flap<F extends URIS4>(\n  F: Functor4<F>\n): <A>(a: A) => <S, R, E, B>(fab: Kind4<F, S, R, E, (a: A) => B>) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <S, R, E, B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 119,
        "to": 121
      }
    }
  },
  {
    "name": "flap",
    "text": "\nexport function flap<F extends URIS3>(\n  F: Functor3<F>\n): <A>(a: A) => <R, E, B>(fab: Kind3<F, R, E, (a: A) => B>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <R, E, B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "flap",
    "text": "\nexport function flap<F extends URIS2>(\n  F: Functor2<F>\n): <A>(a: A) => <E, B>(fab: Kind2<F, E, (a: A) => B>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <E, B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 125,
        "to": 127
      }
    }
  },
  {
    "name": "flap",
    "text": "\nexport function flap<F extends URIS>(F: Functor1<F>): <A>(a: A) => <B>(fab: Kind<F, (a: A) => B>) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 128,
        "to": 128
      }
    }
  },
  {
    "name": "flap",
    "text": "\nexport function flap<F>(F: Functor<F>): <A>(a: A) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 129,
        "to": 129
      }
    }
  },
  {
    "name": "flap",
    "text": "\nexport function flap<F>(F: Functor<F>): <A>(a: A) => <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B> {\n  return (a) => (fab) => F.map(fab, (f) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 130,
        "to": 132
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function bindTo<F extends URIS4>(\n  F: Functor4<F>\n): <N extends string>(name: N) => <S, R, E, A>(fa: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, { readonly [K in N]: A }>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <S, R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 141,
        "to": 143
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F extends URIS3>(\n  F: Functor3<F>\n): <N extends string>(name: N) => <R, E, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 144,
        "to": 146
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <N extends string>(name: N) => <R, A>(fa: Kind3<F, R, E, A>) => Kind3<F, R, E, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 147,
        "to": 149
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F extends URIS2>(\n  F: Functor2<F>\n): <N extends string>(name: N) => <E, A>(fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 150,
        "to": 152
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <N extends string>(name: N) => <A>(fa: Kind2<F, E, A>) => Kind2<F, E, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 153,
        "to": 155
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F extends URIS>(\n  F: Functor1<F>\n): <N extends string>(name: N) => <A>(fa: Kind<F, A>) => Kind<F, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 156,
        "to": 158
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F>(\n  F: Functor<F>\n): <N extends string>(name: N) => <A>(fa: HKT<F, A>) => HKT<F, { readonly [K in N]: A }>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 159,
        "to": 161
      }
    }
  },
  {
    "name": "bindTo",
    "text": "\nexport function bindTo<F>(\n  F: Functor<F>\n): <N extends string>(name: N) => <A>(fa: HKT<F, A>) => HKT<F, { readonly [K in N]: A }> {\n  return (name) => (fa) => F.map(fa, (a) => ({ [name]: a } as any))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<N extends string>(name: N) => <A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, { readonly [K in N]: A; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 162,
        "to": 166
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n\n/**\n * Use [`map`](#map) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getFunctorComposition<F extends URIS2, G extends URIS3, E>(\n  F: Functor2<F>,\n  G: Functor3C<G, E>\n): FunctorComposition23C<F, G, E>",
    "docs": "/**\n * Use [`map`](#map) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition23C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 284,
        "to": 287
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2, G extends URIS2, E>(\n  F: Functor2<F>,\n  G: Functor2C<G, E>\n): FunctorComposition22C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition22C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 289,
        "to": 292
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2, G extends URIS2>(\n  F: Functor2<F>,\n  G: Functor2<G>\n): FunctorComposition22<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition22<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 294,
        "to": 297
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2, G extends URIS, E>(\n  F: Functor2C<F, E>,\n  G: Functor1<G>\n): FunctorComposition2C1<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition2C1<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 299,
        "to": 302
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS2, G extends URIS>(\n  F: Functor2<F>,\n  G: Functor1<G>\n): FunctorComposition21<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition21<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 304,
        "to": 307
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS, G extends URIS2, E>(\n  F: Functor1<F>,\n  G: Functor2C<G, E>\n): FunctorComposition12C<F, G, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<G, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition12C<F, G, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 309,
        "to": 312
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS, G extends URIS2>(\n  F: Functor1<F>,\n  G: Functor2<G>\n): FunctorComposition12<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition12<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 314,
        "to": 317
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F extends URIS, G extends URIS>(\n  F: Functor1<F>,\n  G: Functor1<G>\n): FunctorComposition11<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 319,
        "to": 322
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 324,
        "to": 324
      }
    }
  },
  {
    "name": "getFunctorComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorComposition<F, G>(F: Functor<F>, G: Functor<G>): FunctorComposition<F, G> {\n  const _map = map(F, G)\n  return {\n    map: (fga, f) => pipe(fga, _map(f))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").FunctorComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Functor.ts",
      "lines": {
        "from": 326,
        "to": 331
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `mapWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function mapWithIndex<F extends URIS, I, G extends URIS, J>(\n  F: FunctorWithIndex1<F, I>,\n  G: FunctorWithIndex1<G, J>\n): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: Kind<F, Kind<G, A>>) => Kind<F, Kind<G, B>>",
    "docs": "/**\n * `mapWithIndex` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 105,
        "to": 108
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\nexport function mapWithIndex<F, I, G, J>(\n  F: FunctorWithIndex<F, I>,\n  G: FunctorWithIndex<G, J>\n): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 109,
        "to": 112
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\nexport function mapWithIndex<F, I, G, J>(\n  F: FunctorWithIndex<F, I>,\n  G: FunctorWithIndex<G, J>\n): <A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: HKT<F, HKT<G, A>>) => HKT<F, HKT<G, B>> {\n  return (f) => (fa) => F.mapWithIndex(fa, (i, ga) => G.mapWithIndex(ga, (j, a) => f([i, j], a)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, I>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, J>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (ij: readonly [I, J], a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 113,
        "to": 118
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n\n/**\n * Use [`mapWithIndex`](#mapwithindex) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2C<G, FI, E>\n): FunctorWithIndexComposition22C<F, FI, G, GI, E>",
    "docs": "/**\n * Use [`mapWithIndex`](#mapwithindex) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<G, FI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition22C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 209,
        "to": 212
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex2<G, FI>\n): FunctorWithIndexComposition22<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<G, FI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition22<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 214,
        "to": 217
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI, E>(\n  F: FunctorWithIndex2C<F, FI, E>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition2C1<F, FI, G, GI, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<F, FI, E>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition2C1<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 219,
        "to": 222
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS2, FI, G extends URIS, GI>(\n  F: FunctorWithIndex2<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition21<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition21<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 224,
        "to": 227
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI, E>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2C<G, GI, E>\n): FunctorWithIndexComposition12C<F, FI, G, GI, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<G, GI, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition12C<F, FI, G, GI, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 229,
        "to": 232
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS2, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex2<G, GI>\n): FunctorWithIndexComposition12<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition12<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 234,
        "to": 237
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F extends URIS, FI, G extends URIS, GI>(\n  F: FunctorWithIndex1<F, FI>,\n  G: FunctorWithIndex1<G, GI>\n): FunctorWithIndexComposition11<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition11<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 239,
        "to": 242
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F, FI, G, GI>(\n  F: FunctorWithIndex<F, FI>,\n  G: FunctorWithIndex<G, GI>\n): FunctorWithIndexComposition<F, FI, G, GI>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 244,
        "to": 247
      }
    }
  },
  {
    "name": "getFunctorWithIndexComposition",
    "text": "\n/** @deprecated */\nexport function getFunctorWithIndexComposition<F, FI, G, GI>(\n  F: FunctorWithIndex<F, FI>,\n  G: FunctorWithIndex<G, GI>\n): FunctorWithIndexComposition<F, FI, G, GI> {\n  const map = getFunctorComposition(F, G).map\n  const _mapWithIndex = mapWithIndex(F, G)\n  return {\n    map,\n    mapWithIndex: (fga, f: any) => pipe(fga, _mapWithIndex(f))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, FI>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<G, GI>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndexComposition<F, FI, G, GI>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/FunctorWithIndex.ts",
      "lines": {
        "from": 249,
        "to": 259
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Identity<A>) => Identity<B> = (f) => (fa) => f(fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 69,
        "to": 69
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Identity<A>) => <B>(fab: Identity<(a: A) => B>) => Identity<B> = (fa) => (fab) => fab(fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: (a: A) => B) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 77,
        "to": 77
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Identity<B>) => (ma: Identity<A>) => Identity<B> = (f) => (ma) => f(ma)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 91,
        "to": 91
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Identity<A>) => B) => (wa: Identity<A>) => Identity<B> = (f) => (wa) => f(wa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 97,
        "to": 97
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Identity<A>) => B = (b, f) => (fa) => f(b, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 129,
        "to": 129
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Identity<A>) => M = () => (f) => (fa) => f(fa)",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: A) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 135,
        "to": 135
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Identity<A>) => B = (b, f) => (fa) => f(fa, b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: A) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 141,
        "to": 141
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Identity<A>) => HKT<F, Identity<B>>) => (f) => (ta) => F.map(f(ta), id)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 146,
        "to": 148
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: ApplicativeHKT<F>) => <A>(\n  ta: Identity<HKT<F, A>>\n): HKT<F, Identity<A>> => {\n  return F.map(ta, id)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 153,
        "to": 157
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW: <B>(that: () => Identity<B>) => <A>(fa: Identity<A>) => Identity<A | B> = () => id",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "typeof import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").identity"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Identity.ts",
      "lines": {
        "from": 165,
        "to": 165
      }
    }
  },
  {
    "name": "isSome",
    "text": "const isSome = <A>(fa: Option<A>): fa is Some<A> => fa._tag === 'Some'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/internal.ts",
      "lines": {
        "from": 14,
        "to": 14
      }
    }
  },
  {
    "name": "isLeft",
    "text": "const isLeft = <E, A>(ma: Either<E, A>): ma is Left<E> => ma._tag === 'Left'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/internal.ts",
      "lines": {
        "from": 21,
        "to": 21
      }
    }
  },
  {
    "name": "fromReadonlyNonEmptyArray",
    "text": "const fromReadonlyNonEmptyArray = <A>(as: ReadonlyNonEmptyArray<A>): NonEmptyArray<A> => [as[0], ...as.slice(1)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/internal.ts",
      "lines": {
        "from": 35,
        "to": 35
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: IO<A>) => IO<B> = (f) => (fa) => _map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 65,
        "to": 65
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: IO<A>) => <B>(fab: IO<(a: A) => B>) => IO<B> = (fa) => (fab) => _ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 73,
        "to": 73
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => IO<B>) => (ma: IO<A>) => IO<B> = (f) => (ma) => _chain(ma, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 87,
        "to": 87
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, B>(f: (index: number, a: A) => IO<B>) => (\n  as: ReadonlyArray<A>\n): IO<ReadonlyArray<B>> => () => as.map((a, i) => f(i, a)())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 316,
        "to": 318
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, B>(f: (a: A) => IO<B>): ((as: ReadonlyArray<A>) => IO<ReadonlyArray<B>>) =>\n  traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IO.ts",
      "lines": {
        "from": 325,
        "to": 326
      }
    }
  },
  {
    "name": "getApplicativeIOValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeIOValidation<E>(S: Semigroup<E>): Applicative2C<URI, E> {\n  const ap = ap_(I.Apply, E.getApplicativeValidation(S))\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 416,
        "to": 425
      }
    }
  },
  {
    "name": "getAltIOValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltIOValidation<E>(S: Semigroup<E>): Alt2C<URI, E> {\n  const alt = ET.altValidation(I.Monad, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    alt: (fa, that) => pipe(fa, alt(that))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 431,
        "to": 439
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.1.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E> {\n  const F = E.getFilterable(M)\n  const C = getCompactable(M)\n\n  const filter = filter_(I.Functor, F)\n  const filterMap = filterMap_(I.Functor, F)\n  const partition = partition_(I.Functor, F)\n  const partitionMap = partitionMap_(I.Functor, F)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact: C.compact,\n    separate: C.separate,\n    filter: <A>(fa: IOEither<E, A>, predicate: Predicate<A>) => pipe(fa, filter(predicate)),\n    filterMap: (fa, f) => pipe(fa, filterMap(f)),\n    partition: <A>(fa: IOEither<E, A>, predicate: Predicate<A>) => pipe(fa, partition(predicate)),\n    partitionMap: (fa, f) => pipe(fa, partitionMap(f))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 459,
        "to": 478
      }
    }
  },
  {
    "name": "getIOValidation",
    "text": "\n\n/**\n * Use [`getApplicativeIOValidation`](#getapplicativeiovalidation) and [`getAltIOValidation`](#getaltiovalidation).\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport function getIOValidation<E>(\n  SE: Semigroup<E>\n): Monad2C<URI, E> & Bifunctor2<URI> & Alt2C<URI, E> & MonadIO2C<URI, E> & MonadThrow2C<URI, E> {\n  const applicativeIOValidation = getApplicativeIOValidation(SE)\n  const altIOValidation = getAltIOValidation(SE)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: applicativeIOValidation.ap,\n    of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: altIOValidation.alt,\n    fromIO,\n    throwError\n  }\n}",
    "docs": "/**\n * Use [`getApplicativeIOValidation`](#getapplicativeiovalidation) and [`getAltIOValidation`](#getaltiovalidation).\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"IOEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadIO\").MonadIO2C<\"IOEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 1020,
        "to": 1038
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch = <E, A>(f: Lazy<A>, onThrow: (reason: unknown) => E): IOEither<E, A> => () =>\n  E.tryCatch(f, onThrow)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        },
        {
          "name": "onThrow",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 198,
        "to": 199
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "const tryCatchK = <A extends ReadonlyArray<unknown>, B, E>(\n  f: (...a: A) => B,\n  onThrow: (reason: unknown) => E\n): ((...a: A) => IOEither<E, B>) => (...a) => tryCatch(() => f(...a), onThrow)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        },
        {
          "name": "onThrow",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 207,
        "to": 210
      }
    }
  },
  {
    "name": "getCompactable",
    "text": "const getCompactable = <E>(M: Monoid<E>): Compactable2C<URI, E> => {\n  const C = E.getCompactable(M)\n  return {\n    URI,\n    _E: undefined as any,\n    compact: compact_(I.Functor, C),\n    separate: separate_(I.Functor, C, E.Functor)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<\"IOEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 445,
        "to": 453
      }
    }
  },
  {
    "name": "bracket",
    "text": "const bracket = <E, A, B>(\n  acquire: IOEither<E, A>,\n  use: (a: A) => IOEither<E, B>,\n  release: (a: A, e: Either<E, B>) => IOEither<E, void>\n): IOEither<E, B> =>\n  pipe(\n    acquire,\n    chain((a) =>\n      pipe(\n        use(a),\n        I.chain((e) =>\n          pipe(\n            release(a, e),\n            chain(() => I.of(e))\n          )\n        )\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "acquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 799,
        "to": 817
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, E, B>(\n  f: (index: number, a: A) => IOEither<E, B>\n): ((as: ReadonlyArray<A>) => IOEither<E, ReadonlyArray<B>>) =>\n  flow(I.traverseArrayWithIndex(f), I.map(E.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 884,
        "to": 887
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, E, B>(\n  f: (a: A) => IOEither<E, B>\n): ((as: ReadonlyArray<A>) => IOEither<E, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 894,
        "to": 896
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <A, E, B>(f: (index: number, a: A) => IOEither<E, B>) => (\n  as: ReadonlyArray<A>\n): IOEither<E, ReadonlyArray<B>> => () => {\n  const out = []\n  for (let i = 0; i < as.length; i++) {\n    const b = f(i, as[i])()\n    if (E.isLeft(b)) {\n      return b\n    }\n    out.push(b.right)\n  }\n  return E.right(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 912,
        "to": 924
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray = <A, E, B>(\n  f: (a: A) => IOEither<E, B>\n): ((as: ReadonlyArray<A>) => IOEither<E, ReadonlyArray<B>>) => traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 931,
        "to": 933
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <E, A>(S: Semigroup<A>): Semigroup<IOEither<E, A>> =>\n  getApplySemigroup_(I.Apply)(E.getSemigroup(S))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IOEither.ts",
      "lines": {
        "from": 1010,
        "to": 1011
      }
    }
  },
  {
    "name": "newIORef",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function newIORef<A>(a: A): IO<IORef<A>> {\n  return () => new IORef(a)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IORef\").IORef<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/IORef.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "parse",
    "text": "const parse = (s: string): Either<unknown, Json> => parseJSON(s, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Json\").Json>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Json.ts",
      "lines": {
        "from": 38,
        "to": 38
      }
    }
  },
  {
    "name": "stringify",
    "text": "const stringify = <A>(a: A): Either<unknown, string> => stringifyJSON(a, identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, string>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Json.ts",
      "lines": {
        "from": 62,
        "to": 62
      }
    }
  },
  {
    "name": "collect",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: Map<K, A>) => Array<B> {\n  const keysO = keys(O)\n  return <A, B>(f: (k: K, a: A) => B) => (m: Map<K, A>): Array<B> => {\n    const out: Array<B> = []\n    const ks = keysO(m)\n    for (const key of ks) {\n      out.push(f(key, m.get(key)!))\n    }\n    return out\n  }\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: K, a: A) => B) => (m: Map<K, A>) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 92,
        "to": 102
      }
    }
  },
  {
    "name": "toArray",
    "text": "\n\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Map`.\n *\n * @since 2.0.0\n */\nexport function toArray<K>(O: Ord<K>): <A>(m: Map<K, A>) => Array<[K, A]> {\n  return collect(O)((k, a) => [k, a])\n}",
    "docs": "/**\n * Get a sorted `Array` of the key/value pairs contained in a `Map`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: Map<K, A>) => [K, A][]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 109,
        "to": 111
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a map into a list of key/value pairs\n *\n * @since 2.0.0\n */\nexport function toUnfoldable<K, F extends URIS>(ord: Ord<K>, U: Unfoldable1<F>): <A>(d: Map<K, A>) => Kind<F, [K, A]>",
    "docs": "/**\n * Unfolds a map into a list of key/value pairs\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 118,
        "to": 118
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(ord: Ord<K>, U: Unfoldable<F>): <A>(d: Map<K, A>) => HKT<F, [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 119,
        "to": 119
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(ord: Ord<K>, U: Unfoldable<F>): <A>(d: Map<K, A>) => HKT<F, [K, A]> {\n  const toArrayO = toArray(ord)\n  return (d) => {\n    const kas = toArrayO(d)\n    const len = kas.length\n    return U.unfold(0, (b) => (b < len ? O.some([kas[b], b + 1]) : O.none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 120,
        "to": 127
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.0.0\n */\nexport function pop<K>(E: Eq<K>): (k: K) => <A>(m: Map<K, A>) => Option<[A, Map<K, A>]> {\n  const lookupE = lookup(E)\n  const deleteAtE = deleteAt(E)\n  return (k) => {\n    const deleteAtEk = deleteAtE(k)\n    return (m) =>\n      pipe(\n        lookupE(k, m),\n        O.map((a) => [a, deleteAtEk(m)])\n      )\n  }\n}",
    "docs": "/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[A, Map<K, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 203,
        "to": 214
      }
    }
  },
  {
    "name": "lookupWithKey",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.0.0\n */\nexport function lookupWithKey<K>(\n  E: Eq<K>\n): {\n  (k: K): <A>(m: Map<K, A>) => Option<[K, A]>\n  <A>(k: K, m: Map<K, A>): Option<[K, A]>\n}",
    "docs": "/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (k: K): <A>(m: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[K, A]>; <A>(k: K, m: Map<K, A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[K, A]>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 228,
        "to": 233
      }
    }
  },
  {
    "name": "lookupWithKey",
    "text": "\nexport function lookupWithKey<K>(\n  E: Eq<K>\n): <A>(k: K, m?: Map<K, A>) => Option<[K, A]> | ((m: Map<K, A>) => Option<[K, A]>) {\n  return <A>(k: K, m?: Map<K, A>) => {\n    if (m === undefined) {\n      const lookupWithKeyE = lookupWithKey(E)\n      return (m) => lookupWithKeyE(k, m)\n    }\n    const entries = m.entries()\n    let e: Next<[K, A]>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = entries.next()).done) {\n      const [ka, a] = e.value\n      if (E.equals(ka, k)) {\n        return O.some([ka, a])\n      }\n    }\n    return O.none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m?: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<[K, A]> | ((m: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[K, A]>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 234,
        "to": 253
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<Map<K, A>> {\n  const lookupWithKeyS = lookupWithKey(SK)\n  return {\n    concat: (mx, my) => {\n      if (isEmpty(mx)) {\n        return my\n      }\n      if (isEmpty(my)) {\n        return mx\n      }\n      const r = new Map(mx)\n      const entries = my.entries()\n      let e: Next<[K, A]>\n      // tslint:disable-next-line: strict-boolean-expressions\n      while (!(e = entries.next()).done) {\n        const [k, a] = e.value\n        const mxOptA = lookupWithKeyS(k, mx)\n        if (O.isSome(mxOptA)) {\n          r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a))\n        } else {\n          r.set(k, a)\n        }\n      }\n      return r\n    },\n    empty: new Map()\n  }\n}",
    "docs": "/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Map<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 294,
        "to": 321
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, [K, A]>) => Map<K, A>",
    "docs": "/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 337,
        "to": 341
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 342,
        "to": 346
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 347,
        "to": 351
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [K, A]>) => Map<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 352,
        "to": 352
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(E: Eq<K>, M: Magma<A>, F: Foldable<F>): (fka: HKT<F, [K, A]>) => Map<K, A> {\n  return (fka: HKT<F, [K, A]>) => {\n    const lookupWithKeyE = lookupWithKey(E)\n    return F.reduce<[K, A], Map<K, A>>(fka, new Map<K, A>(), (b, [k, a]) => {\n      const bOpt = lookupWithKeyE(k, b)\n      if (O.isSome(bOpt)) {\n        b.set(bOpt.value[0], M.concat(bOpt.value[1], a))\n      } else {\n        b.set(k, a)\n      }\n      return b\n    })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 353,
        "to": 366
      }
    }
  },
  {
    "name": "getFilterableWithIndex",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getFilterableWithIndex<K = never>(): FilterableWithIndex2C<URI, K, K> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact,\n    separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2C<\"Map\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 599,
        "to": 616
      }
    }
  },
  {
    "name": "getWitherable",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getWitherable<K>(O: Ord<K>): Witherable2C<URI, K> & TraversableWithIndex2C<URI, K, K> {\n  const TWI = getTraversableWithIndex(O)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact,\n    separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: TWI.reduce,\n    foldMap: TWI.foldMap,\n    reduceRight: TWI.reduceRight,\n    traverse: TWI.traverse,\n    sequence: TWI.sequence,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: TWI.reduceWithIndex,\n    foldMapWithIndex: TWI.foldMapWithIndex,\n    reduceRightWithIndex: TWI.reduceRightWithIndex,\n    traverseWithIndex: TWI.traverseWithIndex,\n    wilt: <F>(\n      F: Applicative<F>\n    ): (<A, B, C>(wa: Map<K, A>, f: (a: A) => HKT<F, Either<B, C>>) => HKT<F, Separated<Map<K, B>, Map<K, C>>>) => {\n      const traverseF = TWI.traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), separate)\n    },\n    wither: <F>(F: Applicative<F>): (<A, B>(wa: Map<K, A>, f: (a: A) => HKT<F, Option<B>>) => HKT<F, Map<K, B>>) => {\n      const traverseF = TWI.traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), compact)\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Witherable\").Witherable2C<\"Map\", K> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TraversableWithIndex\").TraversableWithIndex2C<\"Map\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 622,
        "to": 655
      }
    }
  },
  {
    "name": "keys",
    "text": "const keys = <K>(O: Ord<K>) => <A>(m: Map<K, A>): Array<K> => Array.from(m.keys()).sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: Map<K, A>) => K[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 80,
        "to": 80
      }
    }
  },
  {
    "name": "values",
    "text": "const values = <A>(O: Ord<A>) => <K>(m: Map<K, A>): Array<A> => Array.from(m.values()).sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(m: Map<K, A>) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 87,
        "to": 87
      }
    }
  },
  {
    "name": "upsertAt",
    "text": "const upsertAt = <K>(E: Eq<K>): (<A>(k: K, a: A) => (m: Map<K, A>) => Map<K, A>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, a) => {\n    const lookupWithKeyEk = lookupWithKeyE(k)\n    return (m) => {\n      const found = lookupWithKeyEk(m)\n      if (O.isNone(found)) {\n        const out = new Map(m)\n        out.set(k, a)\n        return out\n      } else if (found.value[1] !== a) {\n        const out = new Map(m)\n        out.set(found.value[0], a)\n        return out\n      }\n      return m\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: Map<K, A>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 135,
        "to": 153
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "const deleteAt = <K>(E: Eq<K>): ((k: K) => <A>(m: Map<K, A>) => Map<K, A>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isSome(found)) {\n      const r = new Map(m)\n      r.delete(found.value[0])\n      return r\n    }\n    return m\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: Map<K, A>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 161,
        "to": 172
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <K>(E: Eq<K>): (<A>(k: K, a: A) => (m: Map<K, A>) => Option<Map<K, A>>) => {\n  const modifyAtE = modifyAt(E)\n  return (k, a) => modifyAtE(k, () => a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Map<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 177,
        "to": 180
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <K>(E: Eq<K>): (<A>(k: K, f: (a: A) => A) => (m: Map<K, A>) => Option<Map<K, A>>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, f) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isNone(found)) {\n      return O.none\n    }\n    const r = new Map(m)\n    r.set(found.value[0], f(found.value[1]))\n    return O.some(r)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, f: (a: A) => A) => (m: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Map<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 185,
        "to": 196
      }
    }
  },
  {
    "name": "singleton",
    "text": "const singleton = <K, A>(k: K, a: A): Map<K, A> => new Map([[k, a]])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 328,
        "to": 328
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "const partitionMapWithIndex = <K, A, B, C>(f: (k: K, a: A) => Either<B, C>) => (\n  fa: Map<K, A>\n): Separated<Map<K, B>, Map<K, C>> => {\n  const left = new Map<K, B>()\n  const right = new Map<K, C>()\n  const entries = fa.entries()\n  let e: Next<[K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    const ei = f(k, a)\n    if (isLeft(ei)) {\n      left.set(k, ei.left)\n    } else {\n      right.set(k, ei.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Map<K, B>, Map<K, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 384,
        "to": 402
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "const partitionWithIndex = <K, A>(p: (k: K, a: A) => boolean) => (\n  fa: Map<K, A>\n): Separated<Map<K, A>, Map<K, A>> => {\n  const left = new Map<K, A>()\n  const right = new Map<K, A>()\n  const entries = fa.entries()\n  let e: Next<[K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    if (p(k, a)) {\n      right.set(k, a)\n    } else {\n      left.set(k, a)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "p",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Map<K, A>, Map<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 408,
        "to": 425
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "const filterMapWithIndex = <K, A, B>(f: (k: K, a: A) => Option<B>) => (fa: Map<K, A>): Map<K, B> => {\n  const m = new Map<K, B>()\n  const entries = fa.entries()\n  let e: Next<[K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    const o = f(k, a)\n    if (O.isSome(o)) {\n      m.set(k, o.value)\n    }\n  }\n  return m\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Map<K, A>) => Map<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 431,
        "to": 444
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex = <K, A>(p: (k: K, a: A) => boolean) => (m: Map<K, A>): Map<K, A> => {\n  const out = new Map<K, A>()\n  const entries = m.entries()\n  let e: Next<[K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    if (p(k, a)) {\n      out.set(k, a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "p",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(m: Map<K, A>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 450,
        "to": 462
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <K, A>(fa: Map<K, Option<A>>): Map<K, A> => {\n  const m = new Map<K, A>()\n  const entries = fa.entries()\n  let e: Next<[K, Option<A>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, oa] = e.value\n    if (O.isSome(oa)) {\n      m.set(k, oa.value)\n    }\n  }\n  return m\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Map<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 489,
        "to": 501
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Map<K, B>\n  <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Map<K, A>\n} = <A>(predicate: Predicate<A>) => <K>(fa: Map<K, A>) => _filter(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: Map<K, A>) => Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 507,
        "to": 510
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => <K>(fa: Map<K, A>) => Map<K, B> = (f) => (fa) =>\n  _filterMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: Map<K, A>) => Map<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 516,
        "to": 517
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <K>(fa: Map<K, A>) => Map<K, B> = (f) => (fa) => _map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: Map<K, A>) => Map<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 526,
        "to": 526
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <K, A, B>(f: (k: K, a: A) => B) => (fa: Map<K, A>) => Map<K, B> = (f) => (fa) =>\n  _mapWithIndex(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Map<K, A>) => Map<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 532,
        "to": 533
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, B>>\n  <A>(predicate: Predicate<A>): <K>(fa: Map<K, A>) => Separated<Map<K, A>, Map<K, A>>\n} = <A>(predicate: Predicate<A>) => <K>(fa: Map<K, A>) => _partition(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Map<K, A>, Map<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 539,
        "to": 542
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <K>(fa: Map<K, A>) => Separated<Map<K, B>, Map<K, C>> = (f) => (fa) => _partitionMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: Map<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Map<K, B>, Map<K, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 548,
        "to": 550
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <K, A, B>(fa: Map<K, Either<A, B>>): Separated<Map<K, A>, Map<K, B>> => {\n  const left = new Map<K, A>()\n  const right = new Map<K, B>()\n  const entries = fa.entries()\n  let e: Next<[K, Either<A, B>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, ei] = e.value\n    if (isLeft(ei)) {\n      left.set(k, ei.left)\n    } else {\n      right.set(k, ei.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "Map<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Map<K, A>, Map<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 556,
        "to": 571
      }
    }
  },
  {
    "name": "getFoldableWithIndex",
    "text": "const getFoldableWithIndex = <K>(O: Ord<K>): FoldableWithIndex2C<URI, K, K> => {\n  const keysO = keys(O)\n\n  const reduceWithIndex = <B, A>(fa: Map<K, A>, b: B, f: (k: K, b: B, a: A) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = f(k, out, fa.get(k)!)\n    }\n    return out\n  }\n\n  const foldMapWithIndex = <M>(M: Monoid<M>) => <A>(fa: Map<K, A>, f: (k: K, a: A) => M): M => {\n    let out: M = M.empty\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = M.concat(out, f(k, fa.get(k)!))\n    }\n    return out\n  }\n\n  const reduceRightWithIndex = <B, A>(fa: Map<K, A>, b: B, f: (k: K, a: A, b: B) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = len - 1; i >= 0; i--) {\n      const k = ks[i]\n      out = f(k, fa.get(k)!, out)\n    }\n    return out\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    reduce: (fa, b, f) => reduceWithIndex(fa, b, (_, b, a) => f(b, a)),\n    foldMap: (M) => {\n      const foldMapWithIndexM = foldMapWithIndex(M)\n      return (fa, f) => foldMapWithIndexM(fa, (_, a) => f(a))\n    },\n    reduceRight: (fa, b, f) => reduceRightWithIndex(fa, b, (_, a, b) => f(a, b)),\n    reduceWithIndex,\n    foldMapWithIndex,\n    reduceRightWithIndex\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<\"Map\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 661,
        "to": 710
      }
    }
  },
  {
    "name": "getTraversableWithIndex",
    "text": "const getTraversableWithIndex = <K>(O: Ord<K>): TraversableWithIndex2C<URI, K, K> => {\n  const FWI = getFoldableWithIndex(O)\n  const keysO = keys(O)\n  const traverseWithIndex = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ta: Map<K, A>, f: (k: K, a: A) => HKT<F, B>) => HKT<F, Map<K, B>>) => {\n    return <A, B>(ta: Map<K, A>, f: (k: K, a: A) => HKT<F, B>) => {\n      let fm: HKT<F, Map<K, B>> = F.of(new Map())\n      const ks = keysO(ta)\n      const len = ks.length\n      for (let i = 0; i < len; i++) {\n        const key = ks[i]\n        const a = ta.get(key)!\n        fm = F.ap(\n          F.map(fm, (m) => (b: B) => m.set(key, b)),\n          f(key, a)\n        )\n      }\n      return fm\n    }\n  }\n  const traverse = <F>(F: Applicative<F>): (<A, B>(ta: Map<K, A>, f: (a: A) => HKT<F, B>) => HKT<F, Map<K, B>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta, f) => traverseWithIndexF(ta, (_, a) => f(a))\n  }\n\n  const sequence = <F>(F: Applicative<F>): (<A>(ta: Map<K, HKT<F, A>>) => HKT<F, Map<K, A>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta) => traverseWithIndexF(ta, (_, a) => a)\n  }\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: FWI.reduce,\n    foldMap: FWI.foldMap,\n    reduceRight: FWI.reduceRight,\n    reduceWithIndex: FWI.reduceWithIndex,\n    foldMapWithIndex: FWI.foldMapWithIndex,\n    reduceRightWithIndex: FWI.reduceRightWithIndex,\n    traverse,\n    sequence,\n    traverseWithIndex\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TraversableWithIndex\").TraversableWithIndex2C<\"Map\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Map.ts",
      "lines": {
        "from": 716,
        "to": 761
      }
    }
  },
  {
    "name": "min",
    "text": "const min = <A>(B: Bounded<A>): Monoid<A> => ({\n  concat: Se.min(B).concat,\n  empty: B.top\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bounded\").Bounded<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 73,
        "to": 76
      }
    }
  },
  {
    "name": "max",
    "text": "const max = <A>(B: Bounded<A>): Monoid<A> => ({\n  concat: Se.max(B).concat,\n  empty: B.bottom\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "B",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bounded\").Bounded<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 93,
        "to": 96
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(M: Monoid<A>): Monoid<A> => ({\n  concat: Se.reverse(M).concat,\n  empty: M.empty\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 114,
        "to": 117
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(monoids: { [K in keyof A]: Monoid<A[K]> }): Monoid<{ readonly [K in keyof A]: A[K] }> => {\n  const empty: A = {} as any\n  for (const k in monoids) {\n    if (_.has.call(monoids, k)) {\n      empty[k] = monoids[k].empty\n    }\n  }\n  return {\n    concat: Se.struct(monoids).concat,\n    empty\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "monoids",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<{ readonly [K in keyof A]: A[K]; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 141,
        "to": 152
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...monoids: { [K in keyof A]: Monoid<A[K]> }\n): Monoid<Readonly<A>> =>\n  ({\n    concat: Se.tuple(...(monoids as any)).concat,\n    empty: monoids.map((m) => m.empty)\n  } as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "monoids",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 172,
        "to": 178
      }
    }
  },
  {
    "name": "concatAll",
    "text": "const concatAll = <A>(M: Monoid<A>): ((as: ReadonlyArray<A>) => A) => Se.concatAll(M)(M.empty)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 207,
        "to": 207
      }
    }
  },
  {
    "name": "getEndomorphismMonoid",
    "text": "const getEndomorphismMonoid = <A = never>(): Monoid<Endomorphism<A>> => reverse(getEM())",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Monoid.ts",
      "lines": {
        "from": 314,
        "to": 314
      }
    }
  },
  {
    "name": "concat",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n// TODO: curry in v3\n/**\n * @category combinators\n * @since 2.2.0\n */\nexport function concat<A>(first: Array<A>, second: NonEmptyArray<A>): NonEmptyArray<A>",
    "docs": "/**\n * @category combinators\n * @since 2.2.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 224,
        "to": 224
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(first: NonEmptyArray<A>, second: Array<A>): NonEmptyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 225,
        "to": 225
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(first: Array<A>, second: Array<A>): Array<A> {\n  return first.concat(second)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 226,
        "to": 228
      }
    }
  },
  {
    "name": "group",
    "text": "\n\n/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { group } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(group(N.Ord)([1, 2, 1, 1]), [\n *   [1],\n *   [2],\n *   [1, 1]\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function group<B>(\n  E: Eq<B>\n): {\n  <A extends B>(as: NonEmptyArray<A>): NonEmptyArray<NonEmptyArray<A>>\n  <A extends B>(as: Array<A>): Array<NonEmptyArray<A>>\n}",
    "docs": "/**\n * Group equal, consecutive elements of an array into non empty arrays.\n *\n * @example\n * import { group } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(group(N.Ord)([1, 2, 1, 1]), [\n *   [1],\n *   [2],\n *   [1, 1]\n * ])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>; <A extends B>(as: A[]): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 252,
        "to": 257
      }
    }
  },
  {
    "name": "group",
    "text": "\nexport function group<A>(E: Eq<A>): (as: Array<A>) => Array<NonEmptyArray<A>> {\n  return (as) => {\n    const len = as.length\n    if (len === 0) {\n      return []\n    }\n    const out: Array<NonEmptyArray<A>> = []\n    let head: A = as[0]\n    let nea: NonEmptyArray<A> = [head]\n    for (let i = 1; i < len; i++) {\n      const a = as[i]\n      if (E.equals(a, head)) {\n        nea.push(a)\n      } else {\n        out.push(nea)\n        head = a\n        nea = [head]\n      }\n    }\n    out.push(nea)\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 258,
        "to": 280
      }
    }
  },
  {
    "name": "groupSort",
    "text": "\n\n/**\n * Sort and then group the elements of an array into non empty arrays.\n *\n * @example\n * import { groupSort } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(groupSort(N.Ord)([1, 2, 1, 1]), [[1, 1, 1], [2]])\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function groupSort<B>(\n  O: Ord<B>\n): {\n  <A extends B>(as: NonEmptyArray<A>): NonEmptyArray<NonEmptyArray<A>>\n  <A extends B>(as: Array<A>): Array<NonEmptyArray<A>>\n}",
    "docs": "/**\n * Sort and then group the elements of an array into non empty arrays.\n *\n * @example\n * import { groupSort } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(groupSort(N.Ord)([1, 2, 1, 1]), [[1, 1, 1], [2]])\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>; <A extends B>(as: A[]): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 294,
        "to": 299
      }
    }
  },
  {
    "name": "groupSort",
    "text": "\nexport function groupSort<A>(O: Ord<A>): (as: Array<A>) => Array<NonEmptyArray<A>> {\n  const sortO = sort(O)\n  const groupO = group(O)\n  return (as) => (isNonEmpty(as) ? groupO(sortO(as)) : [])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 300,
        "to": 304
      }
    }
  },
  {
    "name": "zip",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport function zip<B>(bs: NonEmptyArray<B>): <A>(as: NonEmptyArray<A>) => NonEmptyArray<[A, B]>",
    "docs": "/**\n * @category combinators\n * @since 2.5.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<[A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 395,
        "to": 395
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(as: NonEmptyArray<A>, bs: NonEmptyArray<B>): NonEmptyArray<[A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<[A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 396,
        "to": 396
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(\n  as: NonEmptyArray<A>,\n  bs?: NonEmptyArray<B>\n): NonEmptyArray<[A, B]> | ((bs: NonEmptyArray<B>) => NonEmptyArray<[B, A]>) {\n  if (bs === undefined) {\n    return (bs) => zip(bs, as)\n  }\n  return zipWith(as, bs, (a, b) => [a, b])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<[A, B]> | ((bs: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<[B, A]>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 397,
        "to": 405
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n/**\n * Use [`filter`](./Array.ts.html#filter) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport function filter<A, B extends A>(refinement: Refinement<A, B>): (as: NonEmptyArray<A>) => Option<NonEmptyArray<B>>",
    "docs": "/**\n * Use [`filter`](./Array.ts.html#filter) instead.\n *\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1070,
        "to": 1070
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (as: NonEmptyArray<A>) => Option<NonEmptyArray<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1071,
        "to": 1071
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (as: NonEmptyArray<A>) => Option<NonEmptyArray<A>> {\n  // tslint:disable-next-line: deprecation\n  return filterWithIndex((_, a) => predicate(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1072,
        "to": 1075
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * Use [`prepend`](./Array.ts.html#prepend) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */\nexport function cons<A>(head: A): (tail: Array<A>) => NonEmptyArray<A>",
    "docs": "/**\n * Use [`prepend`](./Array.ts.html#prepend) instead.\n *\n * @category constructors\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tail: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1113,
        "to": 1113
      }
    }
  },
  {
    "name": "cons",
    "text": "\n/** @deprecated */\nexport function cons<A>(head: A, tail: Array<A>): NonEmptyArray<A>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1115,
        "to": 1115
      }
    }
  },
  {
    "name": "cons",
    "text": "\nexport function cons<A>(head: A, tail?: Array<A>): NonEmptyArray<A> | ((tail: Array<A>) => NonEmptyArray<A>) {\n  return tail === undefined ? prepend(head) : pipe(tail, prepend(head))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A> | ((tail: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1116,
        "to": 1118
      }
    }
  },
  {
    "name": "isNonEmpty",
    "text": "const isNonEmpty = <A>(as: Array<A>): as is NonEmptyArray<A> => as.length > 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 63,
        "to": 63
      }
    }
  },
  {
    "name": "isOutOfBound",
    "text": "const isOutOfBound = <A>(i: number, as: Array<A>): boolean => i < 0 || i >= as.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 68,
        "to": 68
      }
    }
  },
  {
    "name": "prepend",
    "text": "const prepend = <A>(head: A) => (tail: Array<A>): NonEmptyArray<A> => [head, ...tail]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tail: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 73,
        "to": 73
      }
    }
  },
  {
    "name": "append",
    "text": "const append = <A>(end: A) => (init: Array<A>): NonEmptyArray<A> => concat(init, [end])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "end",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(init: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 78,
        "to": 78
      }
    }
  },
  {
    "name": "unsafeInsertAt",
    "text": "const unsafeInsertAt = <A>(i: number, a: A, as: Array<A>): NonEmptyArray<A> => {\n  if (isNonEmpty(as)) {\n    const xs = fromReadonlyNonEmptyArray(as)\n    xs.splice(i, 0, a)\n    return xs\n  }\n  return [a]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 83,
        "to": 90
      }
    }
  },
  {
    "name": "unsafeUpdateAt",
    "text": "const unsafeUpdateAt = <A>(i: number, a: A, as: NonEmptyArray<A>): NonEmptyArray<A> => {\n  const xs = fromReadonlyNonEmptyArray(as)\n  xs[i] = a\n  return xs\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 95,
        "to": 99
      }
    }
  },
  {
    "name": "uniq",
    "text": "const uniq = <A>(E: Eq<A>) => (as: NonEmptyArray<A>): NonEmptyArray<A> => {\n  if (as.length === 1) {\n    return copy(as)\n  }\n  const out: NonEmptyArray<A> = [head(as)]\n  const rest = tail(as)\n  for (const a of rest) {\n    if (out.every((o) => !E.equals(o, a))) {\n      out.push(a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 104,
        "to": 116
      }
    }
  },
  {
    "name": "sortBy",
    "text": "const sortBy = <B>(ords: Array<Ord<B>>): (<A extends B>(as: NonEmptyArray<A>) => NonEmptyArray<A>) => {\n  if (isNonEmpty(ords)) {\n    const M = getMonoid<B>()\n    return sort(ords.reduce(M.concat, M.empty))\n  }\n  return copy\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 121,
        "to": 127
      }
    }
  },
  {
    "name": "union",
    "text": "const union = <A>(E: Eq<A>): Semigroup<NonEmptyArray<A>>['concat'] => {\n  const uniqE = uniq(E)\n  return (first, second) => uniqE(concat(first, second))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>, y: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 132,
        "to": 135
      }
    }
  },
  {
    "name": "rotate",
    "text": "const rotate = (n: number) => <A>(as: NonEmptyArray<A>): NonEmptyArray<A> => {\n  const len = as.length\n  const m = Math.round(n) % len\n  if (isOutOfBound(Math.abs(m), as) || m === 0) {\n    return copy(as)\n  }\n  if (m < 0) {\n    const [f, s] = splitAt(-m)(as)\n    return concat(s, f)\n  } else {\n    return rotate(m - len)(as)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 140,
        "to": 152
      }
    }
  },
  {
    "name": "makeBy",
    "text": "const makeBy = <A>(n: number, f: (i: number) => A): NonEmptyArray<A> => {\n  const j = Math.max(0, Math.floor(n))\n  const out: NonEmptyArray<A> = [f(0)]\n  for (let i = 1; i < j; i++) {\n    out.push(f(i))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 157,
        "to": 164
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <A>(as: Array<A>): Option<NonEmptyArray<A>> => (isNonEmpty(as) ? O.some(as) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 183,
        "to": 183
      }
    }
  },
  {
    "name": "unprepend",
    "text": "const unprepend = <A>(as: NonEmptyArray<A>): [A, Array<A>] => [head(as), tail(as)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A, A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 200,
        "to": 200
      }
    }
  },
  {
    "name": "unappend",
    "text": "const unappend = <A>(as: NonEmptyArray<A>): [Array<A>, A] => [init(as), last(as)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A[], A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 213,
        "to": 213
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(as: NonEmptyArray<A>): NonEmptyArray<A> => [last(as), ...as.slice(0, -1).reverse()]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 234,
        "to": 234
      }
    }
  },
  {
    "name": "groupBy",
    "text": "const groupBy = <A>(f: (a: A) => string) => (as: Array<A>): Record<string, NonEmptyArray<A>> => {\n  const out: Record<string, NonEmptyArray<A>> = {}\n  for (const a of as) {\n    const k = f(a)\n    if (out.hasOwnProperty(k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 321,
        "to": 332
      }
    }
  },
  {
    "name": "sort",
    "text": "const sort = <B>(O: Ord<B>) => <A extends B>(as: NonEmptyArray<A>): NonEmptyArray<A> =>\n  as.slice().sort(O.compare) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 338,
        "to": 339
      }
    }
  },
  {
    "name": "insertAt",
    "text": "const insertAt = <A>(i: number, a: A) => (as: Array<A>): Option<NonEmptyArray<A>> =>\n  i < 0 || i > as.length ? O.none : O.some(unsafeInsertAt(i, a, as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 345,
        "to": 346
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(i: number, a: A): ((as: NonEmptyArray<A>) => Option<NonEmptyArray<A>>) =>\n  modifyAt(i, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 352,
        "to": 353
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(i: number, f: (a: A) => A) => (as: NonEmptyArray<A>): Option<NonEmptyArray<A>> =>\n  isOutOfBound(i, as) ? O.none : O.some(unsafeUpdateAt(i, f(as[i]), as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 359,
        "to": 360
      }
    }
  },
  {
    "name": "of",
    "text": "const of: Pointed1<URI>['of'] = (a) => [a]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 372,
        "to": 372
      }
    }
  },
  {
    "name": "zipWith",
    "text": "const zipWith = <A, B, C>(\n  as: NonEmptyArray<A>,\n  bs: NonEmptyArray<B>,\n  f: (a: A, b: B) => C\n): NonEmptyArray<C> => {\n  const cs: NonEmptyArray<C> = [f(as[0], bs[0])]\n  const len = Math.min(as.length, bs.length)\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(as[i], bs[i])\n  }\n  return cs\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 378,
        "to": 389
      }
    }
  },
  {
    "name": "unzip",
    "text": "const unzip = <A, B>(abs: NonEmptyArray<[A, B]>): [NonEmptyArray<A>, NonEmptyArray<B>] => {\n  const fa: NonEmptyArray<A> = [abs[0][0]]\n  const fb: NonEmptyArray<B> = [abs[0][1]]\n  for (let i = 1; i < abs.length; i++) {\n    fa[i] = abs[i][0]\n    fb[i] = abs[i][1]\n  }\n  return [fa, fb]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "abs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<[A, B]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 411,
        "to": 419
      }
    }
  },
  {
    "name": "prependAll",
    "text": "const prependAll = <A>(middle: A) => (as: NonEmptyArray<A>): NonEmptyArray<A> => {\n  const out: NonEmptyArray<A> = [middle, as[0]]\n  for (let i = 1; i < as.length; i++) {\n    out.push(middle, as[i])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 432,
        "to": 438
      }
    }
  },
  {
    "name": "intersperse",
    "text": "const intersperse = <A>(middle: A) => (as: NonEmptyArray<A>): NonEmptyArray<A> => {\n  const rest = tail(as)\n  return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 451,
        "to": 454
      }
    }
  },
  {
    "name": "chainWithIndex",
    "text": "const chainWithIndex = <A, B>(f: (i: number, a: A) => NonEmptyArray<B>) => (\n  as: NonEmptyArray<A>\n): NonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = fromReadonlyNonEmptyArray(f(0, head(as)))\n  for (let i = 1; i < as.length; i++) {\n    out.push(...f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 473,
        "to": 481
      }
    }
  },
  {
    "name": "chop",
    "text": "const chop = <A, B>(f: (as: NonEmptyArray<A>) => [B, Array<A>]) => (as: NonEmptyArray<A>): NonEmptyArray<B> => {\n  const [b, rest] = f(as)\n  const out: NonEmptyArray<B> = [b]\n  let next: Array<A> = rest\n  while (isNonEmpty(next)) {\n    const [b, rest] = f(next)\n    out.push(b)\n    next = rest\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => [B, A[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 487,
        "to": 497
      }
    }
  },
  {
    "name": "splitAt",
    "text": "const splitAt = (n: number) => <A>(as: NonEmptyArray<A>): [NonEmptyArray<A>, Array<A>] => {\n  const m = Math.max(1, n)\n  return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>, A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 505,
        "to": 508
      }
    }
  },
  {
    "name": "chunksOf",
    "text": "const chunksOf = (n: number): (<A>(as: NonEmptyArray<A>) => NonEmptyArray<NonEmptyArray<A>>) => chop(splitAt(n))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 514,
        "to": 514
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW = <B>(that: Lazy<NonEmptyArray<B>>) => <A>(as: NonEmptyArray<A>): NonEmptyArray<A | B> =>\n  concat(as as NonEmptyArray<A | B>, that())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 577,
        "to": 578
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap = <A>(as: NonEmptyArray<A>): (<B>(fab: NonEmptyArray<(a: A) => B>) => NonEmptyArray<B>) =>\n  chain((f) => pipe(as, map(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 595,
        "to": 596
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain = <A, B>(f: (a: A) => NonEmptyArray<B>): ((ma: NonEmptyArray<A>) => NonEmptyArray<B>) =>\n  chainWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 604,
        "to": 605
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend = <A, B>(f: (as: NonEmptyArray<A>) => B) => (as: NonEmptyArray<A>): NonEmptyArray<B> => {\n  let next: Array<A> = tail(as)\n  const out: NonEmptyArray<B> = [f(as)]\n  while (isNonEmpty(next)) {\n    out.push(f(next))\n    next = tail(next)\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 611,
        "to": 619
      }
    }
  },
  {
    "name": "map",
    "text": "const map = <A, B>(f: (a: A) => B): ((as: NonEmptyArray<A>) => NonEmptyArray<B>) => mapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 648,
        "to": 648
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex = <A, B>(f: (i: number, a: A) => B) => (as: NonEmptyArray<A>): NonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = [f(0, head(as))]\n  for (let i = 1; i < as.length; i++) {\n    out.push(f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 654,
        "to": 660
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (as: NonEmptyArray<A>) => HKT<F, NonEmptyArray<B>>) => {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 691,
        "to": 696
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: ApplicativeHKT<F>\n): (<A>(as: NonEmptyArray<HKT<F, A>>) => HKT<F, NonEmptyArray<A>>) => traverseWithIndex(F)((_, a) => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 701,
        "to": 703
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "const traverseWithIndex: PipeableTraverseWithIndex1<URI, number> = <F>(F: ApplicativeHKT<F>) => <A, B>(\n  f: (i: number, a: A) => HKT<F, B>\n) => (as: NonEmptyArray<A>): HKT<F, NonEmptyArray<B>> => {\n  let out: HKT<F, NonEmptyArray<B>> = F.map(f(0, head(as)), of)\n  for (let i = 1; i < as.length; i++) {\n    out = F.ap(\n      F.map(out, (bs) => (b: B) => pipe(bs, append(b))),\n      f(i, as[i])\n    )\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 708,
        "to": 719
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A = never>(): Semigroup<NonEmptyArray<A>> => ({\n  concat\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 760,
        "to": 762
      }
    }
  },
  {
    "name": "tail",
    "text": "const tail = <A>(as: NonEmptyArray<A>): Array<A> => as.slice(1)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1024,
        "to": 1024
      }
    }
  },
  {
    "name": "init",
    "text": "const init = <A>(as: NonEmptyArray<A>): Array<A> => as.slice(0, -1)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1042,
        "to": 1042
      }
    }
  },
  {
    "name": "concatAll",
    "text": "const concatAll = <A>(S: Semigroup<A>) => (as: NonEmptyArray<A>): A => as.reduce(S.concat)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1057,
        "to": 1057
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex = <A>(predicate: (i: number, a: A) => boolean) => (\n  as: NonEmptyArray<A>\n): Option<NonEmptyArray<A>> => fromArray(as.filter((a, i) => predicate(i, a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1084,
        "to": 1086
      }
    }
  },
  {
    "name": "snoc",
    "text": "const snoc = <A>(init: Array<A>, end: A): NonEmptyArray<A> => pipe(init, append(end))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "init",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/NonEmptyArray\").NonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/NonEmptyArray.ts",
      "lines": {
        "from": 1127,
        "to": 1127
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\n\n/**\n * Returns a *smart constructor* based on the given predicate.\n *\n * @example\n * import { none, some, fromPredicate } from 'fp-ts/Option'\n *\n * const getOption = fromPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), none)\n * assert.deepStrictEqual(getOption(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromPredicate<A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>",
    "docs": "/**\n * Returns a *smart constructor* based on the given predicate.\n *\n * @example\n * import { none, some, fromPredicate } from 'fp-ts/Option'\n *\n * const getOption = fromPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), none)\n * assert.deepStrictEqual(getOption(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 140,
        "to": 140
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<A>(predicate: Predicate<A>): (a: A) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 141,
        "to": 141
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<A>(predicate: Predicate<A>): (a: A) => Option<A> {\n  return (a) => (predicate(a) ? some(a) : none)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 142,
        "to": 144
      }
    }
  },
  {
    "name": "getLeft",
    "text": "\n\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft<E, A>(ma: Either<E, A>): Option<E> {\n  return ma._tag === 'Right' ? none : some(ma.left)\n}",
    "docs": "/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 159,
        "to": 161
      }
    }
  },
  {
    "name": "getRight",
    "text": "\n\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight<E, A>(ma: Either<E, A>): Option<A> {\n  return ma._tag === 'Left' ? none : some(ma.right)\n}",
    "docs": "/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 176,
        "to": 178
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<A>(S: Show<A>): Show<Option<A>> {\n  return {\n    show: (ma) => (isNone(ma) ? 'none' : `some(${S.show(ma.value)})`)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 766,
        "to": 770
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<Option<A>> {\n  return {\n    equals: (x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value))\n  }\n}",
    "docs": "/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 787,
        "to": 791
      }
    }
  },
  {
    "name": "getOrd",
    "text": "\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd<A>(O: Ord<A>): Ord<Option<A>> {\n  return {\n    equals: getEq(O).equals,\n    compare: (x, y) => (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1)\n  }\n}",
    "docs": "/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 814,
        "to": 819
      }
    }
  },
  {
    "name": "getFirstMonoid",
    "text": "\n\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid<A = never>(): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(x) ? y : x),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 843,
        "to": 848
      }
    }
  },
  {
    "name": "getLastMonoid",
    "text": "\n\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid<A = never>(): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(y) ? x : y),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 872,
        "to": 877
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid<A>(S: Semigroup<A>): Monoid<Option<A>> {\n  return {\n    concat: (x, y) => (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))),\n    empty: none\n  }\n}",
    "docs": "/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 903,
        "to": 908
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * assert.strictEqual(elem(N.Eq)(1, some(1)), true)\n * assert.strictEqual(elem(N.Eq)(2, some(1)), false)\n * assert.strictEqual(elem(N.Eq)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, ma: Option<A>) => boolean {\n  return (a, ma) => (isNone(ma) ? false : E.equals(a, ma.value))\n}",
    "docs": "/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * assert.strictEqual(elem(N.Eq)(1, some(1)), true)\n * assert.strictEqual(elem(N.Eq)(2, some(1)), false)\n * assert.strictEqual(elem(N.Eq)(1, none), false)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 1154,
        "to": 1156
      }
    }
  },
  {
    "name": "exists",
    "text": "\n\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists<A>(predicate: Predicate<A>): (ma: Option<A>) => boolean {\n  return (ma) => (isNone(ma) ? false : predicate(ma.value))\n}",
    "docs": "/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 1189,
        "to": 1191
      }
    }
  },
  {
    "name": "getRefinement",
    "text": "\n\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement<A, B extends A>(getOption: (a: A) => Option<B>): Refinement<A, B> {\n  return (a: A): a is B => isSome(getOption(a))\n}",
    "docs": "/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "getOption",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 1210,
        "to": 1212
      }
    }
  },
  {
    "name": "isNone",
    "text": "const isNone = <A>(fa: Option<A>): fa is None => fa._tag === 'None'",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 104,
        "to": 104
      }
    }
  },
  {
    "name": "some",
    "text": "const some = <A>(a: A): Option<A> => ({ _tag: 'Some', value: a })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 124,
        "to": 124
      }
    }
  },
  {
    "name": "matchW",
    "text": "const matchW = <B, A, C>(onNone: Lazy<B>, onSome: (a: A) => C) => (ma: Option<A>): B | C =>\n  isNone(ma) ? onNone() : onSome(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        },
        {
          "name": "onSome",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B | C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 200,
        "to": 201
      }
    }
  },
  {
    "name": "getOrElseW",
    "text": "const getOrElseW = <B>(onNone: Lazy<B>) => <A>(ma: Option<A>): A | B => (isNone(ma) ? onNone() : ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onNone",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B | A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 254,
        "to": 254
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "const fromNullable = <A>(a: A): Option<NonNullable<A>> => (a == null ? none : some(a as NonNullable<A>))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 301,
        "to": 301
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch = <A>(f: Lazy<A>): Option<A> => {\n  try {\n    return some(f())\n  } catch (e) {\n    return none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 323,
        "to": 329
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "const tryCatchK = <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): ((...a: A) => Option<B>) => (...a) =>\n  tryCatch(() => f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 337,
        "to": 338
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "const fromNullableK: <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => Option<NonNullable<B>> = (f) => flow(f, fromNullable)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 359,
        "to": 361
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "const chainNullableK = <A, B>(f: (a: A) => B | null | undefined) => (ma: Option<A>): Option<B> =>\n  isNone(ma) ? none : fromNullable(f(ma.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 407,
        "to": 408
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Option<A>) => Option<B> = (f) => (fa) =>\n  isNone(fa) ? none : some(f(fa.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 525,
        "to": 526
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Option<A>) => <B>(fab: Option<(a: A) => B>) => Option<B> = (fa) => (fab) =>\n  isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 534,
        "to": 535
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Option<B>) => (ma: Option<A>) => Option<B> = (f) => (ma) =>\n  isNone(ma) ? none : f(ma.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 549,
        "to": 550
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW: <B>(that: Lazy<Option<B>>) => <A>(fa: Option<A>) => Option<A | B> = (that) => (fa) =>\n  isNone(fa) ? that() : fa",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<A> | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 568,
        "to": 569
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero: Alternative1<URI>['zero'] = () => none",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 605,
        "to": 605
      }
    }
  },
  {
    "name": "throwError",
    "text": "const throwError: MonadThrow1<URI>['throwError'] = () => none",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 611,
        "to": 611
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Option<A>) => B) => (wa: Option<A>) => Option<B> = (f) => (wa) =>\n  isNone(wa) ? none : some(f(wa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 617,
        "to": 618
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Option<A>) => B = (b, f) => (fa) =>\n  isNone(fa) ? b : f(b, fa.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 634,
        "to": 635
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Option<A>) => M = (M) => (f) => (fa) =>\n  isNone(fa) ? M.empty : f(fa.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 641,
        "to": 642
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Option<A>) => B = (b, f) => (fa) =>\n  isNone(fa) ? b : f(fa.value, b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 648,
        "to": 649
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate: <A, B>(ma: Option<Either<A, B>>) => Separated<Option<A>, Option<B>> = (ma) =>\n  isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 665,
        "to": 666
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Option<A>) => Option<B>\n  <A>(predicate: Predicate<A>): (fa: Option<A>) => Option<A>\n} = <A>(predicate: Predicate<A>) => (fa: Option<A>) => (isNone(fa) ? none : predicate(fa.value) ? fa : none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 672,
        "to": 675
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: Option<A>) => Option<B> = (f) => (fa) =>\n  isNone(fa) ? none : f(fa.value)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 681,
        "to": 682
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Option<A>) => Separated<Option<A>, Option<B>>\n  <A>(predicate: Predicate<A>): (fa: Option<A>) => Separated<Option<A>, Option<A>>\n} = <A>(predicate: Predicate<A>) => (fa: Option<A>) => {\n  return separated(\n    _filter(fa, (a) => !predicate(a)),\n    _filter(fa, predicate)\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 688,
        "to": 696
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Option<A>) => Separated<Option<B>, Option<C>> = (f) => flow(map(f), separate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 702,
        "to": 704
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(F: ApplicativeHKT<F>) => <A, B>(f: (a: A) => HKT<F, B>) => (\n  ta: Option<A>\n): HKT<F, Option<B>> => (isNone(ta) ? F.of(none) : F.map(f(ta.value), some))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 710,
        "to": 712
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: ApplicativeHKT<F>) => <A>(\n  ta: Option<HKT<F, A>>\n): HKT<F, Option<A>> => (isNone(ta) ? F.of(none) : F.map(ta.value, some))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 718,
        "to": 720
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(F: ApplicativeHKT<F>) => <A, B>(f: (a: A) => HKT<F, Option<B>>) => (\n  fa: Option<A>\n): HKT<F, Option<B>> => (isNone(fa) ? F.of(none) : f(fa.value))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 726,
        "to": 728
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(F: ApplicativeHKT<F>) => <A, B, C>(f: (a: A) => HKT<F, Either<B, C>>) => (\n  fa: Option<A>\n): HKT<F, Separated<Option<B>, Option<C>>> => {\n  return isNone(fa) ? F.of(defaultSeparated) : F.map(f(fa.value), (e) => separated(getLeft(e), getRight(e)))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 734,
        "to": 738
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, B>(f: (index: number, a: A) => Option<B>) => (\n  as: ReadonlyArray<A>\n): Option<ReadonlyArray<B>> => {\n  const out = []\n  for (let i = 0; i < as.length; i++) {\n    const b = f(i, as[i])\n    if (isNone(b)) {\n      return none\n    }\n    out.push(b.value)\n  }\n  return some(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 1259,
        "to": 1271
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, B>(f: (a: A) => Option<B>): ((as: ReadonlyArray<A>) => Option<ReadonlyArray<B>>) =>\n  traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Option.ts",
      "lines": {
        "from": 1278,
        "to": 1279
      }
    }
  },
  {
    "name": "some",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function some<F extends URIS4>(F: Pointed4<F>): <A, S, R, E>(a: A) => Kind4<F, S, R, E, Option<A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 29,
        "to": 29
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F extends URIS3>(F: Pointed3<F>): <A, R, E>(a: A) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 30,
        "to": 30
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F extends URIS3, E>(F: Pointed3C<F, E>): <A, R>(a: A) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 31,
        "to": 31
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F extends URIS2>(F: Pointed2<F>): <A, E>(a: A) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 32,
        "to": 32
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(a: A) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 33,
        "to": 33
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F extends URIS>(F: Pointed1<F>): <A>(a: A) => Kind<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 34,
        "to": 34
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 35,
        "to": 35
      }
    }
  },
  {
    "name": "some",
    "text": "\nexport function some<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option<A>> {\n  return flow(O.some, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 36,
        "to": 38
      }
    }
  },
  {
    "name": "zero",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function zero<F extends URIS4>(F: Pointed4<F>): <S, R, E, A>() => Kind4<F, S, R, E, Option<A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 43,
        "to": 43
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F extends URIS3>(F: Pointed3<F>): <R, E, A>() => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 44,
        "to": 44
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F extends URIS3, E>(F: Pointed3C<F, E>): <R, A>() => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 45,
        "to": 45
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F extends URIS2>(F: Pointed2<F>): <E, A>() => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 46,
        "to": 46
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F extends URIS2, E>(F: Pointed2C<F, E>): <A>() => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F extends URIS>(F: Pointed1<F>): <A>() => Kind<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 48,
        "to": 48
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F>(F: Pointed<F>): <A>() => HKT<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 49,
        "to": 49
      }
    }
  },
  {
    "name": "zero",
    "text": "\nexport function zero<F>(F: Pointed<F>): <A>() => HKT<F, Option<A>> {\n  return constant(F.of(O.none))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 50,
        "to": 52
      }
    }
  },
  {
    "name": "fromF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromF<F extends URIS4>(\n  F: Functor4<F>\n): <S, R, E, A>(ma: Kind4<F, S, R, E, A>) => Kind4<F, S, R, E, Option<A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 57,
        "to": 59
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS3>(F: Functor3<F>): <R, E, A>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 60,
        "to": 60
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <R, A>(ma: Kind3<F, R, E, A>) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS2>(F: Functor2<F>): <E, A>(ma: Kind2<F, E, A>) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 64,
        "to": 64
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS2, E>(F: Functor2C<F, E>): <A>(ma: Kind2<F, E, A>) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 65,
        "to": 65
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS>(F: Functor1<F>): <A>(ma: Kind<F, A>) => Kind<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 66,
        "to": 66
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F>(F: Functor<F>): <A>(ma: HKT<F, A>) => HKT<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 67,
        "to": 67
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F>(F: Functor<F>): <A>(ma: HKT<F, A>) => HKT<F, Option<A>> {\n  return (ma) => F.map(ma, O.some)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 68,
        "to": 70
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromNullable<F extends URIS4>(\n  F: Pointed4<F>\n): <A, S, R, E>(a: A) => Kind4<F, S, R, E, Option<NonNullable<A>>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 75,
        "to": 77
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F extends URIS3>(F: Pointed3<F>): <A, R, E>(a: A) => Kind3<F, R, E, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 78,
        "to": 78
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F extends URIS3, E>(\n  F: Pointed3C<F, E>\n): <A, R>(a: A) => Kind3<F, R, E, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 79,
        "to": 81
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F extends URIS2>(F: Pointed2<F>): <A, E>(a: A) => Kind2<F, E, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 82,
        "to": 82
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(a: A) => Kind2<F, E, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 83,
        "to": 83
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F extends URIS>(F: Pointed1<F>): <A>(a: A) => Kind<F, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 84,
        "to": 84
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option<NonNullable<A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 85,
        "to": 85
      }
    }
  },
  {
    "name": "fromNullable",
    "text": "\nexport function fromNullable<F>(F: Pointed<F>): <A>(a: A) => HKT<F, Option<NonNullable<A>>> {\n  return flow(O.fromNullable, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromNullableK<F extends URIS4>(\n  F: Pointed4<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => <S, R, E>(...a: A) => Kind4<F, S, R, E, Option<NonNullable<B>>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => <S, R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 93,
        "to": 97
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F extends URIS3>(\n  F: Pointed3<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => <R, E>(...a: A) => Kind3<F, R, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => <R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 98,
        "to": 102
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F extends URIS3, E>(\n  F: Pointed3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => <R>(...a: A) => Kind3<F, R, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 103,
        "to": 107
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F extends URIS2>(\n  F: Pointed2<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => <E>(...a: A) => Kind2<F, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => <E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 108,
        "to": 112
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F extends URIS2, E>(\n  F: Pointed2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => Kind2<F, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 113,
        "to": 117
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F extends URIS>(\n  F: Pointed1<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => Kind<F, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 118,
        "to": 122
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F>(\n  F: Pointed<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => HKT<F, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 123,
        "to": 127
      }
    }
  },
  {
    "name": "fromNullableK",
    "text": "\nexport function fromNullableK<F>(\n  F: Pointed<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n) => (...a: A) => HKT<F, Option<NonNullable<B>>> {\n  const fromNullableF = fromNullable(F)\n  return (f) => flow(f, fromNullableF)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => B) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 128,
        "to": 135
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chainNullableK<M extends URIS4>(\n  M: Monad4<M>\n): <A, B>(\n  f: (a: A) => B | null | undefined\n) => <S, R, E>(ma: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, Option<NonNullable<B>>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S, R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 140,
        "to": 144
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M extends URIS3>(\n  M: Monad3<M>\n): <A, B>(\n  f: (a: A) => B | null | undefined\n) => <R, E>(ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 145,
        "to": 149
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <A, B>(\n  f: (a: A) => B | null | undefined\n) => <R>(ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 150,
        "to": 154
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M extends URIS2>(\n  M: Monad2<M>\n): <A, B>(f: (a: A) => B | null | undefined) => <E>(ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 155,
        "to": 157
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 158,
        "to": 160
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind<M, Option<A>>) => Kind<M, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 161,
        "to": 163
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Option<A>>) => HKT<M, Option<NonNullable<B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 164,
        "to": 166
      }
    }
  },
  {
    "name": "chainNullableK",
    "text": "\nexport function chainNullableK<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Option<A>>) => HKT<M, Option<NonNullable<B>>> {\n  const chainM = chain(M)\n  const fromNullableKM = fromNullableK(M)\n  return (f) => chainM(fromNullableKM(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<NonNullable<B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 167,
        "to": 173
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromOptionK<F extends URIS4>(\n  F: Pointed4<F>\n): <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Option<B>\n) => <S, R, E>(...a: A) => Kind4<F, S, R, E, Option<B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <S, R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 178,
        "to": 182
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS3>(\n  F: Pointed3<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <R, E>(...a: A) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R, E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 183,
        "to": 185
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS3, E>(\n  F: Pointed3C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <R>(...a: A) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 186,
        "to": 188
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS2>(\n  F: Pointed2<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => <E>(...a: A) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <E>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 189,
        "to": 191
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS2, E>(\n  F: Pointed2C<F, E>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 192,
        "to": 194
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F extends URIS>(\n  F: Pointed1<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => Kind<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 195,
        "to": 197
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F>(\n  F: Pointed<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => HKT<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 198,
        "to": 200
      }
    }
  },
  {
    "name": "fromOptionK",
    "text": "\nexport function fromOptionK<F>(\n  F: Pointed<F>\n): <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => HKT<F, Option<B>> {\n  return (f) => flow(f, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends readonly unknown[], B>(f: (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 201,
        "to": 205
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chainOptionK<M extends URIS4>(\n  M: Monad4<M>\n): <A, B>(f: (a: A) => Option<B>) => <S, R, E>(ma: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, Option<B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <S, R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 210,
        "to": 212
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M extends URIS3>(\n  M: Monad3<M>\n): <A, B>(f: (a: A) => Option<B>) => <R, E>(ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 213,
        "to": 215
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <A, B>(f: (a: A) => Option<B>) => <R>(ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 216,
        "to": 218
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M extends URIS2>(\n  M: Monad2<M>\n): <A, B>(f: (a: A) => Option<B>) => <E>(ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => <E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 219,
        "to": 221
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(f: (a: A) => Option<B>) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 222,
        "to": 224
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(f: (a: A) => Option<B>) => (ma: Kind<M, Option<A>>) => Kind<M, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 225,
        "to": 227
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => Option<B>) => (ma: HKT<M, Option<A>>) => HKT<M, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 228,
        "to": 230
      }
    }
  },
  {
    "name": "chainOptionK",
    "text": "\nexport function chainOptionK<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => Option<B>) => (ma: HKT<M, Option<A>>) => HKT<M, Option<B>> {\n  const chainM = chain(M)\n  const fromOptionKM = fromOptionK(M)\n  return (f) => chainM(fromOptionKM(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 231,
        "to": 237
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromPredicate<F extends URIS4>(\n  F: Pointed4<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <S, R, E>(a: A) => Kind4<F, S, R, E, Option<B>>\n  <A>(predicate: Predicate<A>): <S, R, E>(a: A) => Kind4<F, S, R, E, Option<A>>\n}",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): <S, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): <S, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 242,
        "to": 247
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS3>(\n  F: Pointed3<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <R, E>(a: A) => Kind3<F, R, E, Option<B>>\n  <A>(predicate: Predicate<A>): <R, E>(a: A) => Kind3<F, R, E, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): <R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): <R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 248,
        "to": 253
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS3, E>(\n  F: Pointed3C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <R>(a: A) => Kind3<F, R, E, Option<B>>\n  <A>(predicate: Predicate<A>): <R>(a: A) => Kind3<F, R, E, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): <R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 254,
        "to": 259
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS2>(\n  F: Pointed2<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): <E>(a: A) => Kind2<F, E, Option<B>>\n  <A>(predicate: Predicate<A>): <E>(a: A) => Kind2<F, E, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): <E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): <E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 260,
        "to": 265
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS2, E>(\n  F: Pointed2C<F, E>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Kind2<F, E, Option<B>>\n  <A>(predicate: Predicate<A>): (a: A) => Kind2<F, E, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 266,
        "to": 271
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F extends URIS>(\n  F: Pointed1<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Kind<F, Option<B>>\n  <A>(predicate: Predicate<A>): (a: A) => Kind<F, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 272,
        "to": 277
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F>(\n  F: Pointed<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => HKT<F, Option<B>>\n  <A>(predicate: Predicate<A>): (a: A) => HKT<F, Option<A>>\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 278,
        "to": 283
      }
    }
  },
  {
    "name": "fromPredicate",
    "text": "\nexport function fromPredicate<F>(\n  F: Pointed<F>\n): {\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => HKT<F, Option<B>>\n  <A>(predicate: Predicate<A>): (a: A) => HKT<F, Option<A>>\n} {\n  return <A>(predicate: Predicate<A>) => (a: A) => F.of(O.fromPredicate(predicate)(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A, B extends A>(refinement: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>; <A>(predicate: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>): (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 284,
        "to": 291
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromEither<F extends URIS4>(\n  F: Pointed4<F>\n): <A, S, R, E>(e: Either<unknown, A>) => Kind4<F, S, R, E, Option<A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 296,
        "to": 298
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS3>(\n  F: Pointed3<F>\n): <A, R, E>(e: Either<unknown, A>) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 299,
        "to": 301
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS3, E>(\n  F: Pointed3C<F, E>\n): <A, R>(e: Either<unknown, A>) => Kind3<F, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 302,
        "to": 304
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS2>(F: Pointed2<F>): <A, E>(e: Either<unknown, A>) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 305,
        "to": 305
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(e: Either<unknown, A>) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 306,
        "to": 306
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS2, E>(F: Pointed2C<F, E>): <A>(e: Either<unknown, A>) => Kind2<F, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 307,
        "to": 307
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F extends URIS>(F: Pointed1<F>): <A>(e: Either<unknown, A>) => Kind<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 308,
        "to": 308
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F>(F: Pointed<F>): <A>(e: Either<unknown, A>) => HKT<F, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 309,
        "to": 309
      }
    }
  },
  {
    "name": "fromEither",
    "text": "\nexport function fromEither<F>(F: Pointed<F>): <A>(e: Either<unknown, A>) => HKT<F, Option<A>> {\n  return flow(O.fromEither, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<unknown, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 310,
        "to": 312
      }
    }
  },
  {
    "name": "match",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function match<F extends URIS4>(\n  F: Functor4<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => <S, R, E>(ma: Kind4<F, S, R, E, Option<A>>) => Kind4<F, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => <S, R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 321,
        "to": 323
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS3>(\n  F: Functor3<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => <R, E>(ma: Kind3<F, R, E, Option<A>>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => <R, E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 324,
        "to": 326
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => <R>(ma: Kind3<F, R, E, Option<A>>) => Kind3<F, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 327,
        "to": 329
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS2>(\n  F: Functor2<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => <E>(ma: Kind2<F, E, Option<A>>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => <E>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 330,
        "to": 332
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: Kind2<F, E, Option<A>>) => Kind2<F, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 333,
        "to": 335
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS>(\n  F: Functor1<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: Kind<F, Option<A>>) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 336,
        "to": 338
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: HKT<F, Option<A>>) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 339,
        "to": 341
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: HKT<F, Option<A>>) => HKT<F, B> {\n  return (onNone, onSome) => (ma) => F.map(ma, O.match(onNone, onSome))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 342,
        "to": 346
      }
    }
  },
  {
    "name": "matchE",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function matchE<M extends URIS4>(\n  M: Chain4<M>\n): <S, R, E, B, A>(\n  onNone: () => Kind4<M, S, R, E, B>,\n  onSome: (a: A) => Kind4<M, S, R, E, B>\n) => (ma: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 351,
        "to": 356
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS3>(\n  M: Chain3<M>\n): <R, E, B, A>(\n  onNone: () => Kind3<M, R, E, B>,\n  onSome: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 357,
        "to": 362
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <R, B, A>(\n  onNone: () => Kind3<M, R, E, B>,\n  onSome: (a: A) => Kind3<M, R, E, B>\n) => (ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 363,
        "to": 368
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2>(\n  M: Chain2<M>\n): <E, B, A>(\n  onNone: () => Kind2<M, E, B>,\n  onSome: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 369,
        "to": 374
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <B, A>(\n  onNone: () => Kind2<M, E, B>,\n  onSome: (a: A) => Kind2<M, E, B>\n) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 375,
        "to": 380
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS>(\n  M: Chain1<M>\n): <B, A>(onNone: () => Kind<M, B>, onSome: (a: A) => Kind<M, B>) => (ma: Kind<M, Option<A>>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 381,
        "to": 383
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <B, A>(onNone: () => HKT<M, B>, onSome: (a: A) => HKT<M, B>) => (ma: HKT<M, Option<A>>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 384,
        "to": 386
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <B, A>(onNone: () => HKT<M, B>, onSome: (a: A) => HKT<M, B>) => (ma: HKT<M, Option<A>>) => HKT<M, B> {\n  return (onNone, onSome) => (ma) => M.chain(ma, O.match(onNone, onSome))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B, A>(onNone: () => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onSome: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 387,
        "to": 391
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function getOrElse<M extends URIS4>(\n  M: Monad4<M>\n): <S, R, E, A>(onNone: Lazy<Kind4<M, S, R, E, A>>) => (fa: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 396,
        "to": 398
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A>(onNone: Lazy<Kind3<M, R, E, A>>) => (fa: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 399,
        "to": 401
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A>(onNone: Lazy<Kind3<M, R, E, A>>) => (fa: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 402,
        "to": 404
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS2>(\n  M: Monad2<M>\n): <E, A>(onNone: Lazy<Kind2<M, E, A>>) => (fa: Kind2<M, E, Option<A>>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 405,
        "to": 407
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A>(onNone: Lazy<Kind2<M, E, A>>) => (fa: Kind2<M, E, Option<A>>) => Kind2<M, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 408,
        "to": 410
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M extends URIS>(\n  M: Monad1<M>\n): <A>(onNone: Lazy<Kind<M, A>>) => (fa: Kind<M, Option<A>>) => Kind<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 411,
        "to": 413
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M>(M: Monad<M>): <A>(onNone: Lazy<HKT<M, A>>) => (fa: HKT<M, Option<A>>) => HKT<M, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 414,
        "to": 414
      }
    }
  },
  {
    "name": "getOrElse",
    "text": "\nexport function getOrElse<M>(M: Monad<M>): <A>(onNone: Lazy<HKT<M, A>>) => (fa: HKT<M, Option<A>>) => HKT<M, A> {\n  return (onNone) => (fa) => M.chain(fa, O.match(onNone, M.of))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(onNone: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 415,
        "to": 417
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// type class members\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.10.0\n */\nexport function map<F extends URIS4>(\n  F: Functor4<F>\n): <A, B>(f: (a: A) => B) => <S, R, E>(fa: Kind4<F, S, R, E, Option<A>>) => Kind4<F, S, R, E, Option<B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S, R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 426,
        "to": 428
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, E, Option<A>>) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 429,
        "to": 431
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <A, B>(f: (a: A) => B) => <R>(fa: Kind3<F, R, E, Option<A>>) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 432,
        "to": 434
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, E, Option<A>>) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 435,
        "to": 437
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <A, B>(f: (a: A) => B) => (fa: Kind2<F, E, Option<A>>) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 438,
        "to": 440
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS>(\n  F: Functor1<F>\n): <A, B>(f: (a: A) => B) => (fa: Kind<F, Option<A>>) => Kind<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 441,
        "to": 443
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, Option<A>>) => HKT<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 444,
        "to": 444
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => (fa: HKT<F, Option<A>>) => HKT<F, Option<B>> {\n  return map_(F, O.Functor)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 445,
        "to": 447
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function ap<F extends URIS4>(\n  F: Apply4<F>\n): <S, R, E, A>(\n  fa: Kind4<F, S, R, E, Option<A>>\n) => <B>(fab: Kind4<F, S, R, E, Option<(a: A) => B>>) => Kind4<F, S, R, E, Option<B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 452,
        "to": 456
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3>(\n  F: Apply3<F>\n): <R, E, A>(\n  fa: Kind3<F, R, E, Option<A>>\n) => <B>(fab: Kind3<F, R, E, Option<(a: A) => B>>) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 457,
        "to": 461
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3, E>(\n  F: Apply3C<F, E>\n): <R, A>(fa: Kind3<F, R, E, Option<A>>) => <B>(fab: Kind3<F, R, E, Option<(a: A) => B>>) => Kind3<F, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 462,
        "to": 464
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2>(\n  F: Apply2<F>\n): <E, A>(fa: Kind2<F, E, Option<A>>) => <B>(fab: Kind2<F, E, Option<(a: A) => B>>) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 465,
        "to": 467
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2, E>(\n  F: Apply2C<F, E>\n): <A>(fa: Kind2<F, E, Option<A>>) => <B>(fab: Kind2<F, E, Option<(a: A) => B>>) => Kind2<F, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 468,
        "to": 470
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS>(\n  F: Apply1<F>\n): <A>(fa: Kind<F, Option<A>>) => <B>(fab: Kind<F, Option<(a: A) => B>>) => Kind<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 471,
        "to": 473
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <A>(fa: HKT<F, Option<A>>) => <B>(fab: HKT<F, Option<(a: A) => B>>) => HKT<F, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 474,
        "to": 476
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <A>(fa: HKT<F, Option<A>>) => <B>(fab: HKT<F, Option<(a: A) => B>>) => HKT<F, Option<B>> {\n  return ap_(F, O.Apply)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<(a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 477,
        "to": 481
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chain<M extends URIS4>(\n  M: Monad4<M>\n): <A, S, R, E, B>(\n  f: (a: A) => Kind4<M, S, R, E, Option<B>>\n) => (ma: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, Option<B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 486,
        "to": 490
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3>(\n  M: Monad3<M>\n): <A, R, E, B>(f: (a: A) => Kind3<M, R, E, Option<B>>) => (ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 491,
        "to": 493
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <A, R, B>(f: (a: A) => Kind3<M, R, E, Option<B>>) => (ma: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 494,
        "to": 496
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2>(\n  M: Monad2<M>\n): <A, E, B>(f: (a: A) => Kind2<M, E, Option<B>>) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 497,
        "to": 499
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(f: (a: A) => Kind2<M, E, Option<B>>) => (ma: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 500,
        "to": 502
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(f: (a: A) => Kind<M, Option<B>>) => (ma: Kind<M, Option<A>>) => Kind<M, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 503,
        "to": 505
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => HKT<M, Option<B>>) => (ma: HKT<M, Option<A>>) => HKT<M, Option<B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 506,
        "to": 508
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Monad<M>\n): <A, B>(f: (a: A) => HKT<M, Option<B>>) => (ma: HKT<M, Option<A>>) => HKT<M, Option<B>> {\n  const zeroM = zero(M)\n  return (f) => (ma) =>\n    M.chain(\n      ma,\n      O.match(() => zeroM(), f)\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 509,
        "to": 518
      }
    }
  },
  {
    "name": "alt",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function alt<M extends URIS4>(\n  M: Monad4<M>\n): <S, R, E, A>(\n  second: Lazy<Kind4<M, S, R, E, Option<A>>>\n) => (first: Kind4<M, S, R, E, Option<A>>) => Kind4<M, S, R, E, Option<A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 523,
        "to": 527
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A>(second: Lazy<Kind3<M, R, E, Option<A>>>) => (first: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 528,
        "to": 530
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A>(second: Lazy<Kind3<M, R, E, Option<A>>>) => (first: Kind3<M, R, E, Option<A>>) => Kind3<M, R, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 531,
        "to": 533
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS2>(\n  M: Monad2<M>\n): <E, A>(second: Lazy<Kind2<M, E, Option<A>>>) => (first: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 534,
        "to": 536
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A>(second: Lazy<Kind2<M, E, Option<A>>>) => (first: Kind2<M, E, Option<A>>) => Kind2<M, E, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 537,
        "to": 539
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M extends URIS>(\n  M: Monad1<M>\n): <A>(second: Lazy<Kind<M, Option<A>>>) => (first: Kind<M, Option<A>>) => Kind<M, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 540,
        "to": 542
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M>(\n  M: Monad<M>\n): <A>(second: Lazy<HKT<M, Option<A>>>) => (first: HKT<M, Option<A>>) => HKT<M, Option<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 543,
        "to": 545
      }
    }
  },
  {
    "name": "alt",
    "text": "\nexport function alt<M>(\n  M: Monad<M>\n): <A>(second: Lazy<HKT<M, Option<A>>>) => (first: HKT<M, Option<A>>) => HKT<M, Option<A>> {\n  const _some = some(M)\n  return (second) => (first) => M.chain(first, O.match(second, _some))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(second: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>) => (first: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 546,
        "to": 551
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport function getOptionM<M extends URIS2>(M: Monad2<M>): OptionM2<M>",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 644,
        "to": 644
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n/** @deprecated */\nexport function getOptionM<M extends URIS2, E>(M: Monad2C<M, E>): OptionM2C<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 646,
        "to": 646
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n/** @deprecated */\nexport function getOptionM<M extends URIS>(M: Monad1<M>): OptionM1<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 648,
        "to": 648
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n/** @deprecated */\nexport function getOptionM<M>(M: Monad<M>): OptionM<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 650,
        "to": 650
      }
    }
  },
  {
    "name": "getOptionM",
    "text": "\n/** @deprecated */\nexport function getOptionM<M>(M: Monad<M>): OptionM<M> {\n  const apM = ap(M)\n  const mapM = map(M)\n  const chainM = chain(M)\n  const altM = alt(M)\n  const foldM = matchE(M)\n  const getOrElseM = getOrElse(M)\n  const zeroM = zero(M)\n\n  return {\n    map: (fa, f) => pipe(fa, mapM(f)),\n    ap: (fab, fa) => pipe(fab, apM(fa)),\n    of: some(M),\n    chain: (ma, f) => pipe(ma, chainM(f)),\n    alt: (fa, that) => pipe(fa, altM(that)),\n    fold: (fa, onNone, onSome) => pipe(fa, foldM(onNone, onSome)),\n    getOrElse: (fa, onNone) => pipe(fa, getOrElseM(onNone)),\n    fromM: fromF(M),\n    none: () => zeroM()\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/OptionT\").OptionM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/OptionT.ts",
      "lines": {
        "from": 652,
        "to": 672
      }
    }
  },
  {
    "name": "equalsDefault",
    "text": "const equalsDefault = <A>(compare: Ord<A>['compare']): Eq<A>['equals'] => (first, second) =>\n  first === second || compare(first, second) === 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "compare",
          "type": {
            "__tag": "Other",
            "values": "(first: A, second: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: A, y: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 39,
        "to": 40
      }
    }
  },
  {
    "name": "fromCompare",
    "text": "const fromCompare = <A>(compare: Ord<A>['compare']): Ord<A> => ({\n  equals: equalsDefault(compare),\n  compare: (first, second) => (first === second ? 0 : compare(first, second))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "compare",
          "type": {
            "__tag": "Other",
            "values": "(first: A, second: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 50,
        "to": 53
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(...ords: { [K in keyof A]: Ord<A[K]> }): Ord<Readonly<A>> =>\n  fromCompare((first, second) => {\n    let i = 0\n    for (; i < ords.length - 1; i++) {\n      const r = ords[i].compare(first[i], second[i])\n      if (r !== 0) {\n        return r\n      }\n    }\n    return ords[i].compare(first[i], second[i])\n  })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 76,
        "to": 86
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(O: Ord<A>): Ord<A> => fromCompare((first, second) => O.compare(second, first))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "contramap",
    "text": "const contramap: <A, B>(f: (b: B) => A) => (fa: Ord<A>) => Ord<B> = (f) => (fa) =>\n  fromCompare((first, second) => fa.compare(f(first), f(second)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 109,
        "to": 110
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A = never>(): Semigroup<Ord<A>> => ({\n  concat: (first, second) =>\n    fromCompare((a, b) => {\n      const ox = first.compare(a, b)\n      return ox !== 0 ? ox : second.compare(a, b)\n    })\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 138,
        "to": 144
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <A = never>(): Monoid<Ord<A>> => ({\n  concat: getSemigroup<A>().concat,\n  empty: fromCompare(() => 0)\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 213,
        "to": 216
      }
    }
  },
  {
    "name": "lt",
    "text": "const lt = <A>(O: Ord<A>) => (first: A, second: A): boolean => O.compare(first, second) === -1",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 237,
        "to": 237
      }
    }
  },
  {
    "name": "gt",
    "text": "const gt = <A>(O: Ord<A>) => (first: A, second: A): boolean => O.compare(first, second) === 1",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 245,
        "to": 245
      }
    }
  },
  {
    "name": "leq",
    "text": "const leq = <A>(O: Ord<A>) => (first: A, second: A): boolean => O.compare(first, second) !== 1",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 253,
        "to": 253
      }
    }
  },
  {
    "name": "geq",
    "text": "const geq = <A>(O: Ord<A>) => (first: A, second: A): boolean => O.compare(first, second) !== -1",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 261,
        "to": 261
      }
    }
  },
  {
    "name": "min",
    "text": "const min = <A>(O: Ord<A>) => (first: A, second: A): A =>\n  first === second || O.compare(first, second) < 1 ? first : second",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 269,
        "to": 270
      }
    }
  },
  {
    "name": "max",
    "text": "const max = <A>(O: Ord<A>) => (first: A, second: A): A =>\n  first === second || O.compare(first, second) > -1 ? first : second",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(first: A, second: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 278,
        "to": 279
      }
    }
  },
  {
    "name": "clamp",
    "text": "const clamp = <A>(O: Ord<A>): ((low: A, hi: A) => (a: A) => A) => {\n  const minO = min(O)\n  const maxO = max(O)\n  return (low, hi) => (a) => maxO(minO(a, hi), low)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(low: A, hi: A) => (a: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 286,
        "to": 290
      }
    }
  },
  {
    "name": "between",
    "text": "const between = <A>(O: Ord<A>): ((low: A, hi: A) => (a: A) => boolean) => {\n  const ltO = lt(O)\n  const gtO = gt(O)\n  return (low, hi) => (a) => (ltO(a, low) || gtO(a, hi) ? false : true)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(low: A, hi: A) => (a: A) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ord.ts",
      "lines": {
        "from": 297,
        "to": 301
      }
    }
  },
  {
    "name": "match",
    "text": "const match = <A>(onLessThan: () => A, onEqual: () => A, onGreaterThan: () => A) => (o: Ordering): A =>\n  o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLessThan",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        },
        {
          "name": "onEqual",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        },
        {
          "name": "onGreaterThan",
          "type": {
            "__tag": "Other",
            "values": "() => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(o: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ordering.ts",
      "lines": {
        "from": 26,
        "to": 27
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = (o: Ordering): Ordering => (o === -1 ? 1 : o === 1 ? -1 : 0)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "o",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ordering.ts",
      "lines": {
        "from": 37,
        "to": 37
      }
    }
  },
  {
    "name": "sign",
    "text": "const sign = (n: number): Ordering => (n <= -1 ? -1 : n >= 1 ? 1 : 0)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ordering\").Ordering"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ordering.ts",
      "lines": {
        "from": 75,
        "to": 75
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport function pipeable<F extends URIS4, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain4<F>\n  ? PipeableChain4<F>\n  : I extends Apply4<F>\n  ? PipeableApply4<F>\n  : I extends Functor4<F>\n  ? PipeableFunctor4<F>\n  : {}) &\n  (I extends Contravariant4<F> ? PipeableContravariant4<F> : {}) &\n  (I extends FunctorWithIndex4<F, infer Ix> ? PipeableFunctorWithIndex4<F, Ix> : {}) &\n  (I extends Bifunctor4<F> ? PipeableBifunctor4<F> : {}) &\n  (I extends Extend4<F> ? PipeableExtend4<F> : {}) &\n  (I extends FoldableWithIndex4<F, infer Ix>\n    ? PipeableFoldableWithIndex4<F, Ix>\n    : I extends Foldable4<F>\n    ? PipeableFoldable4<F>\n    : {}) &\n  (I extends Alt4<F> ? PipeableAlt4<F> : {}) &\n  (I extends FilterableWithIndex4<F, infer Ix>\n    ? PipeableFilterableWithIndex4<F, Ix>\n    : I extends Filterable4<F>\n    ? PipeableFilterable4<F>\n    : I extends Compactable4<F>\n    ? PipeableCompactable4<F>\n    : {}) &\n  (I extends Profunctor4<F> ? PipeableProfunctor4<F> : {}) &\n  (I extends Semigroupoid4<F> ? PipeableSemigroupoid4<F> : {}) &\n  (I extends MonadThrow4<F> ? PipeableMonadThrow4<F> : {})",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex4<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex4<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex4<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex4<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable4<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid4<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow4<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow4<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1332,
        "to": 1360
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F extends URIS3, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain3<F>\n  ? PipeableChain3<F>\n  : I extends Apply3<F>\n  ? PipeableApply3<F>\n  : I extends Functor3<F>\n  ? PipeableFunctor3<F>\n  : {}) &\n  (I extends Contravariant3<F> ? PipeableContravariant3<F> : {}) &\n  (I extends FunctorWithIndex3<F, infer Ix> ? PipeableFunctorWithIndex3<F, Ix> : {}) &\n  (I extends Bifunctor3<F> ? PipeableBifunctor3<F> : {}) &\n  (I extends Extend3<F> ? PipeableExtend3<F> : {}) &\n  (I extends FoldableWithIndex3<F, infer Ix>\n    ? PipeableFoldableWithIndex3<F, Ix>\n    : I extends Foldable3<F>\n    ? PipeableFoldable3<F>\n    : {}) &\n  (I extends Alt3<F> ? PipeableAlt3<F> : {}) &\n  (I extends FilterableWithIndex3<F, infer Ix>\n    ? PipeableFilterableWithIndex3<F, Ix>\n    : I extends Filterable3<F>\n    ? PipeableFilterable3<F>\n    : I extends Compactable3<F>\n    ? PipeableCompactable3<F>\n    : {}) &\n  (I extends Profunctor3<F> ? PipeableProfunctor3<F> : {}) &\n  (I extends Semigroupoid3<F> ? PipeableSemigroupoid3<F> : {}) &\n  (I extends MonadThrow3<F> ? PipeableMonadThrow3<F> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex3<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex3<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex3<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex3<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable3<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid3<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow3<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1362,
        "to": 1390
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F extends URIS3, I, E>(\n  I: { readonly URI: F } & I\n): (I extends Chain3C<F, E>\n  ? PipeableChain3C<F, E>\n  : I extends Apply3C<F, E>\n  ? PipeableApply3C<F, E>\n  : I extends Functor3C<F, E>\n  ? PipeableFunctor3C<F, E>\n  : {}) &\n  (I extends Contravariant3C<F, E> ? PipeableContravariant3C<F, E> : {}) &\n  (I extends FunctorWithIndex3C<F, infer Ix, E> ? PipeableFunctorWithIndex3C<F, Ix, E> : {}) &\n  (I extends Bifunctor3C<F, E> ? PipeableBifunctor3C<F, E> : {}) &\n  (I extends Extend3C<F, E> ? PipeableExtend3C<F, E> : {}) &\n  (I extends FoldableWithIndex3C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex3C<F, Ix, E>\n    : I extends Foldable3C<F, E>\n    ? PipeableFoldable3C<F, E>\n    : {}) &\n  (I extends Alt3C<F, E> ? PipeableAlt3C<F, E> : {}) &\n  (I extends FilterableWithIndex3C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex3C<F, Ix, E>\n    : I extends Filterable3C<F, E>\n    ? PipeableFilterable3C<F, E>\n    : I extends Compactable3C<F, E>\n    ? PipeableCompactable3C<F, E>\n    : {}) &\n  (I extends Profunctor3C<F, E> ? PipeableProfunctor3C<F, E> : {}) &\n  (I extends Semigroupoid3C<F, E> ? PipeableSemigroupoid3C<F, E> : {}) &\n  (I extends MonadThrow3C<F, E> ? PipeableMonadThrow3C<F, E> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex3C<F, Ix, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex3C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex3C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex3C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable3C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid3C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow3C<F, E> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1392,
        "to": 1420
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F extends URIS2, I, E>(\n  I: { readonly URI: F; readonly _E: E } & I\n): (I extends Chain2C<F, E>\n  ? PipeableChain2C<F, E>\n  : I extends Apply2C<F, E>\n  ? PipeableApply2C<F, E>\n  : I extends Functor2C<F, E>\n  ? PipeableFunctor2C<F, E>\n  : {}) &\n  (I extends Contravariant2C<F, E> ? PipeableContravariant2C<F, E> : {}) &\n  (I extends FunctorWithIndex2C<F, infer Ix, E> ? PipeableFunctorWithIndex2C<F, Ix, E> : {}) &\n  (I extends Extend2C<F, E> ? PipeableExtend2C<F, E> : {}) &\n  (I extends FoldableWithIndex2C<F, infer Ix, E>\n    ? PipeableFoldableWithIndex2C<F, Ix, E>\n    : I extends Foldable2C<F, E>\n    ? PipeableFoldable2C<F, E>\n    : {}) &\n  (I extends Alt2C<F, E> ? PipeableAlt2C<F, E> : {}) &\n  (I extends FilterableWithIndex2C<F, infer Ix, E>\n    ? PipeableFilterableWithIndex2C<F, Ix, E>\n    : I extends Filterable2C<F, E>\n    ? PipeableFilterable2C<F, E>\n    : I extends Compactable2C<F, E>\n    ? PipeableCompactable2C<F, E>\n    : {}) &\n  (I extends Profunctor2C<F, E> ? PipeableProfunctor2C<F, E> : {}) &\n  (I extends Semigroupoid2C<F, E> ? PipeableSemigroupoid2C<F, E> : {}) &\n  (I extends MonadThrow2C<F, E> ? PipeableMonadThrow2C<F, E> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; readonly _E: E; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex2C<F, Ix, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex2C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2C<F, infer Ix, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex2C<F, Ix, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable2C<F, E> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid2C<F, E> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<F, E> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow2C<F, E> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1422,
        "to": 1449
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F extends URIS2, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain2<F>\n  ? PipeableChain2<F>\n  : I extends Apply2<F>\n  ? PipeableApply2<F>\n  : I extends Functor2<F>\n  ? PipeableFunctor2<F>\n  : {}) &\n  (I extends Contravariant2<F> ? PipeableContravariant2<F> : {}) &\n  (I extends FunctorWithIndex2<F, infer Ix> ? PipeableFunctorWithIndex2<F, Ix> : {}) &\n  (I extends Bifunctor2<F> ? PipeableBifunctor2<F> : {}) &\n  (I extends Extend2<F> ? PipeableExtend2<F> : {}) &\n  (I extends FoldableWithIndex2<F, infer Ix>\n    ? PipeableFoldableWithIndex2<F, Ix>\n    : I extends Foldable2<F>\n    ? PipeableFoldable2<F>\n    : {}) &\n  (I extends Alt2<F> ? PipeableAlt2<F> : {}) &\n  (I extends FilterableWithIndex2<F, infer Ix>\n    ? PipeableFilterableWithIndex2<F, Ix>\n    : I extends Filterable2<F>\n    ? PipeableFilterable2<F>\n    : I extends Compactable2<F>\n    ? PipeableCompactable2<F>\n    : {}) &\n  (I extends Profunctor2<F> ? PipeableProfunctor2<F> : {}) &\n  (I extends Semigroupoid2<F> ? PipeableSemigroupoid2<F> : {}) &\n  (I extends MonadThrow2<F> ? PipeableMonadThrow2<F> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex2<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex2<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex2<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable2<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid2<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow2<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1451,
        "to": 1479
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F extends URIS, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain1<F>\n  ? PipeableChain1<F>\n  : I extends Apply1<F>\n  ? PipeableApply1<F>\n  : I extends Functor1<F>\n  ? PipeableFunctor1<F>\n  : {}) &\n  (I extends Contravariant1<F> ? PipeableContravariant1<F> : {}) &\n  (I extends FunctorWithIndex1<F, infer Ix> ? PipeableFunctorWithIndex1<F, Ix> : {}) &\n  (I extends Extend1<F> ? PipeableExtend1<F> : {}) &\n  (I extends FoldableWithIndex1<F, infer Ix>\n    ? PipeableFoldableWithIndex1<F, Ix>\n    : I extends Foldable1<F>\n    ? PipeableFoldable1<F>\n    : {}) &\n  (I extends Alt1<F> ? PipeableAlt1<F> : {}) &\n  (I extends FilterableWithIndex1<F, infer Ix>\n    ? PipeableFilterableWithIndex1<F, Ix>\n    : I extends Filterable1<F>\n    ? PipeableFilterable1<F>\n    : I extends Compactable1<F>\n    ? PipeableCompactable1<F>\n    : {}) &\n  (I extends MonadThrow1<F> ? PipeableMonadThrow1<F> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex1<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex1<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex1<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex1<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable1<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable1<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow1<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow1<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1481,
        "to": 1506
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F, I>(\n  I: { readonly URI: F } & I\n): (I extends Chain<F>\n  ? PipeableChain<F>\n  : I extends Apply<F>\n  ? PipeableApply<F>\n  : I extends Functor<F>\n  ? PipeableFunctor<F>\n  : {}) &\n  (I extends Contravariant<F> ? PipeableContravariant<F> : {}) &\n  (I extends FunctorWithIndex<F, infer Ix> ? PipeableFunctorWithIndex<F, Ix> : {}) &\n  (I extends Bifunctor<F> ? PipeableBifunctor<F> : {}) &\n  (I extends Extend<F> ? PipeableExtend<F> : {}) &\n  (I extends FoldableWithIndex<F, infer Ix>\n    ? PipeableFoldableWithIndex<F, Ix>\n    : I extends Foldable<F>\n    ? PipeableFoldable<F>\n    : {}) &\n  (I extends Alt<F> ? PipeableAlt<F> : {}) &\n  (I extends FilterableWithIndex<F, infer Ix>\n    ? PipeableFilterableWithIndex<F, Ix>\n    : I extends Filterable<F>\n    ? PipeableFilterable<F>\n    : I extends Compactable<F>\n    ? PipeableCompactable<F>\n    : {}) &\n  (I extends Profunctor<F> ? PipeableProfunctor<F> : {}) &\n  (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) &\n  (I extends MonadThrow<F> ? PipeableMonadThrow<F> : {})",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableChain<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableApply<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Contravariant\").Contravariant<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableContravariant<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFunctorWithIndex<F, Ix> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableBifunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Extend\").Extend<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableExtend<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldableWithIndex<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFoldable<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableAlt<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex<F, infer Ix> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterableWithIndex<F, Ix> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableFilterable<F> : I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableCompactable<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Profunctor\").Profunctor<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableProfunctor<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroupoid\").Semigroupoid<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableSemigroupoid<F> : {}) & (I extends import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow<F> ? import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/pipeable\").PipeableMonadThrow<F> : {})"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1508,
        "to": 1536
      }
    }
  },
  {
    "name": "pipeable",
    "text": "\n/** @deprecated */\nexport function pipeable<F, I>(I: { readonly URI: F } & I): Record<string, unknown> {\n  const r: any = {}\n  if (isFunctor<F>(I)) {\n    const map: PipeableFunctor<F>['map'] = (f) => (fa) => I.map(fa, f)\n    r.map = map\n  }\n  if (isContravariant<F>(I)) {\n    const contramap: PipeableContravariant<F>['contramap'] = (f) => (fa) => I.contramap(fa, f)\n    r.contramap = contramap\n  }\n  if (isFunctorWithIndex<F>(I)) {\n    const mapWithIndex: PipeableFunctorWithIndex<F, unknown>['mapWithIndex'] = (f) => (fa) => I.mapWithIndex(fa, f)\n    r.mapWithIndex = mapWithIndex\n  }\n  if (isApply<F>(I)) {\n    const ap: PipeableApply<F>['ap'] = (fa) => (fab) => I.ap(fab, fa)\n    const apFirst: PipeableApply<F>['apFirst'] = (fb) => (fa) =>\n      I.ap(\n        I.map(fa, (a) => () => a),\n        fb\n      )\n    r.ap = ap\n    r.apFirst = apFirst\n    r.apSecond = <B>(fb: HKT<F, B>) => <A>(fa: HKT<F, A>): HKT<F, B> =>\n      I.ap(\n        I.map(fa, () => (b: B) => b),\n        fb\n      )\n  }\n  if (isChain<F>(I)) {\n    const chain: PipeableChain<F>['chain'] = (f) => (ma) => I.chain(ma, f)\n    const chainFirst: PipeableChain<F>['chainFirst'] = (f) => (ma) => I.chain(ma, (a) => I.map(f(a), () => a))\n    const flatten: PipeableChain<F>['flatten'] = (mma) => I.chain(mma, identity)\n    r.chain = chain\n    r.chainFirst = chainFirst\n    r.flatten = flatten\n  }\n  if (isBifunctor<F>(I)) {\n    const bimap: PipeableBifunctor<F>['bimap'] = (f, g) => (fa) => I.bimap(fa, f, g)\n    const mapLeft: PipeableBifunctor<F>['mapLeft'] = (f) => (fa) => I.mapLeft(fa, f)\n    r.bimap = bimap\n    r.mapLeft = mapLeft\n  }\n  if (isExtend<F>(I)) {\n    const extend: PipeableExtend<F>['extend'] = (f) => (wa) => I.extend(wa, f)\n    const duplicate: PipeableExtend<F>['duplicate'] = (wa) => I.extend(wa, identity)\n    r.extend = extend\n    r.duplicate = duplicate\n  }\n  if (isFoldable<F>(I)) {\n    const reduce: PipeableFoldable<F>['reduce'] = (b, f) => (fa) => I.reduce(fa, b, f)\n    const foldMap: PipeableFoldable<F>['foldMap'] = (M) => {\n      const foldMapM = I.foldMap(M)\n      return (f) => (fa) => foldMapM(fa, f)\n    }\n    const reduceRight: PipeableFoldable<F>['reduceRight'] = (b, f) => (fa) => I.reduceRight(fa, b, f)\n    r.reduce = reduce\n    r.foldMap = foldMap\n    r.reduceRight = reduceRight\n  }\n  if (isFoldableWithIndex<F>(I)) {\n    const reduceWithIndex: PipeableFoldableWithIndex<F, unknown>['reduceWithIndex'] = (b, f) => (fa) =>\n      I.reduceWithIndex(fa, b, f)\n    const foldMapWithIndex: PipeableFoldableWithIndex<F, unknown>['foldMapWithIndex'] = (M) => {\n      const foldMapM = I.foldMapWithIndex(M)\n      return (f) => (fa) => foldMapM(fa, f)\n    }\n    const reduceRightWithIndex: PipeableFoldableWithIndex<F, unknown>['reduceRightWithIndex'] = (b, f) => (fa) =>\n      I.reduceRightWithIndex(fa, b, f)\n    r.reduceWithIndex = reduceWithIndex\n    r.foldMapWithIndex = foldMapWithIndex\n    r.reduceRightWithIndex = reduceRightWithIndex\n  }\n  if (isAlt<F>(I)) {\n    const alt: PipeableAlt<F>['alt'] = (that) => (fa) => I.alt(fa, that)\n    r.alt = alt\n  }\n  if (isCompactable<F>(I)) {\n    r.compact = I.compact\n    r.separate = I.separate\n  }\n  if (isFilterable<F>(I)) {\n    const filter: PipeableFilterable<F>['filter'] = <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) =>\n      I.filter(fa, predicate)\n    const filterMap: PipeableFilterable<F>['filterMap'] = (f) => (fa) => I.filterMap(fa, f)\n    const partition: PipeableFilterable<F>['partition'] = <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) =>\n      I.partition(fa, predicate)\n    const partitionMap: PipeableFilterable<F>['partitionMap'] = (f) => (fa) => I.partitionMap(fa, f)\n    r.filter = filter\n    r.filterMap = filterMap\n    r.partition = partition\n    r.partitionMap = partitionMap\n  }\n  if (isFilterableWithIndex<F>(I)) {\n    const filterWithIndex: PipeableFilterableWithIndex<F, unknown>['filterWithIndex'] = <A>(\n      predicateWithIndex: PredicateWithIndex<unknown, A>\n    ) => (fa: HKT<F, A>) => I.filterWithIndex(fa, predicateWithIndex)\n    const filterMapWithIndex: PipeableFilterableWithIndex<F, unknown>['filterMapWithIndex'] = (f) => (fa) =>\n      I.filterMapWithIndex(fa, f)\n    const partitionWithIndex: PipeableFilterableWithIndex<F, unknown>['partitionWithIndex'] = <A>(\n      predicateWithIndex: PredicateWithIndex<unknown, A>\n    ) => (fa: HKT<F, A>) => I.partitionWithIndex(fa, predicateWithIndex)\n    const partitionMapWithIndex: PipeableFilterableWithIndex<F, unknown>['partitionMapWithIndex'] = (f) => (fa) =>\n      I.partitionMapWithIndex(fa, f)\n    r.filterWithIndex = filterWithIndex\n    r.filterMapWithIndex = filterMapWithIndex\n    r.partitionWithIndex = partitionWithIndex\n    r.partitionMapWithIndex = partitionMapWithIndex\n  }\n  if (isProfunctor<F>(I)) {\n    const promap: PipeableProfunctor<F>['promap'] = (f, g) => (fa) => I.promap(fa, f, g)\n    r.promap = promap\n  }\n  if (isSemigroupoid<F>(I)) {\n    const compose: PipeableSemigroupoid<F>['compose'] = (that) => (fa) => I.compose(fa, that)\n    r.compose = compose\n  }\n  if (isMonadThrow<F>(I)) {\n    const fromOption: PipeableMonadThrow<F>['fromOption'] = (onNone) => (ma) =>\n      ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value)\n    const fromEither: PipeableMonadThrow<F>['fromEither'] = (ma) =>\n      ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right)\n    const fromPredicate: PipeableMonadThrow<F>['fromPredicate'] = <E, A>(\n      predicate: Predicate<A>,\n      onFalse: (a: A) => E\n    ) => (a: A) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a)))\n    const filterOrElse: PipeableMonadThrow<F>['filterOrElse'] = <E, A>(\n      predicate: Predicate<A>,\n      onFalse: (a: A) => E\n    ) => (ma: HKT<F, A>) => I.chain(ma, (a) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a))))\n    r.fromOption = fromOption\n    r.fromEither = fromEither\n    r.fromPredicate = fromPredicate\n    r.filterOrElse = filterOrElse\n  }\n  return r\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "I",
          "type": {
            "__tag": "Other",
            "values": "{ readonly URI: F; } & I"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<string, unknown>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/pipeable.ts",
      "lines": {
        "from": 1538,
        "to": 1674
      }
    }
  },
  {
    "name": "randomInt",
    "text": "\n\n/**\n * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly\n * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of\n * `low` or `high` is not an integer.\n *\n * @since 2.0.0\n */\nexport function randomInt(low: number, high: number): IO<number> {\n  return pipe(\n    random,\n    map((n) => Math.floor((high - low + 1) * n + low))\n  )\n}",
    "docs": "/**\n * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly\n * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of\n * `low` or `high` is not an integer.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "low",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "high",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 23,
        "to": 28
      }
    }
  },
  {
    "name": "randomRange",
    "text": "\n\n/**\n * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what\n * happens if `maximum < minimum`.\n *\n * @since 2.0.0\n */\nexport function randomRange(min: number, max: number): IO<number> {\n  return pipe(\n    random,\n    map((n) => (max - min) * n + min)\n  )\n}",
    "docs": "/**\n * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what\n * happens if `maximum < minimum`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "min",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "max",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 36,
        "to": 41
      }
    }
  },
  {
    "name": "random",
    "text": "const random: IO<number> = () => Math.random()",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 14,
        "to": 14
      }
    }
  },
  {
    "name": "randomElem",
    "text": "const randomElem = <A>(as: ReadonlyNonEmptyArray<A>): IO<A> =>\n  pipe(\n    randomInt(0, as.length - 1),\n    map((i) => as[i])\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Random.ts",
      "lines": {
        "from": 60,
        "to": 64
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R>() => Reader<R, R> = () => identity",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "typeof import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").identity"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 41,
        "to": 41
      }
    }
  },
  {
    "name": "local",
    "text": "const local: <R2, R1>(f: (r2: R2) => R1) => <A>(ma: Reader<R1, A>) => Reader<R2, A> = (f) => (ma) => (r2) =>\n  ma(f(r2))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r2: R2) => R1"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R1, A>) => (r2: R2) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 62,
        "to": 63
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, A>) => Reader<R, B> = (f) => (fa) => (r) => f(fa(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => (r: R) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 89,
        "to": 89
      }
    }
  },
  {
    "name": "apW",
    "text": "const apW: <R2, A>(fa: Reader<R2, A>) => <R1, B>(fab: Reader<R1, (a: A) => B>) => Reader<R1 & R2, B> = (fa) => (\n  fab\n) => (r) => fab(r)(fa(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R2, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R1, (a: A) => B>) => (r: R1 & R2) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 97,
        "to": 99
      }
    }
  },
  {
    "name": "chainW",
    "text": "const chainW: <R2, A, B>(f: (a: A) => Reader<R2, B>) => <R1>(ma: Reader<R1, A>) => Reader<R1 & R2, B> = (f) => (\n  fa\n) => (r) => f(fa(r))(r)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R1, A>) => (r: R1 & R2) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 121,
        "to": 123
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <A, B>(ab: Reader<A, B>) => <C>(bc: Reader<B, C>) => Reader<A, C> = (ab) => (bc) => flow(ab, bc)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<C>(bc: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<B, C>) => (r: A) => C"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 147,
        "to": 147
      }
    }
  },
  {
    "name": "promap",
    "text": "const promap: <E, A, D, B>(f: (d: D) => E, g: (a: A) => B) => (fbc: Reader<E, A>) => Reader<D, B> = (f, g) => (\n  fea\n) => (a) => g(fea(f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(d: D) => E"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<E, A>) => (a: D) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 153,
        "to": 155
      }
    }
  },
  {
    "name": "id",
    "text": "const id: Category2<URI>['id'] = () => identity",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "typeof import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").identity"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 161,
        "to": 161
      }
    }
  },
  {
    "name": "first",
    "text": "const first: Strong2<URI>['first'] = (pab) => ([a, c]) => [pab(a), c]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "pab",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "([a, c]: [A, C]) => [B, C]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "second",
    "text": "const second: Strong2<URI>['second'] = (pbc) => ([a, b]) => [a, pbc(b)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "pbc",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "([a, b]: [A, B]) => [A, C]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 173,
        "to": 173
      }
    }
  },
  {
    "name": "left",
    "text": "const left: Choice2<URI>['left'] = (pab) => E.fold((a) => E.left(pab(a)), E.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "pab",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 179,
        "to": 179
      }
    }
  },
  {
    "name": "right",
    "text": "const right: Choice2<URI>['right'] = (pbc) => E.fold(E.left, (b) => E.right(pbc(b)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "pbc",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 185,
        "to": 185
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <R, A, B>(f: (index: number, a: A) => Reader<R, B>) => (\n  as: ReadonlyArray<A>\n): Reader<R, ReadonlyArray<B>> => (r) => as.map((x, i) => f(i, x)(r))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 427,
        "to": 429
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <R, A, B>(\n  f: (a: A) => Reader<R, B>\n): ((as: ReadonlyArray<A>) => Reader<R, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Reader.ts",
      "lines": {
        "from": 436,
        "to": 438
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable3C<URI, E> {\n  const F = E.getFilterable(M)\n  const C = getCompactable(M)\n\n  const filter = filter_(R.Functor, F)\n  const filterMap = filterMap_(R.Functor, F)\n  const partition = partition_(R.Functor, F)\n  const partitionMap = partitionMap_(R.Functor, F)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact: C.compact,\n    separate: C.separate,\n    filter: <R, A>(fa: ReaderEither<R, E, A>, predicate: Predicate<A>) => pipe(fa, filter(predicate)),\n    filterMap: (fa, f) => pipe(fa, filterMap(f)),\n    partition: <R, A>(fa: ReaderEither<R, E, A>, predicate: Predicate<A>) => pipe(fa, partition(predicate)),\n    partitionMap: (fa, f) => pipe(fa, partitionMap(f))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 421,
        "to": 440
      }
    }
  },
  {
    "name": "getApplicativeReaderValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeReaderValidation<E>(S: Semigroup<E>): Applicative3C<URI, E> {\n  const ap = ap_(R.Apply, E.getApplicativeValidation(S))\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 446,
        "to": 455
      }
    }
  },
  {
    "name": "getAltReaderValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltReaderValidation<E>(S: Semigroup<E>): Alt3C<URI, E> {\n  const alt = ET.altValidation(R.Monad, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    alt: (fa, that) => pipe(fa, alt(that))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 461,
        "to": 469
      }
    }
  },
  {
    "name": "getReaderValidation",
    "text": "\n\n/**\n * Use [`getApplicativeReaderValidation`](#getapplicativereadervalidation) and [`getAltReaderValidation`](#getaltreadervalidation) instead.\n *\n * @category instances\n * @since 2.3.0\n * @deprecated\n */\nexport function getReaderValidation<E>(\n  SE: Semigroup<E>\n): Monad3C<URI, E> & Bifunctor3<URI> & Alt3C<URI, E> & MonadThrow3C<URI, E> {\n  const applicativeReaderValidation = getApplicativeReaderValidation(SE)\n  const altReaderValidation = getAltReaderValidation(SE)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: applicativeReaderValidation.ap,\n    of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: altReaderValidation.alt,\n    throwError\n  }\n}",
    "docs": "/**\n * Use [`getApplicativeReaderValidation`](#getapplicativereadervalidation) and [`getAltReaderValidation`](#getaltreadervalidation) instead.\n *\n * @category instances\n * @since 2.3.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<\"ReaderEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<\"ReaderEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 881,
        "to": 898
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R, E = never>() => ReaderEither<R, E, R> = () => E.right",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<E = never, A = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 99,
        "to": 99
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, E = never, A = never>(f: (r: R) => A) => ReaderEither<R, E, A> = (f) => flow(f, E.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<never, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 105,
        "to": 105
      }
    }
  },
  {
    "name": "getCompactable",
    "text": "const getCompactable = <E>(M: Monoid<E>): Compactable3C<URI, E> => {\n  const C = E.getCompactable(M)\n  return {\n    URI,\n    _E: undefined as any,\n    compact: compact_(R.Functor, C),\n    separate: separate_(R.Functor, C, E.Functor)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<\"ReaderEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 407,
        "to": 415
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <R, E, A, B>(\n  f: (index: number, a: A) => ReaderEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderEither<R, E, ReadonlyArray<B>>) =>\n  flow(R.traverseArrayWithIndex(f), R.map(E.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 794,
        "to": 797
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <R, E, A, B>(\n  f: (a: A) => ReaderEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderEither<R, E, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 804,
        "to": 806
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <R, E, A>(S: Semigroup<A>): Semigroup<ReaderEither<R, E, A>> =>\n  getApplySemigroup_(R.Apply)(E.getSemigroup(S))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderEither.ts",
      "lines": {
        "from": 871,
        "to": 872
      }
    }
  },
  {
    "name": "of",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function of<F extends URIS4>(F: Pointed4<F>): <A, R, S, FR, FE>(a: A) => Reader<R, Kind4<F, S, FR, FE, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, S, FR, FE>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 16,
        "to": 16
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS3>(F: Pointed3<F>): <A, R, FR, FE>(a: A) => Reader<R, Kind3<F, FR, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FR, FE>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 17,
        "to": 17
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS3, FE>(F: Pointed3C<F, FE>): <A, R, FR>(a: A) => Reader<R, Kind3<F, FR, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FR>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 18,
        "to": 18
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS2>(F: Pointed2<F>): <A, R, FE>(a: A) => Reader<R, Kind2<F, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FE>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 19,
        "to": 19
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, R>(a: A) => Reader<R, Kind2<F, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 20,
        "to": 20
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS>(F: Pointed1<F>): <A, R>(a: A) => Reader<R, Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 21,
        "to": 21
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F>(F: Pointed<F>): <A, R>(a: A) => Reader<R, HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 22,
        "to": 22
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F>(F: Pointed<F>): <A, R>(a: A) => Reader<R, HKT<F, A>> {\n  return (a) => () => F.of(a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 23,
        "to": 25
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function map<F extends URIS4>(\n  F: Functor4<F>\n): <A, B>(f: (a: A) => B) => <R, S, FR, FE>(fa: Reader<R, Kind4<F, S, FR, FE, A>>) => Reader<R, Kind4<F, S, FR, FE, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, S, FR, FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 30,
        "to": 32
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <R, FR, FE>(fa: Reader<R, Kind3<F, FR, FE, A>>) => Reader<R, Kind3<F, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, FR, FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 33,
        "to": 35
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <A, B>(f: (a: A) => B) => <R, FR>(fa: Reader<R, Kind3<F, FR, FE, A>>) => Reader<R, Kind3<F, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, FR>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 36,
        "to": 38
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <R, FE>(fa: Reader<R, Kind2<F, FE, A>>) => Reader<R, Kind2<F, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 39,
        "to": 41
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, Kind2<F, FE, A>>) => Reader<R, Kind2<F, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 42,
        "to": 44
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS>(\n  F: Functor1<F>\n): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, Kind<F, A>>) => Reader<R, Kind<F, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 45,
        "to": 47
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, HKT<F, A>>) => Reader<R, HKT<F, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 48,
        "to": 48
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <R>(fa: Reader<R, HKT<F, A>>) => Reader<R, HKT<F, B>> {\n  return (f) => (fa) => (r) => F.map(fa(r), f)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 49,
        "to": 51
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function ap<F extends URIS4>(\n  F: Apply4<F>\n): <R, S, FR, FE, A>(\n  fa: Reader<R, Kind4<F, S, FR, FE, A>>\n) => <B>(fab: Reader<R, Kind4<F, S, FR, FE, (a: A) => B>>) => Reader<R, Kind4<F, S, FR, FE, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, S, FR, FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 56,
        "to": 60
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3>(\n  F: Apply3<F>\n): <R, FR, FE, A>(\n  fa: Reader<R, Kind3<F, FR, FE, A>>\n) => <B>(fab: Reader<R, Kind3<F, FR, FE, (a: A) => B>>) => Reader<R, Kind3<F, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FR, FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 61,
        "to": 65
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3, FE>(\n  F: Apply3C<F, FE>\n): <R, FR, A>(\n  fa: Reader<R, Kind3<F, FR, FE, A>>\n) => <B>(fab: Reader<R, Kind3<F, FR, FE, (a: A) => B>>) => Reader<R, Kind3<F, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FR, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 66,
        "to": 70
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2>(\n  F: Apply2<F>\n): <R, FE, A>(\n  fa: Reader<R, Kind2<F, FE, A>>\n) => <B>(fab: Reader<R, Kind2<F, FE, (a: A) => B>>) => Reader<R, Kind2<F, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 71,
        "to": 75
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2, FE>(\n  F: Apply2C<F, FE>\n): <R, A>(\n  fa: Reader<R, Kind2<F, FE, A>>\n) => <B>(fab: Reader<R, Kind2<F, FE, (a: A) => B>>) => Reader<R, Kind2<F, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 76,
        "to": 80
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS>(\n  F: Apply1<F>\n): <R, A>(fa: Reader<R, Kind<F, A>>) => <B>(fab: Reader<R, Kind<F, (a: A) => B>>) => Reader<R, Kind<F, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 81,
        "to": 83
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <R, A>(fa: Reader<R, HKT<F, A>>) => <B>(fab: Reader<R, HKT<F, (a: A) => B>>) => Reader<R, HKT<F, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 84,
        "to": 86
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F>(\n  F: Apply<F>\n): <R, A>(fa: Reader<R, HKT<F, A>>) => <B>(fab: Reader<R, HKT<F, (a: A) => B>>) => Reader<R, HKT<F, B>> {\n  return (fa) => (fab) => (r) => F.ap(fab(r), fa(r))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 87,
        "to": 91
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chain<M extends URIS4>(\n  M: Chain4<M>\n): <A, R, S, FR, FE, B>(\n  f: (a: A) => Reader<R, Kind4<M, S, FR, FE, B>>\n) => (ma: Reader<R, Kind4<M, S, FR, FE, A>>) => Reader<R, Kind4<M, S, FR, FE, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, S, FR, FE, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, FR, FE, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 96,
        "to": 100
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3>(\n  M: Chain3<M>\n): <A, R, FR, FE, B>(\n  f: (a: A) => Reader<R, Kind3<M, FR, FE, B>>\n) => (ma: Reader<R, Kind3<M, FR, FE, A>>) => Reader<R, Kind3<M, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FR, FE, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 101,
        "to": 105
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3, FE>(\n  M: Chain3C<M, FE>\n): <A, R, FR, B>(\n  f: (a: A) => Reader<R, Kind3<M, FR, FE, B>>\n) => (ma: Reader<R, Kind3<M, FR, FE, A>>) => Reader<R, Kind3<M, FR, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FR, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, FR, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 106,
        "to": 110
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2>(\n  M: Chain2<M>\n): <A, R, FE, B>(\n  f: (a: A) => Reader<R, Kind2<M, FE, B>>\n) => (ma: Reader<R, Kind2<M, FE, A>>) => Reader<R, Kind2<M, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FE, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 111,
        "to": 115
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, FE>(\n  M: Chain2C<M, FE>\n): <A, R, B>(f: (a: A) => Reader<R, Kind2<M, FE, B>>) => (ma: Reader<R, Kind2<M, FE, A>>) => Reader<R, Kind2<M, FE, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, FE, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS>(\n  M: Chain1<M>\n): <A, R, B>(f: (a: A) => Reader<R, Kind<M, B>>) => (ma: Reader<R, Kind<M, A>>) => Reader<R, Kind<M, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 119,
        "to": 121
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Chain<M>\n): <A, R, B>(f: (a: A) => Reader<R, HKT<M, B>>) => (ma: Reader<R, HKT<M, A>>) => Reader<R, HKT<M, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Chain<M>\n): <A, R, B>(f: (a: A) => Reader<R, HKT<M, B>>) => (ma: Reader<R, HKT<M, A>>) => Reader<R, HKT<M, B>> {\n  return (f) => (ma) => (r) => M.chain(ma(r), (a) => f(a)(r))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 125,
        "to": 129
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromReader<F extends URIS4>(\n  F: Pointed4<F>\n): <R, A, S, FR, FE>(ma: Reader<R, A>) => Reader<R, Kind4<F, S, FR, FE, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, S, FR, FE>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 134,
        "to": 136
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F extends URIS3>(\n  F: Pointed3<F>\n): <R, A, FR, FE>(ma: Reader<R, A>) => Reader<R, Kind3<F, FR, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, FR, FE>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 137,
        "to": 139
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F extends URIS3, FE>(\n  F: Pointed3C<F, FE>\n): <R, A, FR>(ma: Reader<R, A>) => Reader<R, Kind3<F, FR, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, FR>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, FR, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 140,
        "to": 142
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F extends URIS2>(F: Pointed2<F>): <R, A, FE>(ma: Reader<R, A>) => Reader<R, Kind2<F, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, FE>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 143,
        "to": 143
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F extends URIS2, FE>(\n  F: Pointed2C<F, FE>\n): <R, A>(ma: Reader<R, A>) => Reader<R, Kind2<F, FE, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 144,
        "to": 146
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F extends URIS>(F: Pointed1<F>): <R, A>(ma: Reader<R, A>) => Reader<R, Kind<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 147,
        "to": 147
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F>(F: Pointed<F>): <R, A>(ma: Reader<R, A>) => Reader<R, HKT<F, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 148,
        "to": 148
      }
    }
  },
  {
    "name": "fromReader",
    "text": "\nexport function fromReader<F>(F: Pointed<F>): <R, A>(ma: Reader<R, A>) => Reader<R, HKT<F, A>> {\n  return (ma) => flow(ma, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 149,
        "to": 151
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport function getReaderM<M extends URIS3>(M: Monad3<M>): ReaderM3<M>",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 284,
        "to": 284
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n/** @deprecated */\nexport function getReaderM<M extends URIS2>(M: Monad2<M>): ReaderM2<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 286,
        "to": 286
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n/** @deprecated */\nexport function getReaderM<M extends URIS2, E>(M: Monad2C<M, E>): ReaderM2C<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 288,
        "to": 288
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n/** @deprecated */\nexport function getReaderM<M extends URIS>(M: Monad1<M>): ReaderM1<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 290,
        "to": 290
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n/** @deprecated */\nexport function getReaderM<M>(M: Monad<M>): ReaderM<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 292,
        "to": 292
      }
    }
  },
  {
    "name": "getReaderM",
    "text": "\n/** @deprecated */\n/* istanbul ignore next */\nexport function getReaderM<M>(M: Monad<M>): ReaderM<M> {\n  const _ap = ap(M)\n  const _map = map(M)\n  const _chain = chain(M)\n\n  return {\n    map: (fa, f) => pipe(fa, _map(f)),\n    ap: (fab, fa) => pipe(fab, _ap(fa)),\n    of: of(M),\n    chain: (ma, f) => pipe(ma, _chain(f)),\n    ask: () => M.of,\n    asks: (f) => flow(f, M.of),\n    local: (ma, f) => (q) => ma(f(q)),\n    fromReader: fromReader(M),\n    fromM: (ma) => () => ma\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderT\").ReaderM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderT.ts",
      "lines": {
        "from": 295,
        "to": 311
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 2.4.0\n * @deprecated\n */\n/* istanbul ignore next */\nexport function run<R, A>(ma: ReaderTask<R, A>, r: R): Promise<A> {\n  return ma(r)()\n}",
    "docs": "/**\n * @since 2.4.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 603,
        "to": 605
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask = <R>(): ReaderTask<R, R> => T.of",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 63,
        "to": 63
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks = <R, A = never>(f: (r: R) => A): ReaderTask<R, A> => flow(f, T.of)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 69,
        "to": 69
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <R, A, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n): ((as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>) =>\n  flow(R.traverseArrayWithIndex(f), R.map(T.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 484,
        "to": 487
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <R, A, B>(\n  f: (a: A) => ReaderTask<R, B>\n): ((as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 494,
        "to": 496
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <R, A, B>(\n  f: (index: number, a: A) => ReaderTask<R, B>\n): ((as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>) =>\n  flow(R.traverseArrayWithIndex(f), R.map(T.sequenceSeqArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 512,
        "to": 515
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray = <R, A, B>(\n  f: (a: A) => ReaderTask<R, B>\n): ((as: ReadonlyArray<A>) => ReaderTask<R, ReadonlyArray<B>>) => traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTask\").ReaderTask<R, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTask.ts",
      "lines": {
        "from": 522,
        "to": 524
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable3C<URI, E> {\n  const F = E.getFilterable(M)\n  const C = getCompactable(M)\n\n  const filter = filter_(RT.Functor, F)\n  const filterMap = filterMap_(RT.Functor, F)\n  const partition = partition_(RT.Functor, F)\n  const partitionMap = partitionMap_(RT.Functor, F)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact: C.compact,\n    separate: C.separate,\n    filter: <R, A>(fa: ReaderTaskEither<R, E, A>, predicate: Predicate<A>) => pipe(fa, filter(predicate)),\n    filterMap: (fa, f) => pipe(fa, filterMap(f)),\n    partition: <R, A>(fa: ReaderTaskEither<R, E, A>, predicate: Predicate<A>) => pipe(fa, partition(predicate)),\n    partitionMap: (fa, f) => pipe(fa, partitionMap(f))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 583,
        "to": 602
      }
    }
  },
  {
    "name": "getApplicativeReaderTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeReaderTaskValidation<E>(A: Apply1<T.URI>, S: Semigroup<E>): Applicative3C<URI, E> {\n  const ap = ap_(R.Apply, TE.getApplicativeTaskValidation(A, S))\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<\"Task\">"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 608,
        "to": 617
      }
    }
  },
  {
    "name": "getAltReaderTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltReaderTaskValidation<E>(S: Semigroup<E>): Alt3C<URI, E> {\n  const alt = ET.altValidation(RT.Monad, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    alt: (fa, that) => pipe(fa, alt(that))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 623,
        "to": 631
      }
    }
  },
  {
    "name": "bracket",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.4\n */\nexport function bracket<R, E, A, B>(\n  aquire: ReaderTaskEither<R, E, A>,\n  use: (a: A) => ReaderTaskEither<R, E, B>,\n  release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>\n): ReaderTaskEither<R, E, B> {\n  return (r) =>\n    TE.bracket(\n      aquire(r),\n      (a) => use(a)(r),\n      (a, e) => release(a, e)(r)\n    )\n}",
    "docs": "/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.4\n */",
    "signature": {
      "parameters": [
        {
          "name": "aquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1018,
        "to": 1029
      }
    }
  },
  {
    "name": "getReaderTaskValidation",
    "text": "\n\n/**\n * Use [`getApplicativeReaderTaskValidation`](#getapplicativereadertaskvalidation) and [`getAltReaderTaskValidation`](#getaltreadertaskvalidation) instead.\n *\n * @category instances\n * @since 2.3.0\n * @deprecated\n */\nexport function getReaderTaskValidation<E>(\n  SE: Semigroup<E>\n): Monad3C<URI, E> & Bifunctor3<URI> & Alt3C<URI, E> & MonadTask3C<URI, E> & MonadThrow3C<URI, E> {\n  const applicativeReaderTaskValidation = getApplicativeReaderTaskValidation(T.ApplicativePar, SE)\n  const altReaderTaskValidation = getAltReaderTaskValidation(SE)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    ap: applicativeReaderTaskValidation.ap,\n    alt: altReaderTaskValidation.alt,\n    fromIO,\n    fromTask,\n    throwError\n  }\n}",
    "docs": "/**\n * Use [`getApplicativeReaderTaskValidation`](#getapplicativereadertaskvalidation) and [`getAltReaderTaskValidation`](#getaltreadertaskvalidation) instead.\n *\n * @category instances\n * @since 2.3.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor3<\"ReaderTaskEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask3C<\"ReaderTaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1242,
        "to": 1261
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\n/* istanbul ignore next */\nexport function run<R, E, A>(ma: ReaderTaskEither<R, E, A>, r: R): Promise<Either<E, A>> {\n  return ma(r)()\n}",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1268,
        "to": 1270
      }
    }
  },
  {
    "name": "rightReader",
    "text": "const rightReader: <R, E = never, A = never>(ma: Reader<R, A>) => ReaderTaskEither<R, E, A> = (ma) =>\n  flow(ma, TE.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<never, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 128,
        "to": 129
      }
    }
  },
  {
    "name": "leftReader",
    "text": "const leftReader: <R, E = never, A = never>(me: Reader<R, E>) => ReaderTaskEither<R, E, A> = (me) =>\n  flow(me, TE.left)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 135,
        "to": 136
      }
    }
  },
  {
    "name": "fromReaderEither",
    "text": "const fromReaderEither = <R, E, A>(ma: ReaderEither<R, E, A>): ReaderTaskEither<R, E, A> =>\n  flow(ma, TE.fromEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 166,
        "to": 167
      }
    }
  },
  {
    "name": "ask",
    "text": "const ask: <R, E = never>() => ReaderTaskEither<R, E, R> = () => TE.right",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<E = never, A = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 201,
        "to": 201
      }
    }
  },
  {
    "name": "asks",
    "text": "const asks: <R, E = never, A = never>(f: (r: R) => A) => ReaderTaskEither<R, E, A> = (f) =>\n  flow(TE.right, TE.map(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(r: R) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: R) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<never, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 207,
        "to": 208
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "const fromIOEitherK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): (<R>(...a: A) => ReaderTaskEither<R, E, B>) => flow(f, fromIOEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 348,
        "to": 350
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW: <E2, A, B>(\n  f: (a: A) => IOEither<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B> = (f) => chainW(fromIOEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R1, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R1, E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 358,
        "to": 360
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "const fromTaskEitherK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n): (<R>(...a: A) => ReaderTaskEither<R, E, B>) => flow(f, fromTaskEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 374,
        "to": 376
      }
    }
  },
  {
    "name": "chainTaskEitherKW",
    "text": "const chainTaskEitherKW: <E2, A, B>(\n  f: (a: A) => TaskEither<E2, B>\n) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B> = (f) => chainW(fromTaskEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R1, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R1, E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 384,
        "to": 386
      }
    }
  },
  {
    "name": "getCompactable",
    "text": "const getCompactable = <E>(M: Monoid<E>): Compactable3C<URI, E> => {\n  const C = E.getCompactable(M)\n  return {\n    URI,\n    _E: undefined as any,\n    compact: compact_(RT.Functor, C),\n    separate: separate_(RT.Functor, C, E.Functor)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable3C<\"ReaderTaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 569,
        "to": 577
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <R, E, A, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>) =>\n  flow(R.traverseArrayWithIndex(f), R.map(TE.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1096,
        "to": 1099
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1106,
        "to": 1108
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <R, E, A, B>(\n  f: (index: number, a: A) => ReaderTaskEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>) =>\n  flow(R.traverseArrayWithIndex(f), R.map(TE.sequenceSeqArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1126,
        "to": 1129
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray = <R, E, A, B>(\n  f: (a: A) => ReaderTaskEither<R, E, B>\n): ((as: ReadonlyArray<A>) => ReaderTaskEither<R, E, ReadonlyArray<B>>) => traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1136,
        "to": 1138
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <R, E, A>(S: Semigroup<A>): Semigroup<ReaderTaskEither<R, E, A>> =>\n  getApplySemigroup_(RT.ApplySeq)(E.getSemigroup(S))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReaderTaskEither.ts",
      "lines": {
        "from": 1232,
        "to": 1233
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * This function provides a safe way to read a value at a particular index from an array\n *\n * @example\n * import { lookup } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.5.0\n */\nexport function lookup(i: number): <A>(as: ReadonlyArray<A>) => Option<A>",
    "docs": "/**\n * This function provides a safe way to read a value at a particular index from an array\n *\n * @example\n * import { lookup } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 280,
        "to": 280
      }
    }
  },
  {
    "name": "lookup",
    "text": "\nexport function lookup<A>(i: number, as: ReadonlyArray<A>): Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 281,
        "to": 281
      }
    }
  },
  {
    "name": "lookup",
    "text": "\nexport function lookup<A>(i: number, as?: ReadonlyArray<A>): Option<A> | (<A>(as: ReadonlyArray<A>) => Option<A>) {\n  return as === undefined ? (as) => lookup(i, as) : isOutOfBound(i, as) ? O.none : O.some(as[i])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<A> | (<A>(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 282,
        "to": 284
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => ReadonlyArray<B>",
    "docs": "/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { takeLeftWhile } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(takeLeftWhile((n: number) => n % 2 === 0)([2, 4, 3, 6]), [2, 4])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 398,
        "to": 398
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 399,
        "to": 399
      }
    }
  },
  {
    "name": "takeLeftWhile",
    "text": "\nexport function takeLeftWhile<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => ReadonlyArray<A> {\n  return (as) => {\n    const out: Array<A> = []\n    for (const a of as) {\n      if (!predicate(a)) {\n        break\n      }\n      out.push(a)\n    }\n    const len = out.length\n    return len === as.length ? as : len === 0 ? empty : out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 400,
        "to": 412
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\n\n/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @since 2.5.0\n */\nexport function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Spanned<B, A>",
    "docs": "/**\n * Split an array into two parts:\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @example\n * import { spanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(spanLeft((n: number) => n % 2 === 1)([1, 3, 2, 4, 5]), { init: [1, 3], rest: [2, 4, 5] })\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<B, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 445,
        "to": 445
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned<A, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 446,
        "to": 446
      }
    }
  },
  {
    "name": "spanLeft",
    "text": "\nexport function spanLeft<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Spanned<A, A> {\n  return (as) => {\n    const [init, rest] = splitAt(spanLeftIndex(as, predicate))(as)\n    return { init, rest }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyArray\").Spanned<A, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 447,
        "to": 452
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\n\n/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findFirst((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @since 2.5.0\n */\nexport function findFirst<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>",
    "docs": "/**\n * Find the first element which satisfies a predicate (or a refinement) function\n *\n * @example\n * import { findFirst } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findFirst((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 1 }))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 547,
        "to": 547
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 548,
        "to": 548
      }
    }
  },
  {
    "name": "findFirst",
    "text": "\nexport function findFirst<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A> {\n  return (as) => {\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i])) {\n        return O.some(as[i])\n      }\n    }\n    return O.none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 549,
        "to": 558
      }
    }
  },
  {
    "name": "findLast",
    "text": "\n\n/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findLast((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @since 2.5.0\n */\nexport function findLast<A, B extends A>(refinement: Refinement<A, B>): (as: ReadonlyArray<A>) => Option<B>",
    "docs": "/**\n * Find the last element which satisfies a predicate function\n *\n * @example\n * import { findLast } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * type X = {\n *   readonly a: number\n *   readonly b: number\n * }\n *\n * assert.deepStrictEqual(findLast((x: X) => x.a === 1)([{ a: 1, b: 1 }, { a: 1, b: 2 }]), some({ a: 1, b: 2 }))\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 605,
        "to": 605
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 606,
        "to": 606
      }
    }
  },
  {
    "name": "findLast",
    "text": "\nexport function findLast<A>(predicate: Predicate<A>): (as: ReadonlyArray<A>) => Option<A> {\n  return (as) => {\n    for (let i = as.length - 1; i >= 0; i--) {\n      if (predicate(as[i])) {\n        return O.some(as[i])\n      }\n    }\n    return O.none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 607,
        "to": 616
      }
    }
  },
  {
    "name": "zip",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], zip(['a', 'b', 'c', 'd'])), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function zip<B>(bs: ReadonlyArray<B>): <A>(as: ReadonlyArray<A>) => ReadonlyArray<readonly [A, B]>",
    "docs": "/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], zip(['a', 'b', 'c', 'd'])), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly (readonly [A, B])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 850,
        "to": 850
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(as: ReadonlyArray<A>, bs: ReadonlyArray<B>): ReadonlyArray<readonly [A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly (readonly [A, B])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 851,
        "to": 851
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(\n  as: ReadonlyArray<A>,\n  bs?: ReadonlyArray<B>\n): ReadonlyArray<readonly [A, B]> | ((bs: ReadonlyArray<B>) => ReadonlyArray<readonly [B, A]>) {\n  if (bs === undefined) {\n    return (bs) => zip(bs, as)\n  }\n  return zipWith(as, bs, (a, b) => [a, b])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly (readonly [A, B])[] | ((bs: readonly B[]) => readonly (readonly [B, A])[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 852,
        "to": 860
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of an array. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an array of type `ReadonlyArray<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.5.0\n */\nexport function elem<A>(\n  E: Eq<A>\n): {\n  (a: A): (as: ReadonlyArray<A>) => boolean\n  (a: A, as: ReadonlyArray<A>): boolean\n}",
    "docs": "/**\n * Test if a value is a member of an array. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an array of type `ReadonlyArray<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (a: A): (as: readonly A[]) => boolean; (a: A, as: readonly A[]): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 947,
        "to": 952
      }
    }
  },
  {
    "name": "elem",
    "text": "\nexport function elem<A>(E: Eq<A>): (a: A, as?: ReadonlyArray<A>) => boolean | ((as: ReadonlyArray<A>) => boolean) {\n  return (a, as?) => {\n    if (as === undefined) {\n      const elemE = elem(E)\n      return (as) => elemE(a, as)\n    }\n    const predicate = (element: A) => E.equals(element, a)\n    let i = 0\n    for (; i < as.length; i++) {\n      if (predicate(as[i])) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, as?: readonly A[]) => boolean | ((as: readonly A[]) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 953,
        "to": 968
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\n\n/**\n * `ReadonlyArray` comprehension.\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/ReadonlyArray'\n * import { tuple } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function comprehension<A, B, C, D, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>, ReadonlyArray<D>],\n  f: (a: A, b: B, c: C, d: D) => R,\n  g?: (a: A, b: B, c: C, d: D) => boolean\n): ReadonlyArray<R>",
    "docs": "/**\n * `ReadonlyArray` comprehension.\n *\n * ```\n * [ f(x, y, ...) | x  xs, y  ys, ..., g(x, y, ...) ]\n * ```\n *\n * @example\n * import { comprehension } from 'fp-ts/ReadonlyArray'\n * import { tuple } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(comprehension([[1, 2, 3], ['a', 'b']], tuple, (a, b) => (a + b.length) % 2 === 0), [\n *   [1, 'a'],\n *   [1, 'b'],\n *   [3, 'a'],\n *   [3, 'b']\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[], readonly C[], readonly D[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1111,
        "to": 1115
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, C, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>, ReadonlyArray<C>],\n  f: (a: A, b: B, c: C) => R,\n  g?: (a: A, b: B, c: C) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[], readonly C[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1116,
        "to": 1120
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, B, R>(\n  input: readonly [ReadonlyArray<A>, ReadonlyArray<B>],\n  f: (a: A, b: B) => R,\n  g?: (a: A, b: B) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[], readonly B[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1121,
        "to": 1125
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(\n  input: readonly [ReadonlyArray<A>],\n  f: (a: A) => R,\n  g?: (a: A) => boolean\n): ReadonlyArray<R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly [readonly A[]]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1126,
        "to": 1130
      }
    }
  },
  {
    "name": "comprehension",
    "text": "\nexport function comprehension<A, R>(\n  input: ReadonlyArray<ReadonlyArray<A>>,\n  f: (...xs: ReadonlyArray<A>) => R,\n  g: (...xs: ReadonlyArray<A>) => boolean = () => true\n): ReadonlyArray<R> {\n  const go = (scope: ReadonlyArray<A>, input: ReadonlyArray<ReadonlyArray<A>>): ReadonlyArray<R> =>\n    isNonEmpty(input)\n      ? pipe(\n          RNEA.head(input),\n          chain((x) => go(pipe(scope, append(x)), RNEA.tail(input)))\n        )\n      : g(...scope)\n      ? [f(...scope)]\n      : empty\n  return go(empty, input)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "input",
          "type": {
            "__tag": "Other",
            "values": "readonly (readonly A[])[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...xs: readonly A[]) => R"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(...xs: readonly A[]) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly R[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1131,
        "to": 1146
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], union(N.Eq)([2, 3])), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function union<A>(\n  E: Eq<A>\n): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}",
    "docs": "/**\n * Creates an array of unique values, in order, from all given arrays using a `Eq` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], union(N.Eq)([2, 3])), [1, 2, 3])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: readonly A[]): (ys: readonly A[]) => readonly A[]; (xs: readonly A[], ys: readonly A[]): readonly A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1162,
        "to": 1167
      }
    }
  },
  {
    "name": "union",
    "text": "\nexport function union<A>(\n  E: Eq<A>\n): (xs: ReadonlyArray<A>, ys?: ReadonlyArray<A>) => ReadonlyArray<A> | ((ys: ReadonlyArray<A>) => ReadonlyArray<A>) {\n  const unionE = RNEA.union(E)\n  return (first, second?) => {\n    if (second === undefined) {\n      const unionE = union(E)\n      return (ys) => unionE(ys, first)\n    }\n    return isNonEmpty(first) && isNonEmpty(second) ? unionE(first, second) : isNonEmpty(first) ? first : second\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys?: readonly A[]) => readonly A[] | ((ys: readonly A[]) => readonly A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1168,
        "to": 1179
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], intersection(N.Eq)([2, 3])), [2])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function intersection<A>(\n  E: Eq<A>\n): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}",
    "docs": "/**\n * Creates an array of unique values that are included in all given arrays using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], intersection(N.Eq)([2, 3])), [2])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: readonly A[]): (ys: readonly A[]) => readonly A[]; (xs: readonly A[], ys: readonly A[]): readonly A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1196,
        "to": 1201
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A>(\n  E: Eq<A>\n): (xs: ReadonlyArray<A>, ys?: ReadonlyArray<A>) => ReadonlyArray<A> | ((ys: ReadonlyArray<A>) => ReadonlyArray<A>) {\n  const elemE = elem(E)\n  return (xs, ys?) => {\n    if (ys === undefined) {\n      const intersectionE = intersection(E)\n      return (ys) => intersectionE(ys, xs)\n    }\n    return xs.filter((a) => elemE(a, ys))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys?: readonly A[]) => readonly A[] | ((ys: readonly A[]) => readonly A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1202,
        "to": 1213
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], difference(N.Eq)([2, 3])), [1])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function difference<A>(\n  E: Eq<A>\n): {\n  (xs: ReadonlyArray<A>): (ys: ReadonlyArray<A>) => ReadonlyArray<A>\n  (xs: ReadonlyArray<A>, ys: ReadonlyArray<A>): ReadonlyArray<A>\n}",
    "docs": "/**\n * Creates an array of array values not included in the other given array using a `Eq` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2], difference(N.Eq)([2, 3])), [1])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (xs: readonly A[]): (ys: readonly A[]) => readonly A[]; (xs: readonly A[], ys: readonly A[]): readonly A[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1230,
        "to": 1235
      }
    }
  },
  {
    "name": "difference",
    "text": "\nexport function difference<A>(\n  E: Eq<A>\n): (xs: ReadonlyArray<A>, ys?: ReadonlyArray<A>) => ReadonlyArray<A> | ((ys: ReadonlyArray<A>) => ReadonlyArray<A>) {\n  const elemE = elem(E)\n  return (xs, ys?) => {\n    if (ys === undefined) {\n      const differenceE = difference(E)\n      return (ys) => differenceE(ys, xs)\n    }\n    return xs.filter((a) => !elemE(a, ys))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(xs: readonly A[], ys?: readonly A[]) => readonly A[] | ((ys: readonly A[]) => readonly A[])"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1236,
        "to": 1247
      }
    }
  },
  {
    "name": "makeBy",
    "text": "const makeBy = <A>(n: number, f: (i: number) => A): ReadonlyArray<A> => (n <= 0 ? empty : RNEA.makeBy(n, f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 86,
        "to": 86
      }
    }
  },
  {
    "name": "range",
    "text": "const range = (start: number, end: number): ReadonlyArray<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : [start]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "start",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly number[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 99,
        "to": 100
      }
    }
  },
  {
    "name": "replicate",
    "text": "const replicate = <A>(n: number, a: A): ReadonlyArray<A> => makeBy(n, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 115,
        "to": 115
      }
    }
  },
  {
    "name": "matchLeft",
    "text": "const matchLeft = <B, A>(onEmpty: Lazy<B>, onNonEmpty: (head: A, tail: ReadonlyArray<A>) => B) => (\n  as: ReadonlyArray<A>\n): B => (isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onEmpty",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        },
        {
          "name": "onNonEmpty",
          "type": {
            "__tag": "Other",
            "values": "(head: A, tail: readonly A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 133,
        "to": 135
      }
    }
  },
  {
    "name": "matchRight",
    "text": "const matchRight = <B, A>(onEmpty: Lazy<B>, onNonEmpty: (init: ReadonlyArray<A>, last: A) => B) => (\n  as: ReadonlyArray<A>\n): B => (isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onEmpty",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<B>"
          }
        },
        {
          "name": "onNonEmpty",
          "type": {
            "__tag": "Other",
            "values": "(init: readonly A[], last: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 154,
        "to": 156
      }
    }
  },
  {
    "name": "chainWithIndex",
    "text": "const chainWithIndex = <A, B>(f: (i: number, a: A) => ReadonlyArray<B>) => (\n  as: ReadonlyArray<A>\n): ReadonlyArray<B> => {\n  if (isEmpty(as)) {\n    return empty\n  }\n  const out: Array<B> = []\n  for (let i = 0; i < as.length; i++) {\n    out.push(...f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 177,
        "to": 188
      }
    }
  },
  {
    "name": "scanLeft",
    "text": "const scanLeft = <A, B>(b: B, f: (b: B, a: A) => B) => (as: ReadonlyArray<A>): ReadonlyNonEmptyArray<B> => {\n  const len = as.length\n  const out = new Array(len + 1) as NonEmptyArray<B>\n  out[0] = b\n  for (let i = 0; i < len; i++) {\n    out[i + 1] = f(out[i], as[i])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 201,
        "to": 209
      }
    }
  },
  {
    "name": "scanRight",
    "text": "const scanRight = <A, B>(b: B, f: (a: A, b: B) => B) => (as: ReadonlyArray<A>): ReadonlyNonEmptyArray<B> => {\n  const len = as.length\n  const out = new Array(len + 1) as NonEmptyArray<B>\n  out[len] = b\n  for (let i = len - 1; i >= 0; i--) {\n    out[i] = f(as[i], out[i + 1])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 222,
        "to": 230
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "const isEmpty = <A>(as: ReadonlyArray<A>): boolean => as.length === 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 242,
        "to": 242
      }
    }
  },
  {
    "name": "size",
    "text": "const size = <A>(as: ReadonlyArray<A>): number => as.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 257,
        "to": 257
      }
    }
  },
  {
    "name": "head",
    "text": "const head = <A>(as: ReadonlyArray<A>): Option<A> => (isNonEmpty(as) ? O.some(RNEA.head(as)) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 298,
        "to": 298
      }
    }
  },
  {
    "name": "last",
    "text": "const last = <A>(as: ReadonlyArray<A>): Option<A> => (isNonEmpty(as) ? O.some(RNEA.last(as)) : O.none)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 312,
        "to": 312
      }
    }
  },
  {
    "name": "tail",
    "text": "const tail = <A>(as: ReadonlyArray<A>): Option<ReadonlyArray<A>> =>\n  isNonEmpty(as) ? O.some(RNEA.tail(as)) : O.none",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 326,
        "to": 327
      }
    }
  },
  {
    "name": "init",
    "text": "const init = <A>(as: ReadonlyArray<A>): Option<ReadonlyArray<A>> =>\n  isNonEmpty(as) ? O.some(RNEA.init(as)) : O.none",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 341,
        "to": 342
      }
    }
  },
  {
    "name": "takeLeft",
    "text": "const takeLeft = (n: number) => <A>(as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 363,
        "to": 364
      }
    }
  },
  {
    "name": "takeRight",
    "text": "const takeRight = (n: number) => <A>(as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 384,
        "to": 385
      }
    }
  },
  {
    "name": "dropLeft",
    "text": "const dropLeft = (n: number) => <A>(as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 471,
        "to": 472
      }
    }
  },
  {
    "name": "dropRight",
    "text": "const dropRight = (n: number) => <A>(as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 491,
        "to": 492
      }
    }
  },
  {
    "name": "dropLeftWhile",
    "text": "const dropLeftWhile = <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>): ReadonlyArray<A> => {\n  const i = spanLeftIndex(as, predicate)\n  return i === 0 ? as : i === as.length ? empty : as.slice(i)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 505,
        "to": 508
      }
    }
  },
  {
    "name": "findIndex",
    "text": "const findIndex = <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>): Option<number> => {\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i])) {\n      return O.some(i)\n    }\n  }\n  return O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 522,
        "to": 529
      }
    }
  },
  {
    "name": "findFirstMap",
    "text": "const findFirstMap = <A, B>(f: (a: A) => Option<B>) => (as: ReadonlyArray<A>): Option<B> => {\n  for (let i = 0; i < as.length; i++) {\n    const out = f(as[i])\n    if (O.isSome(out)) {\n      return out\n    }\n  }\n  return O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 579,
        "to": 587
      }
    }
  },
  {
    "name": "findLastMap",
    "text": "const findLastMap = <A, B>(f: (a: A) => Option<B>) => (as: ReadonlyArray<A>): Option<B> => {\n  for (let i = as.length - 1; i >= 0; i--) {\n    const out = f(as[i])\n    if (O.isSome(out)) {\n      return out\n    }\n  }\n  return O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 637,
        "to": 645
      }
    }
  },
  {
    "name": "findLastIndex",
    "text": "const findLastIndex = <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>): Option<number> => {\n  for (let i = as.length - 1; i >= 0; i--) {\n    if (predicate(as[i])) {\n      return O.some(i)\n    }\n  }\n  return O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<number>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 665,
        "to": 672
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(i: number, a: A): ((as: ReadonlyArray<A>) => Option<ReadonlyArray<A>>) =>\n  modifyAt(i, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 701,
        "to": 702
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "const deleteAt = (i: number) => <A>(as: ReadonlyArray<A>): Option<ReadonlyArray<A>> =>\n  isOutOfBound(i, as) ? O.none : O.some(unsafeDeleteAt(i, as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 716,
        "to": 717
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(i: number, f: (a: A) => A) => (as: ReadonlyArray<A>): Option<ReadonlyArray<A>> =>\n  isOutOfBound(i, as) ? O.none : O.some(unsafeUpdateAt(i, f(as[i]), as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 733,
        "to": 734
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(as: ReadonlyArray<A>): ReadonlyArray<A> => (as.length <= 1 ? as : as.slice().reverse())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 747,
        "to": 747
      }
    }
  },
  {
    "name": "rights",
    "text": "const rights = <E, A>(as: ReadonlyArray<Either<E, A>>): ReadonlyArray<A> => {\n  const r: Array<A> = []\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    if (a._tag === 'Right') {\n      r.push(a.right)\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 761,
        "to": 770
      }
    }
  },
  {
    "name": "lefts",
    "text": "const lefts = <E, A>(as: ReadonlyArray<Either<E, A>>): ReadonlyArray<E> => {\n  const r: Array<E> = []\n  for (let i = 0; i < as.length; i++) {\n    const a = as[i]\n    if (a._tag === 'Left') {\n      r.push(a.left)\n    }\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly E[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 784,
        "to": 793
      }
    }
  },
  {
    "name": "sort",
    "text": "const sort = <B>(O: Ord<B>) => <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  as.length <= 1 ? as : as.slice().sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 807,
        "to": 808
      }
    }
  },
  {
    "name": "zipWith",
    "text": "const zipWith = <A, B, C>(\n  fa: ReadonlyArray<A>,\n  fb: ReadonlyArray<B>,\n  f: (a: A, b: B) => C\n): ReadonlyArray<C> => {\n  const fc: Array<C> = []\n  const len = Math.min(fa.length, fb.length)\n  for (let i = 0; i < len; i++) {\n    fc[i] = f(fa[i], fb[i])\n  }\n  return fc\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "fb",
          "type": {
            "__tag": "Other",
            "values": "readonly B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly C[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 823,
        "to": 834
      }
    }
  },
  {
    "name": "unzip",
    "text": "const unzip = <A, B>(as: ReadonlyArray<readonly [A, B]>): readonly [ReadonlyArray<A>, ReadonlyArray<B>] => {\n  const fa: Array<A> = []\n  const fb: Array<B> = []\n  for (let i = 0; i < as.length; i++) {\n    fa[i] = as[i][0]\n    fb[i] = as[i][1]\n  }\n  return [fa, fb]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly (readonly [A, B])[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [readonly A[], readonly B[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 873,
        "to": 881
      }
    }
  },
  {
    "name": "prependAll",
    "text": "const prependAll = <A>(middle: A): ((as: ReadonlyArray<A>) => ReadonlyArray<A>) => {\n  const f = RNEA.prependAll(middle)\n  return (as) => (isNonEmpty(as) ? f(as) : as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 894,
        "to": 897
      }
    }
  },
  {
    "name": "intersperse",
    "text": "const intersperse = <A>(middle: A): ((as: ReadonlyArray<A>) => ReadonlyArray<A>) => {\n  const f = RNEA.intersperse(middle)\n  return (as) => (isNonEmpty(as) ? f(as) : as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 910,
        "to": 913
      }
    }
  },
  {
    "name": "rotate",
    "text": "const rotate = (n: number): (<A>(as: ReadonlyArray<A>) => ReadonlyArray<A>) => {\n  const f = RNEA.rotate(n)\n  return (as) => (isNonEmpty(as) ? f(as) : as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 926,
        "to": 929
      }
    }
  },
  {
    "name": "uniq",
    "text": "const uniq = <A>(E: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<A>) => {\n  const f = RNEA.uniq(E)\n  return (as) => (isNonEmpty(as) ? f(as) : as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 982,
        "to": 985
      }
    }
  },
  {
    "name": "sortBy",
    "text": "const sortBy = <B>(ords: ReadonlyArray<Ord<B>>): (<A extends B>(as: ReadonlyArray<A>) => ReadonlyArray<A>) => {\n  const f = RNEA.sortBy(ords)\n  return (as) => (isNonEmpty(as) ? f(as) : as)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1018,
        "to": 1021
      }
    }
  },
  {
    "name": "chop",
    "text": "const chop = <A, B>(\n  f: (as: ReadonlyNonEmptyArray<A>) => readonly [B, ReadonlyArray<A>]\n): ((as: ReadonlyArray<A>) => ReadonlyArray<B>) => {\n  const g = RNEA.chop(f)\n  return (as) => (isNonEmpty(as) ? g(as) : empty)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1045,
        "to": 1050
      }
    }
  },
  {
    "name": "splitAt",
    "text": "const splitAt = (n: number) => <A>(as: ReadonlyArray<A>): readonly [ReadonlyArray<A>, ReadonlyArray<A>] =>\n  n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly [readonly A[], readonly A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1063,
        "to": 1064
      }
    }
  },
  {
    "name": "chunksOf",
    "text": "const chunksOf = (n: number): (<A>(as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyNonEmptyArray<A>>) => {\n  const f = RNEA.chunksOf(n)\n  return (as) => (isNonEmpty(as) ? f(as) : empty)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: readonly A[]) => readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1085,
        "to": 1088
      }
    }
  },
  {
    "name": "zero",
    "text": "const zero: Alternative1<URI>['zero'] = () => empty",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "readonly never[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1340,
        "to": 1340
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW = <B>(that: Lazy<ReadonlyArray<B>>) => <A>(fa: ReadonlyArray<A>): ReadonlyArray<A | B> =>\n  (fa as ReadonlyArray<A | B>).concat(that())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<readonly B[]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: readonly A[]) => readonly (B | A)[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1348,
        "to": 1349
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: ReadonlyArray<A>) => <B>(fab: ReadonlyArray<(a: A) => B>) => ReadonlyArray<B> = (fa) =>\n  chain((f) => pipe(fa, map(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly ((a: A) => B)[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1366,
        "to": 1367
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => ReadonlyArray<B>) => (ma: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (ma) =>\n  pipe(\n    ma,\n    chainWithIndex((_, a) => f(a))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => readonly B[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1375,
        "to": 1379
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (fa) =>\n  fa.map((a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1398,
        "to": 1399
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <A, B>(f: (i: number, a: A) => B) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (\n  fa\n) => fa.map((a, i) => f(i, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1405,
        "to": 1407
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <A, B>(fa: ReadonlyArray<Either<A, B>>): Separated<ReadonlyArray<A>, ReadonlyArray<B>> => {\n  const left: Array<A> = []\n  const right: Array<B> = []\n  for (const e of fa) {\n    if (e._tag === 'Left') {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly A[], readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1413,
        "to": 1424
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: ReadonlyArray<A>) => ReadonlyArray<B>\n  <A>(predicate: Predicate<A>): (fa: ReadonlyArray<A>) => ReadonlyArray<A>\n} = <A>(predicate: Predicate<A>) => (fa: ReadonlyArray<A>) => fa.filter(predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1430,
        "to": 1433
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "const filterMapWithIndex = <A, B>(f: (i: number, a: A) => Option<B>) => (\n  fa: ReadonlyArray<A>\n): ReadonlyArray<B> => {\n  const out: Array<B> = []\n  for (let i = 0; i < fa.length; i++) {\n    const optionB = f(i, fa[i])\n    if (O.isSome(optionB)) {\n      out.push(optionB.value)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1439,
        "to": 1450
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => (fa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) =>\n  filterMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1456,
        "to": 1457
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>\n  <A>(predicate: Predicate<A>): (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>\n} = <A>(predicate: Predicate<A>): ((fa: ReadonlyArray<A>) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>) =>\n  partitionWithIndex((_, a) => predicate(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly A[], readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1471,
        "to": 1477
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "const partitionWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<B>>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (\n    fa: ReadonlyArray<A>\n  ) => Separated<ReadonlyArray<A>, ReadonlyArray<A>>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (\n  fa: ReadonlyArray<A>\n): Separated<ReadonlyArray<A>, ReadonlyArray<A>> => {\n  const left: Array<A> = []\n  const right: Array<A> = []\n  for (let i = 0; i < fa.length; i++) {\n    const a = fa[i]\n    if (predicateWithIndex(i, a)) {\n      right.push(a)\n    } else {\n      left.push(a)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly A[], readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1483,
        "to": 1504
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: ReadonlyArray<A>) => Separated<ReadonlyArray<B>, ReadonlyArray<C>> = (f) =>\n  partitionMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly B[], readonly C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1510,
        "to": 1513
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "const partitionMapWithIndex = <A, B, C>(f: (i: number, a: A) => Either<B, C>) => (\n  fa: ReadonlyArray<A>\n): Separated<ReadonlyArray<B>, ReadonlyArray<C>> => {\n  const left: Array<B> = []\n  const right: Array<C> = []\n  for (let i = 0; i < fa.length; i++) {\n    const e = f(i, fa[i])\n    if (e._tag === 'Left') {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly B[], readonly C[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1519,
        "to": 1533
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex: {\n  <A, B extends A>(refinementWithIndex: RefinementWithIndex<number, A, B>): (fa: ReadonlyArray<A>) => ReadonlyArray<B>\n  <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: ReadonlyArray<A>) => ReadonlyArray<A>\n} = <A>(predicateWithIndex: PredicateWithIndex<number, A>) => (fa: ReadonlyArray<A>): ReadonlyArray<A> =>\n  fa.filter((a, i) => predicateWithIndex(i, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<number, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1539,
        "to": 1543
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (fa: ReadonlyArray<A>) => B) => (wa: ReadonlyArray<A>) => ReadonlyArray<B> = (f) => (\n  wa\n) => wa.map((_, i) => f(wa.slice(i)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(fa: readonly A[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: readonly A[]) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1549,
        "to": 1551
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "const foldMapWithIndex = <M>(M: Monoid<M>) => <A>(f: (i: number, a: A) => M) => (fa: ReadonlyArray<A>): M =>\n  fa.reduce((b, a, i) => M.concat(b, f(i, a)), M.empty)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (i: number, a: A) => M) => (fa: readonly A[]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1567,
        "to": 1568
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B = (b, f) =>\n  reduceWithIndex(b, (_, b, a) => f(b, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1574,
        "to": 1575
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: ReadonlyArray<A>) => M = (M) => {\n  const foldMapWithIndexM = foldMapWithIndex(M)\n  return (f) => foldMapWithIndexM((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: readonly A[]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1581,
        "to": 1584
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "const reduceWithIndex: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: ReadonlyArray<A>) => B = (b, f) => (\n  fa\n) => {\n  const len = fa.length\n  let out = b\n  for (let i = 0; i < len; i++) {\n    out = f(i, out, fa[i])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1590,
        "to": 1599
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B = (b, f) =>\n  reduceRightWithIndex(b, (_, a, b) => f(a, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1605,
        "to": 1606
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "const reduceRightWithIndex: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: ReadonlyArray<A>) => B = (\n  b,\n  f\n) => (fa) => fa.reduceRight((b, a, i) => f(i, a, b), b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly A[]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1612,
        "to": 1615
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) => {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1621,
        "to": 1626
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(F: ApplicativeHKT<F>) => <A>(\n  ta: ReadonlyArray<HKT<F, A>>\n): HKT<F, ReadonlyArray<A>> => {\n  return _reduce(ta, F.of(zero()), (fas, fa) =>\n    F.ap(\n      F.map(fas, (as) => (a: A) => pipe(as, append(a))),\n      fa\n    )\n  )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1632,
        "to": 1641
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "const traverseWithIndex: PipeableTraverseWithIndex1<URI, number> = <F>(F: ApplicativeHKT<F>) => <A, B>(\n  f: (i: number, a: A) => HKT<F, B>\n): ((ta: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) =>\n  reduceWithIndex(F.of(zero()), (i, fbs, a) =>\n    F.ap(\n      F.map(fbs, (bs) => (b: B) => pipe(bs, append(b))),\n      f(i, a)\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1647,
        "to": 1655
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (fa: ReadonlyArray<A>) => HKT<F, ReadonlyArray<B>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), compact)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1661,
        "to": 1666
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B, C>(\n  f: (a: A) => HKT<F, Either<B, C>>\n) => (fa: ReadonlyArray<A>) => HKT<F, Separated<ReadonlyArray<B>, ReadonlyArray<C>>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), separate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (fa: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<readonly B[], readonly C[]>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1672,
        "to": 1679
      }
    }
  },
  {
    "name": "unfold",
    "text": "const unfold = <A, B>(b: B, f: (b: B) => Option<readonly [A, B]>): ReadonlyArray<A> => {\n  const out: Array<A> = []\n  let bb: B = b\n  while (true) {\n    const mt = f(bb)\n    if (O.isSome(mt)) {\n      const [a, b] = mt.value\n      out.push(a)\n      bb = b\n    } else {\n      break\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, B]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1685,
        "to": 1699
      }
    }
  },
  {
    "name": "getShow",
    "text": "const getShow = <A>(S: Show<A>): Show<ReadonlyArray<A>> => ({\n  show: (as) => `[${as.map(S.show).join(', ')}]`\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1727,
        "to": 1729
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A = never>(): Semigroup<ReadonlyArray<A>> => ({\n  concat: (first, second) => (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second))\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1735,
        "to": 1737
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "const getMonoid = <A = never>(): Monoid<ReadonlyArray<A>> => ({\n  concat: getSemigroup<A>().concat,\n  empty\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1751,
        "to": 1754
      }
    }
  },
  {
    "name": "getEq",
    "text": "const getEq = <A>(E: Eq<A>): Eq<ReadonlyArray<A>> =>\n  fromEquals((xs, ys) => xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1772,
        "to": 1773
      }
    }
  },
  {
    "name": "getOrd",
    "text": "const getOrd = <A>(O: Ord<A>): Ord<ReadonlyArray<A>> =>\n  fromCompare((a, b) => {\n    const aLen = a.length\n    const bLen = b.length\n    const len = Math.min(aLen, bLen)\n    for (let i = 0; i < len; i++) {\n      const ordering = O.compare(a[i], b[i])\n      if (ordering !== 0) {\n        return ordering\n      }\n    }\n    return N.Ord.compare(aLen, bLen)\n  })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<readonly A[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 1794,
        "to": 1806
      }
    }
  },
  {
    "name": "unsafeUpdateAt",
    "text": "const unsafeUpdateAt = <A>(i: number, a: A, as: ReadonlyArray<A>): ReadonlyArray<A> =>\n  isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2109,
        "to": 2110
      }
    }
  },
  {
    "name": "unsafeDeleteAt",
    "text": "const unsafeDeleteAt = <A>(i: number, as: ReadonlyArray<A>): ReadonlyArray<A> => {\n  const xs = as.slice()\n  xs.splice(i, 1)\n  return xs\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2116,
        "to": 2120
      }
    }
  },
  {
    "name": "toArray",
    "text": "const toArray = <A>(as: ReadonlyArray<A>): Array<A> => as.slice()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2130,
        "to": 2130
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <A>(as: Array<A>): ReadonlyArray<A> => (isEmpty(as) ? empty : as.slice())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2136,
        "to": 2136
      }
    }
  },
  {
    "name": "every",
    "text": "const every = <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>): boolean => as.every(predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2163,
        "to": 2163
      }
    }
  },
  {
    "name": "some",
    "text": "const some = <A>(predicate: Predicate<A>) => (as: ReadonlyArray<A>): as is ReadonlyNonEmptyArray<A> =>\n  as.some(predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => as is import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyArray.ts",
      "lines": {
        "from": 2179,
        "to": 2180
      }
    }
  },
  {
    "name": "fromMap",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function fromMap<K, A>(m: Map<K, A>): ReadonlyMap<K, A> {\n  return new Map(m)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "m",
          "type": {
            "__tag": "Other",
            "values": "Map<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 38,
        "to": 40
      }
    }
  },
  {
    "name": "toMap",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toMap<K, A>(m: ReadonlyMap<K, A>): Map<K, A> {\n  return new Map(m)\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "m",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Map<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 46,
        "to": 48
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<K, A>(SK: Show<K>, SA: Show<A>): Show<ReadonlyMap<K, A>> {\n  return {\n    show: (m) => {\n      const entries: Array<string> = []\n      m.forEach((a, k) => {\n        entries.push(`[${SK.show(k)}, ${SA.show(a)}]`)\n      })\n      return `new Map([${entries.sort().join(', ')}])`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 54,
        "to": 64
      }
    }
  },
  {
    "name": "size",
    "text": "\n\n/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.5.0\n */\nexport function size<K, A>(d: ReadonlyMap<K, A>): number {\n  return d.size\n}",
    "docs": "/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "d",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "\n\n/**\n * Test whether or not a map is empty\n *\n * @since 2.5.0\n */\nexport function isEmpty<K, A>(d: ReadonlyMap<K, A>): boolean {\n  return d.size === 0\n}",
    "docs": "/**\n * Test whether or not a map is empty\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "d",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 80,
        "to": 82
      }
    }
  },
  {
    "name": "member",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not a key exists in a map\n *\n * @since 2.5.0\n */\nexport function member<K>(\n  E: Eq<K>\n): {\n  (k: K): <A>(m: ReadonlyMap<K, A>) => boolean\n  <A>(k: K, m: ReadonlyMap<K, A>): boolean\n}",
    "docs": "/**\n * Test whether or not a key exists in a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (k: K): <A>(m: ReadonlyMap<K, A>) => boolean; <A>(k: K, m: ReadonlyMap<K, A>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 90,
        "to": 95
      }
    }
  },
  {
    "name": "member",
    "text": "\nexport function member<K>(E: Eq<K>): <A>(k: K, m?: ReadonlyMap<K, A>) => boolean | ((m: ReadonlyMap<K, A>) => boolean) {\n  const lookupE = lookup(E)\n  return (k, m?) => {\n    if (m === undefined) {\n      const memberE = member(E)\n      return (m) => memberE(k, m)\n    }\n    return O.isSome(lookupE(k, m))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m?: ReadonlyMap<K, A>) => boolean | ((m: ReadonlyMap<K, A>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 96,
        "to": 105
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not a value is a member of a map\n *\n * @since 2.5.0\n */\nexport function elem<A>(\n  E: Eq<A>\n): {\n  (a: A): <K>(m: ReadonlyMap<K, A>) => boolean\n  <K>(a: A, m: ReadonlyMap<K, A>): boolean\n}",
    "docs": "/**\n * Test whether or not a value is a member of a map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (a: A): <K>(m: ReadonlyMap<K, A>) => boolean; <K>(a: A, m: ReadonlyMap<K, A>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 118,
        "to": 123
      }
    }
  },
  {
    "name": "elem",
    "text": "\nexport function elem<A>(E: Eq<A>): <K>(a: A, m?: ReadonlyMap<K, A>) => boolean | ((m: ReadonlyMap<K, A>) => boolean) {\n  return (a, m?) => {\n    if (m === undefined) {\n      const elemE = elem(E)\n      return (m) => elemE(a, m)\n    }\n    const values = m.values()\n    let e: Next<A>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const v = e.value\n      if (E.equals(a, v)) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(a: A, m?: ReadonlyMap<K, A>) => boolean | ((m: ReadonlyMap<K, A>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 124,
        "to": 141
      }
    }
  },
  {
    "name": "collect",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function collect<K>(O: Ord<K>): <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => ReadonlyArray<B> {\n  const keysO = keys(O)\n  return <A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>): ReadonlyArray<B> => {\n    const out: Array<B> = []\n    const ks = keysO(m)\n    for (const key of ks) {\n      out.push(f(key, m.get(key)!))\n    }\n    return out\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: K, a: A) => B) => (m: ReadonlyMap<K, A>) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 162,
        "to": 172
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a map into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function toUnfoldable<K, F extends URIS>(\n  ord: Ord<K>,\n  U: Unfoldable1<F>\n): <A>(d: ReadonlyMap<K, A>) => Kind<F, readonly [K, A]>",
    "docs": "/**\n * Unfolds a map into a list of key/value pairs\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 188,
        "to": 191
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(ord: Ord<K>, U: Unfoldable<F>): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 192,
        "to": 192
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<K, F>(\n  ord: Ord<K>,\n  U: Unfoldable<F>\n): <A>(d: ReadonlyMap<K, A>) => HKT<F, readonly [K, A]> {\n  const toReadonlyArrayO = toReadonlyArray(ord)\n  return (d) => {\n    const kas = toReadonlyArrayO(d)\n    const len = kas.length\n    return U.unfold(0, (b) => (b < len ? O.some([kas[b], b + 1]) : O.none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ord",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        },
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(d: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 193,
        "to": 203
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */\nexport function pop<K>(E: Eq<K>): (k: K) => <A>(m: ReadonlyMap<K, A>) => Option<readonly [A, ReadonlyMap<K, A>]> {\n  const lookupE = lookup(E)\n  const deleteAtE = deleteAt(E)\n  return (k) => {\n    const deleteAtEk = deleteAtE(k)\n    return (m) =>\n      pipe(\n        lookupE(k, m),\n        O.map((a) => [a, deleteAtEk(m)])\n      )\n  }\n}",
    "docs": "/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, ReadonlyMap<K, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 286,
        "to": 297
      }
    }
  },
  {
    "name": "lookupWithKey",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.5.0\n */\nexport function lookupWithKey<K>(\n  E: Eq<K>\n): {\n  (k: K): <A>(m: ReadonlyMap<K, A>) => Option<readonly [K, A]>\n  <A>(k: K, m: ReadonlyMap<K, A>): Option<readonly [K, A]>\n}",
    "docs": "/**\n * Lookup the value for a key in a `Map`.\n * If the result is a `Some`, the existing key is also returned.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (k: K): <A>(m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [K, A]>; <A>(k: K, m: ReadonlyMap<K, A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [K, A]>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 306,
        "to": 311
      }
    }
  },
  {
    "name": "lookupWithKey",
    "text": "\nexport function lookupWithKey<K>(\n  E: Eq<K>\n): <A>(k: K, m?: ReadonlyMap<K, A>) => Option<readonly [K, A]> | ((m: ReadonlyMap<K, A>) => Option<readonly [K, A]>) {\n  return <A>(k: K, m?: ReadonlyMap<K, A>) => {\n    if (m === undefined) {\n      const lookupWithKeyE = lookupWithKey(E)\n      return (m) => lookupWithKeyE(k, m)\n    }\n    const entries = m.entries()\n    let e: Next<readonly [K, A]>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = entries.next()).done) {\n      const [ka, a] = e.value\n      if (E.equals(ka, k)) {\n        return O.some([ka, a])\n      }\n    }\n    return O.none\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m?: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<readonly [K, A]> | ((m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [K, A]>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 312,
        "to": 331
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Map`.\n *\n * @since 2.5.0\n */\nexport function lookup<K>(\n  E: Eq<K>\n): {\n  (k: K): <A>(m: ReadonlyMap<K, A>) => Option<A>\n  <A>(k: K, m: ReadonlyMap<K, A>): Option<A>\n}",
    "docs": "/**\n * Lookup the value for a key in a `Map`.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (k: K): <A>(m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>; <A>(k: K, m: ReadonlyMap<K, A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 339,
        "to": 344
      }
    }
  },
  {
    "name": "lookup",
    "text": "\nexport function lookup<K>(\n  E: Eq<K>\n): <A>(k: K, m?: ReadonlyMap<K, A>) => Option<A> | ((m: ReadonlyMap<K, A>) => Option<A>) {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, m?) => {\n    if (m === undefined) {\n      const lookupE = lookup(E)\n      return (m) => lookupE(k, m)\n    }\n    return pipe(\n      lookupWithKeyE(k, m),\n      O.map(([_, a]) => a)\n    )\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, m?: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<A> | ((m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 345,
        "to": 359
      }
    }
  },
  {
    "name": "isSubmap",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not one `Map` contains all of the keys and values contained in another `Map`\n *\n * @since 2.5.0\n */\nexport function isSubmap<K, A>(\n  SK: Eq<K>,\n  SA: Eq<A>\n): {\n  (that: ReadonlyMap<K, A>): (me: ReadonlyMap<K, A>) => boolean\n  (me: ReadonlyMap<K, A>, that: ReadonlyMap<K, A>): boolean\n}",
    "docs": "/**\n * Test whether or not one `Map` contains all of the keys and values contained in another `Map`\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: ReadonlyMap<K, A>): (me: ReadonlyMap<K, A>) => boolean; (me: ReadonlyMap<K, A>, that: ReadonlyMap<K, A>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 367,
        "to": 373
      }
    }
  },
  {
    "name": "isSubmap",
    "text": "\nexport function isSubmap<K, A>(\n  SK: Eq<K>,\n  SA: Eq<A>\n): (me: ReadonlyMap<K, A>, that?: ReadonlyMap<K, A>) => boolean | ((me: ReadonlyMap<K, A>) => boolean) {\n  const lookupWithKeyS = lookupWithKey(SK)\n  return (me: ReadonlyMap<K, A>, that?: ReadonlyMap<K, A>) => {\n    if (that === undefined) {\n      const isSubmapSKSA = isSubmap(SK, SA)\n      return (that) => isSubmapSKSA(that, me)\n    }\n    const entries = me.entries()\n    let e: Next<readonly [K, A]>\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = entries.next()).done) {\n      const [k, a] = e.value\n      const d2OptA = lookupWithKeyS(k, that)\n      if (O.isNone(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: ReadonlyMap<K, A>, that?: ReadonlyMap<K, A>) => boolean | ((me: ReadonlyMap<K, A>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 374,
        "to": 396
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<K, A>(SK: Eq<K>, SA: Eq<A>): Eq<ReadonlyMap<K, A>> {\n  const isSubmapSKSA = isSubmap(SK, SA)\n  return fromEquals((x, y) => isSubmapSKSA(x, y) && isSubmapSKSA(y, x))\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 409,
        "to": 412
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid<K, A>(SK: Eq<K>, SA: Semigroup<A>): Monoid<ReadonlyMap<K, A>> {\n  const lookupWithKeyS = lookupWithKey(SK)\n  return {\n    concat: (mx, my) => {\n      if (isEmpty(mx)) {\n        return my\n      }\n      if (isEmpty(my)) {\n        return mx\n      }\n      const r = new Map(mx)\n      const entries = my.entries()\n      let e: Next<readonly [K, A]>\n      // tslint:disable-next-line: strict-boolean-expressions\n      while (!(e = entries.next()).done) {\n        const [k, a] = e.value\n        const mxOptA = lookupWithKeyS(k, mx)\n        if (O.isSome(mxOptA)) {\n          r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a))\n        } else {\n          r.set(k, a)\n        }\n      }\n      return r\n    },\n    empty\n  }\n}",
    "docs": "/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SK",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 420,
        "to": 447
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.5.0\n */\nexport function fromFoldable<F extends URIS3, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "/**\n * Create a map from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 464,
        "to": 468
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 469,
        "to": 473
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 474,
        "to": 478
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 479,
        "to": 483
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, K, A>(\n  E: Eq<K>,\n  M: Magma<A>,\n  F: Foldable<F>\n): (fka: HKT<F, readonly [K, A]>) => ReadonlyMap<K, A> {\n  return (fka: HKT<F, readonly [K, A]>) => {\n    const lookupWithKeyE = lookupWithKey(E)\n    return F.reduce<readonly [K, A], Map<K, A>>(fka, new Map<K, A>(), (b, [k, a]) => {\n      const bOpt = lookupWithKeyE(k, b)\n      if (O.isSome(bOpt)) {\n        b.set(bOpt.value[0], M.concat(bOpt.value[1], a))\n      } else {\n        b.set(k, a)\n      }\n      return b\n    })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 484,
        "to": 501
      }
    }
  },
  {
    "name": "getFilterableWithIndex",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getFilterableWithIndex<K = never>(): FilterableWithIndex2C<URI, K, K> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact,\n    separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").FilterableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 743,
        "to": 760
      }
    }
  },
  {
    "name": "getWitherable",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getWitherable<K>(O: Ord<K>): Witherable2C<URI, K> & TraversableWithIndex2C<URI, K, K> {\n  const TWI = getTraversableWithIndex(O)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact,\n    separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: TWI.reduce,\n    foldMap: TWI.foldMap,\n    reduceRight: TWI.reduceRight,\n    traverse: TWI.traverse,\n    sequence: TWI.sequence,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: TWI.reduceWithIndex,\n    foldMapWithIndex: TWI.foldMapWithIndex,\n    reduceRightWithIndex: TWI.reduceRightWithIndex,\n    traverseWithIndex: TWI.traverseWithIndex,\n    wilt: <F>(\n      F: Applicative<F>\n    ): (<A, B, C>(\n      wa: ReadonlyMap<K, A>,\n      f: (a: A) => HKT<F, Either<B, C>>\n    ) => HKT<F, Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>>) => {\n      const traverseF = TWI.traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), separate)\n    },\n    wither: <F>(\n      F: Applicative<F>\n    ): (<A, B>(wa: ReadonlyMap<K, A>, f: (a: A) => HKT<F, Option<B>>) => HKT<F, ReadonlyMap<K, B>>) => {\n      const traverseF = TWI.traverse(F)\n      return (wa, f) => F.map(traverseF(wa, f), compact)\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Witherable\").Witherable2C<\"ReadonlyMap\", K> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TraversableWithIndex\").TraversableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 963,
        "to": 1001
      }
    }
  },
  {
    "name": "keys",
    "text": "const keys = <K>(O: Ord<K>) => <A>(m: ReadonlyMap<K, A>): ReadonlyArray<K> =>\n  Array.from(m.keys()).sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: ReadonlyMap<K, A>) => readonly K[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 148,
        "to": 149
      }
    }
  },
  {
    "name": "values",
    "text": "const values = <A>(O: Ord<A>) => <K>(m: ReadonlyMap<K, A>): ReadonlyArray<A> =>\n  Array.from(m.values()).sort(O.compare)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(m: ReadonlyMap<K, A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 156,
        "to": 157
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "const toReadonlyArray = <K>(O: Ord<K>): (<A>(m: ReadonlyMap<K, A>) => ReadonlyArray<readonly [K, A]>) =>\n  collect(O)((k, a) => [k, a] as const)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(m: ReadonlyMap<K, A>) => readonly (readonly [K, A])[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 179,
        "to": 180
      }
    }
  },
  {
    "name": "upsertAt",
    "text": "const upsertAt = <K>(E: Eq<K>): (<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, a) => {\n    const lookupWithKeyEk = lookupWithKeyE(k)\n    return (m) => {\n      const found = lookupWithKeyEk(m)\n      if (O.isNone(found)) {\n        const out = new Map(m)\n        out.set(k, a)\n        return out\n      } else if (found.value[1] !== a) {\n        const out = new Map(m)\n        out.set(found.value[0], a)\n        return out\n      }\n      return m\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 211,
        "to": 229
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "const deleteAt = <K>(E: Eq<K>): ((k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isSome(found)) {\n      const r = new Map(m)\n      r.delete(found.value[0])\n      return r\n    }\n    return m\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(k: K) => <A>(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 237,
        "to": 248
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <K>(E: Eq<K>): (<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => Option<ReadonlyMap<K, A>>) => {\n  const modifyAtE = modifyAt(E)\n  return (k, a) => modifyAtE(k, () => a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, a: A) => (m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 253,
        "to": 256
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <K>(\n  E: Eq<K>\n): (<A>(k: K, f: (a: A) => A) => (m: ReadonlyMap<K, A>) => Option<ReadonlyMap<K, A>>) => {\n  const lookupWithKeyE = lookupWithKey(E)\n  return (k, f) => (m) => {\n    const found = lookupWithKeyE(k, m)\n    if (O.isNone(found)) {\n      return O.none\n    }\n    const [fk, fv] = found.value\n    const next = f(fv)\n    if (next === fv) {\n      return O.some(m)\n    }\n    const r = new Map(m)\n    r.set(fk, next)\n    return O.some(r)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(k: K, f: (a: A) => A) => (m: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 261,
        "to": 279
      }
    }
  },
  {
    "name": "singleton",
    "text": "const singleton = <K, A>(k: K, a: A): ReadonlyMap<K, A> => new Map([[k, a]])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 455,
        "to": 455
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "const partitionMapWithIndex = <K, A, B, C>(f: (k: K, a: A) => Either<B, C>) => (\n  fa: ReadonlyMap<K, A>\n): Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>> => {\n  const left = new Map<K, B>()\n  const right = new Map<K, C>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    const ei = f(k, a)\n    if (isLeft(ei)) {\n      left.set(k, ei.left)\n    } else {\n      right.set(k, ei.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 519,
        "to": 537
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "const partitionWithIndex = <K, A>(p: (k: K, a: A) => boolean) => (\n  fa: ReadonlyMap<K, A>\n): Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>> => {\n  const left = new Map<K, A>()\n  const right = new Map<K, A>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    if (p(k, a)) {\n      right.set(k, a)\n    } else {\n      left.set(k, a)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "p",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 543,
        "to": 560
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "const filterMapWithIndex = <K, A, B>(f: (k: K, a: A) => Option<B>) => (\n  fa: ReadonlyMap<K, A>\n): ReadonlyMap<K, B> => {\n  const m = new Map<K, B>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    const o = f(k, a)\n    if (O.isSome(o)) {\n      m.set(k, o.value)\n    }\n  }\n  return m\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 566,
        "to": 581
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex = <K, A>(p: (k: K, a: A) => boolean) => (m: ReadonlyMap<K, A>): ReadonlyMap<K, A> => {\n  const out = new Map<K, A>()\n  const entries = m.entries()\n  let e: Next<readonly [K, A]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, a] = e.value\n    if (p(k, a)) {\n      out.set(k, a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "p",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(m: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 587,
        "to": 599
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <K, A>(fa: ReadonlyMap<K, Option<A>>): ReadonlyMap<K, A> => {\n  const m = new Map<K, A>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, Option<A>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, oa] = e.value\n    if (O.isSome(oa)) {\n      m.set(k, oa.value)\n    }\n  }\n  return m\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 627,
        "to": 639
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>\n  <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, A>\n} = <A>(predicate: Predicate<A>) => <K>(fa: ReadonlyMap<K, A>) => _filter(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 645,
        "to": 648
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(f: (a: A) => Option<B>) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B> = (f) => (\n  fa\n) => _filterMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 654,
        "to": 656
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B> = (f) => (fa) => _map(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 665,
        "to": 665
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex: <K, A, B>(f: (k: K, a: A) => B) => (fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B> = (f) => (\n  fa\n) => _mapWithIndex(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlyMap<K, A>) => ReadonlyMap<K, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 671,
        "to": 673
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): <K>(\n    fa: ReadonlyMap<K, A>\n  ) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>\n  <A>(predicate: Predicate<A>): <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>\n} = <A>(predicate: Predicate<A>) => <K>(fa: ReadonlyMap<K, A>) => _partition(fa, predicate)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlyMap<K, A>, ReadonlyMap<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 679,
        "to": 684
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => <K>(fa: ReadonlyMap<K, A>) => Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>> = (f) => (fa) => _partitionMap(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K>(fa: ReadonlyMap<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlyMap<K, B>, ReadonlyMap<K, C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 690,
        "to": 692
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <K, A, B>(\n  fa: ReadonlyMap<K, Either<A, B>>\n): Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>> => {\n  const left = new Map<K, A>()\n  const right = new Map<K, B>()\n  const entries = fa.entries()\n  let e: Next<readonly [K, Either<A, B>]>\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!(e = entries.next()).done) {\n    const [k, ei] = e.value\n    if (isLeft(ei)) {\n      left.set(k, ei.left)\n    } else {\n      right.set(k, ei.right)\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "ReadonlyMap<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlyMap<K, A>, ReadonlyMap<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 698,
        "to": 715
      }
    }
  },
  {
    "name": "getFunctorWithIndex",
    "text": "const getFunctorWithIndex = <K = never>(): FunctorWithIndex2C<URI, K, K> => ({\n  URI,\n  _E: undefined as any,\n  map: _map,\n  mapWithIndex: _mapWithIndex\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FunctorWithIndex\").FunctorWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 785,
        "to": 790
      }
    }
  },
  {
    "name": "getFoldable",
    "text": "const getFoldable = <K>(O: Ord<K>): Foldable2C<URI, K> => {\n  const FWI = getFoldableWithIndex(O)\n  return {\n    URI,\n    _E: undefined as any,\n    reduce: FWI.reduce,\n    foldMap: FWI.foldMap,\n    reduceRight: FWI.reduceRight\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2C<\"ReadonlyMap\", K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 821,
        "to": 830
      }
    }
  },
  {
    "name": "getFoldableWithIndex",
    "text": "const getFoldableWithIndex = <K>(O: Ord<K>): FoldableWithIndex2C<URI, K, K> => {\n  const keysO = keys(O)\n\n  const reduceWithIndex = <B, A>(fa: ReadonlyMap<K, A>, b: B, f: (k: K, b: B, a: A) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = f(k, out, fa.get(k)!)\n    }\n    return out\n  }\n\n  const foldMapWithIndex = <M>(M: Monoid<M>) => <A>(fa: ReadonlyMap<K, A>, f: (k: K, a: A) => M): M => {\n    let out: M = M.empty\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = M.concat(out, f(k, fa.get(k)!))\n    }\n    return out\n  }\n\n  const reduceRightWithIndex = <B, A>(fa: ReadonlyMap<K, A>, b: B, f: (k: K, a: A, b: B) => B): B => {\n    let out: B = b\n    const ks = keysO(fa)\n    const len = ks.length\n    for (let i = len - 1; i >= 0; i--) {\n      const k = ks[i]\n      out = f(k, fa.get(k)!, out)\n    }\n    return out\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    reduce: (fa, b, f) => reduceWithIndex(fa, b, (_, b, a) => f(b, a)),\n    foldMap: (M) => {\n      const foldMapWithIndexM = foldMapWithIndex(M)\n      return (fa, f) => foldMapWithIndexM(fa, (_, a) => f(a))\n    },\n    reduceRight: (fa, b, f) => reduceRightWithIndex(fa, b, (_, a, b) => f(a, b)),\n    reduceWithIndex,\n    foldMapWithIndex,\n    reduceRightWithIndex\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FoldableWithIndex\").FoldableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 836,
        "to": 885
      }
    }
  },
  {
    "name": "getTraversable",
    "text": "const getTraversable = <K>(O: Ord<K>): Traversable2C<URI, K> => {\n  const TWI = getTraversableWithIndex(O)\n  const F = getFoldable(O)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    reduce: F.reduce,\n    foldMap: F.foldMap,\n    reduceRight: F.reduceRight,\n    traverse: TWI.traverse,\n    sequence: TWI.sequence\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable2C<\"ReadonlyMap\", K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 891,
        "to": 904
      }
    }
  },
  {
    "name": "getTraversableWithIndex",
    "text": "const getTraversableWithIndex = <K>(O: Ord<K>): TraversableWithIndex2C<URI, K, K> => {\n  const FWI = getFoldableWithIndex(O)\n  const keysO = keys(O)\n  const traverseWithIndex = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ta: ReadonlyMap<K, A>, f: (k: K, a: A) => HKT<F, B>) => HKT<F, ReadonlyMap<K, B>>) => {\n    return <A, B>(ta: ReadonlyMap<K, A>, f: (k: K, a: A) => HKT<F, B>) => {\n      let fm: HKT<F, Map<K, B>> = F.of(new Map())\n      const ks = keysO(ta)\n      const len = ks.length\n      for (let i = 0; i < len; i++) {\n        const key = ks[i]\n        const a = ta.get(key)!\n        fm = F.ap(\n          F.map(fm, (m) => (b: B) => m.set(key, b)),\n          f(key, a)\n        )\n      }\n      return fm\n    }\n  }\n  const traverse = <F>(\n    F: Applicative<F>\n  ): (<A, B>(ta: ReadonlyMap<K, A>, f: (a: A) => HKT<F, B>) => HKT<F, ReadonlyMap<K, B>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta, f) => traverseWithIndexF(ta, (_, a) => f(a))\n  }\n\n  const sequence = <F>(F: Applicative<F>): (<A>(ta: ReadonlyMap<K, HKT<F, A>>) => HKT<F, ReadonlyMap<K, A>>) => {\n    const traverseWithIndexF = traverseWithIndex(F)\n    return (ta) => traverseWithIndexF(ta, (_, a) => a)\n  }\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: FWI.reduce,\n    foldMap: FWI.foldMap,\n    reduceRight: FWI.reduceRight,\n    reduceWithIndex: FWI.reduceWithIndex,\n    foldMapWithIndex: FWI.foldMapWithIndex,\n    reduceRightWithIndex: FWI.reduceRightWithIndex,\n    traverse,\n    sequence,\n    traverseWithIndex\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<K>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TraversableWithIndex\").TraversableWithIndex2C<\"ReadonlyMap\", K, K>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyMap.ts",
      "lines": {
        "from": 910,
        "to": 957
      }
    }
  },
  {
    "name": "concat",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function concat<A>(first: ReadonlyArray<A>, second: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A>",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 237,
        "to": 237
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(first: ReadonlyNonEmptyArray<A>, second: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 238,
        "to": 238
      }
    }
  },
  {
    "name": "concat",
    "text": "\nexport function concat<A>(first: ReadonlyArray<A>, second: ReadonlyArray<A>): ReadonlyArray<A> {\n  return first.concat(second)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "first",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "second",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 239,
        "to": 241
      }
    }
  },
  {
    "name": "group",
    "text": "\n\n/**\n * Group equal, consecutive elements of a `ReadonlyArray` into `ReadonlyNonEmptyArray`s.\n *\n * @example\n * import { group } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(group(N.Eq)([1, 2, 1, 1]), [\n *   [1],\n *   [2],\n *   [1, 1]\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function group<B>(\n  E: Eq<B>\n): {\n  <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n  <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>\n}",
    "docs": "/**\n * Group equal, consecutive elements of a `ReadonlyArray` into `ReadonlyNonEmptyArray`s.\n *\n * @example\n * import { group } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(group(N.Eq)([1, 2, 1, 1]), [\n *   [1],\n *   [2],\n *   [1, 1]\n * ])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>; <A extends B>(as: readonly A[]): readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 266,
        "to": 271
      }
    }
  },
  {
    "name": "group",
    "text": "\nexport function group<A>(E: Eq<A>): (as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyNonEmptyArray<A>> {\n  return (as) => {\n    const len = as.length\n    if (len === 0) {\n      return empty\n    }\n    const out: Array<ReadonlyNonEmptyArray<A>> = []\n    let head: A = as[0]\n    let nea: NonEmptyArray<A> = [head]\n    for (let i = 1; i < len; i++) {\n      const a = as[i]\n      if (E.equals(a, head)) {\n        nea.push(a)\n      } else {\n        out.push(nea)\n        head = a\n        nea = [head]\n      }\n    }\n    out.push(nea)\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 272,
        "to": 294
      }
    }
  },
  {
    "name": "groupSort",
    "text": "\n\n/**\n * Sort and then group the elements of a `ReadonlyArray` into `ReadonlyNonEmptyArray`s.\n *\n * @example\n * import { groupSort } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(groupSort(N.Ord)([1, 2, 1, 1]), [[1, 1, 1], [2]])\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function groupSort<B>(\n  O: Ord<B>\n): {\n  <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>\n  <A extends B>(as: ReadonlyArray<A>): ReadonlyArray<ReadonlyNonEmptyArray<A>>\n}",
    "docs": "/**\n * Sort and then group the elements of a `ReadonlyArray` into `ReadonlyNonEmptyArray`s.\n *\n * @example\n * import { groupSort } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(groupSort(N.Ord)([1, 2, 1, 1]), [[1, 1, 1], [2]])\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>): import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>; <A extends B>(as: readonly A[]): readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 308,
        "to": 313
      }
    }
  },
  {
    "name": "groupSort",
    "text": "\nexport function groupSort<A>(O: Ord<A>): (as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyNonEmptyArray<A>> {\n  const sortO = sort(O)\n  const groupO = group(O)\n  return (as) => (isNonEmpty(as) ? groupO(sortO(as)) : empty)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 314,
        "to": 318
      }
    }
  },
  {
    "name": "zip",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.1\n */\nexport function zip<B>(\n  bs: ReadonlyNonEmptyArray<B>\n): <A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<readonly [A, B]>",
    "docs": "/**\n * @category combinators\n * @since 2.5.1\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<readonly [A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 393,
        "to": 395
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(\n  as: ReadonlyNonEmptyArray<A>,\n  bs: ReadonlyNonEmptyArray<B>\n): ReadonlyNonEmptyArray<readonly [A, B]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<readonly [A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 396,
        "to": 399
      }
    }
  },
  {
    "name": "zip",
    "text": "\nexport function zip<A, B>(\n  as: ReadonlyNonEmptyArray<A>,\n  bs?: ReadonlyNonEmptyArray<B>\n): ReadonlyNonEmptyArray<readonly [A, B]> | ((bs: ReadonlyNonEmptyArray<B>) => ReadonlyNonEmptyArray<readonly [B, A]>) {\n  if (bs === undefined) {\n    return (bs) => zip(bs, as)\n  }\n  return zipWith(as, bs, (a, b) => [a, b])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<readonly [A, B]> | ((bs: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<readonly [B, A]>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 400,
        "to": 408
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n/**\n * Use [`filter`](./ReadonlyArray.ts.html#filter) instead.\n *\n * @category combinators\n * @since 2.5.0\n * @deprecated\n */\nexport function filter<A, B extends A>(\n  refinement: Refinement<A, B>\n): (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<B>>",
    "docs": "/**\n * Use [`filter`](./ReadonlyArray.ts.html#filter) instead.\n *\n * @category combinators\n * @since 2.5.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1121,
        "to": 1123
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1124,
        "to": 1124
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>> {\n  // tslint:disable-next-line: deprecation\n  return filterWithIndex((_, a) => predicate(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1125,
        "to": 1128
      }
    }
  },
  {
    "name": "cons",
    "text": "\n\n/**\n * Use [`prepend`](./ReadonlyArray.ts.html#prepend) instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */\nexport function cons<A>(head: A): (tail: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>",
    "docs": "/**\n * Use [`prepend`](./ReadonlyArray.ts.html#prepend) instead.\n *\n * @category constructors\n * @since 2.5.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tail: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1166,
        "to": 1166
      }
    }
  },
  {
    "name": "cons",
    "text": "\n/** @deprecated */\nexport function cons<A>(head: A, tail: ReadonlyArray<A>): ReadonlyNonEmptyArray<A>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1168,
        "to": 1168
      }
    }
  },
  {
    "name": "cons",
    "text": "\nexport function cons<A>(\n  head: A,\n  tail?: ReadonlyArray<A>\n): ReadonlyNonEmptyArray<A> | ((tail: ReadonlyArray<A>) => ReadonlyNonEmptyArray<A>) {\n  return tail === undefined ? prepend(head) : pipe(tail, prepend(head))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "tail",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A> | ((tail: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1169,
        "to": 1174
      }
    }
  },
  {
    "name": "isNonEmpty",
    "text": "const isNonEmpty = <A>(as: ReadonlyArray<A>): as is ReadonlyNonEmptyArray<A> => as.length > 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 67,
        "to": 67
      }
    }
  },
  {
    "name": "isOutOfBound",
    "text": "const isOutOfBound = <A>(i: number, as: ReadonlyArray<A>): boolean => i < 0 || i >= as.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 72,
        "to": 72
      }
    }
  },
  {
    "name": "prepend",
    "text": "const prepend = <A>(head: A) => (tail: ReadonlyArray<A>): ReadonlyNonEmptyArray<A> => [head, ...tail]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "head",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tail: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 77,
        "to": 77
      }
    }
  },
  {
    "name": "append",
    "text": "const append = <A>(end: A) => (init: ReadonlyArray<A>): ReadonlyNonEmptyArray<A> => concat(init, [end])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "end",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(init: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 82,
        "to": 82
      }
    }
  },
  {
    "name": "unsafeInsertAt",
    "text": "const unsafeInsertAt = <A>(i: number, a: A, as: ReadonlyArray<A>): ReadonlyNonEmptyArray<A> => {\n  if (isNonEmpty(as)) {\n    const xs = _.fromReadonlyNonEmptyArray(as)\n    xs.splice(i, 0, a)\n    return xs\n  }\n  return [a]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 87,
        "to": 94
      }
    }
  },
  {
    "name": "unsafeUpdateAt",
    "text": "const unsafeUpdateAt = <A>(i: number, a: A, as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> => {\n  if (as[i] === a) {\n    return as\n  } else {\n    const xs = _.fromReadonlyNonEmptyArray(as)\n    xs[i] = a\n    return xs\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 99,
        "to": 107
      }
    }
  },
  {
    "name": "uniq",
    "text": "const uniq = <A>(E: Eq<A>) => (as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> => {\n  if (as.length === 1) {\n    return as\n  }\n  const out: NonEmptyArray<A> = [head(as)]\n  const rest = tail(as)\n  for (const a of rest) {\n    if (out.every((o) => !E.equals(o, a))) {\n      out.push(a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 112,
        "to": 124
      }
    }
  },
  {
    "name": "sortBy",
    "text": "const sortBy = <B>(\n  ords: ReadonlyArray<Ord<B>>\n): (<A extends B>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>) => {\n  if (isNonEmpty(ords)) {\n    const M = getMonoid<B>()\n    return sort(ords.reduce(M.concat, M.empty))\n  }\n  return identity\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ords",
          "type": {
            "__tag": "Other",
            "values": "readonly import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 129,
        "to": 137
      }
    }
  },
  {
    "name": "union",
    "text": "const union = <A>(E: Eq<A>): Semigroup<ReadonlyNonEmptyArray<A>>['concat'] => {\n  const uniqE = uniq(E)\n  return (first, second) => uniqE(concat(first, second))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(x: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>, y: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 142,
        "to": 145
      }
    }
  },
  {
    "name": "rotate",
    "text": "const rotate = (n: number) => <A>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> => {\n  const len = as.length\n  const m = Math.round(n) % len\n  if (isOutOfBound(Math.abs(m), as) || m === 0) {\n    return as\n  }\n  if (m < 0) {\n    const [f, s] = splitAt(-m)(as)\n    return concat(s, f)\n  } else {\n    return rotate(m - len)(as)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 150,
        "to": 162
      }
    }
  },
  {
    "name": "makeBy",
    "text": "const makeBy = <A>(n: number, f: (i: number) => A): ReadonlyNonEmptyArray<A> => {\n  const j = Math.max(0, Math.floor(n))\n  const out: NonEmptyArray<A> = [f(0)]\n  for (let i = 1; i < j; i++) {\n    out.push(f(i))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 167,
        "to": 174
      }
    }
  },
  {
    "name": "fromReadonlyArray",
    "text": "const fromReadonlyArray = <A>(as: ReadonlyArray<A>): Option<ReadonlyNonEmptyArray<A>> =>\n  isNonEmpty(as) ? O.some(as) : O.none",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 186,
        "to": 187
      }
    }
  },
  {
    "name": "unprepend",
    "text": "const unprepend = <A>(as: ReadonlyNonEmptyArray<A>): readonly [A, ReadonlyArray<A>] => [head(as), tail(as)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [A, readonly A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 204,
        "to": 204
      }
    }
  },
  {
    "name": "unappend",
    "text": "const unappend = <A>(as: ReadonlyNonEmptyArray<A>): readonly [ReadonlyArray<A>, A] => [init(as), last(as)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [readonly A[], A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 217,
        "to": 217
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <A>(as: Array<A>): Option<ReadonlyNonEmptyArray<A>> => fromReadonlyArray(as.slice())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "A[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 227,
        "to": 227
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> =>\n  as.length === 1 ? as : [last(as), ...as.slice(0, -1).reverse()]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 247,
        "to": 248
      }
    }
  },
  {
    "name": "groupBy",
    "text": "const groupBy = <A>(f: (a: A) => string) => (\n  as: ReadonlyArray<A>\n): ReadonlyRecord<string, ReadonlyNonEmptyArray<A>> => {\n  const out: Record<string, NonEmptyArray<A>> = {}\n  for (const a of as) {\n    const k = f(a)\n    if (out.hasOwnProperty(k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => string"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 335,
        "to": 348
      }
    }
  },
  {
    "name": "sort",
    "text": "const sort = <B>(O: Ord<B>) => <A extends B>(as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> =>\n  as.length === 1 ? as : (as.slice().sort(O.compare) as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A extends B>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 354,
        "to": 355
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(i: number, a: A): ((as: ReadonlyNonEmptyArray<A>) => Option<ReadonlyNonEmptyArray<A>>) =>\n  modifyAt(i, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 361,
        "to": 362
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(i: number, f: (a: A) => A) => (\n  as: ReadonlyNonEmptyArray<A>\n): Option<ReadonlyNonEmptyArray<A>> => (isOutOfBound(i, as) ? O.none : O.some(unsafeUpdateAt(i, f(as[i]), as)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 368,
        "to": 370
      }
    }
  },
  {
    "name": "zipWith",
    "text": "const zipWith = <A, B, C>(\n  as: ReadonlyNonEmptyArray<A>,\n  bs: ReadonlyNonEmptyArray<B>,\n  f: (a: A, b: B) => C\n): ReadonlyNonEmptyArray<C> => {\n  const cs: NonEmptyArray<C> = [f(as[0], bs[0])]\n  const len = Math.min(as.length, bs.length)\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(as[i], bs[i])\n  }\n  return cs\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        },
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => C"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<C>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 376,
        "to": 387
      }
    }
  },
  {
    "name": "unzip",
    "text": "const unzip = <A, B>(\n  abs: ReadonlyNonEmptyArray<readonly [A, B]>\n): readonly [ReadonlyNonEmptyArray<A>, ReadonlyNonEmptyArray<B>] => {\n  const fa: NonEmptyArray<A> = [abs[0][0]]\n  const fb: NonEmptyArray<B> = [abs[0][1]]\n  for (let i = 1; i < abs.length; i++) {\n    fa[i] = abs[i][0]\n    fb[i] = abs[i][1]\n  }\n  return [fa, fb]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "abs",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<readonly [A, B]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 414,
        "to": 424
      }
    }
  },
  {
    "name": "prependAll",
    "text": "const prependAll = <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> => {\n  const out: NonEmptyArray<A> = [middle, as[0]]\n  for (let i = 1; i < as.length; i++) {\n    out.push(middle, as[i])\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 437,
        "to": 443
      }
    }
  },
  {
    "name": "intersperse",
    "text": "const intersperse = <A>(middle: A) => (as: ReadonlyNonEmptyArray<A>): ReadonlyNonEmptyArray<A> => {\n  const rest = tail(as)\n  return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 456,
        "to": 459
      }
    }
  },
  {
    "name": "chainWithIndex",
    "text": "const chainWithIndex = <A, B>(f: (i: number, a: A) => ReadonlyNonEmptyArray<B>) => (\n  as: ReadonlyNonEmptyArray<A>\n): ReadonlyNonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = _.fromReadonlyNonEmptyArray(f(0, head(as)))\n  for (let i = 1; i < as.length; i++) {\n    out.push(...f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 465,
        "to": 473
      }
    }
  },
  {
    "name": "chop",
    "text": "const chop = <A, B>(f: (as: ReadonlyNonEmptyArray<A>) => readonly [B, ReadonlyArray<A>]) => (\n  as: ReadonlyNonEmptyArray<A>\n): ReadonlyNonEmptyArray<B> => {\n  const [b, rest] = f(as)\n  const out: NonEmptyArray<B> = [b]\n  let next: ReadonlyArray<A> = rest\n  while (isNonEmpty(next)) {\n    const [b, rest] = f(next)\n    out.push(b)\n    next = rest\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => readonly [B, readonly A[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 483,
        "to": 495
      }
    }
  },
  {
    "name": "splitAt",
    "text": "const splitAt = (n: number) => <A>(\n  as: ReadonlyNonEmptyArray<A>\n): readonly [ReadonlyNonEmptyArray<A>, ReadonlyArray<A>] => {\n  const m = Math.max(1, n)\n  return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => readonly [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>, readonly A[]]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 503,
        "to": 508
      }
    }
  },
  {
    "name": "chunksOf",
    "text": "const chunksOf = (\n  n: number\n): (<A>(as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<ReadonlyNonEmptyArray<A>>) => chop(splitAt(n))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 517,
        "to": 519
      }
    }
  },
  {
    "name": "of",
    "text": "const of: Pointed1<URI>['of'] = (a) => [a]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 577,
        "to": 577
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW = <B>(that: Lazy<ReadonlyNonEmptyArray<B>>) => <A>(\n  as: ReadonlyNonEmptyArray<A>\n): ReadonlyNonEmptyArray<A | B> => concat(as as ReadonlyNonEmptyArray<A | B>, that())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 585,
        "to": 587
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap = <A>(\n  as: ReadonlyNonEmptyArray<A>\n): (<B>(fab: ReadonlyNonEmptyArray<(a: A) => B>) => ReadonlyNonEmptyArray<B>) => chain((f) => pipe(as, map(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 604,
        "to": 606
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain = <A, B>(\n  f: (a: A) => ReadonlyNonEmptyArray<B>\n): ((ma: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>) => chainWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 614,
        "to": 616
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend = <A, B>(f: (as: ReadonlyNonEmptyArray<A>) => B) => (\n  as: ReadonlyNonEmptyArray<A>\n): ReadonlyNonEmptyArray<B> => {\n  let next: ReadonlyArray<A> = tail(as)\n  const out: NonEmptyArray<B> = [f(as)]\n  while (isNonEmpty(next)) {\n    out.push(f(next))\n    next = tail(next)\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 622,
        "to": 632
      }
    }
  },
  {
    "name": "map",
    "text": "const map = <A, B>(f: (a: A) => B): ((as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<B>) =>\n  mapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 661,
        "to": 662
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "const mapWithIndex = <A, B>(f: (i: number, a: A) => B) => (\n  as: ReadonlyNonEmptyArray<A>\n): ReadonlyNonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = [f(0, head(as))]\n  for (let i = 1; i < as.length; i++) {\n    out.push(f(i, as[i]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 668,
        "to": 676
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce = <A, B>(b: B, f: (b: B, a: A) => B): ((as: ReadonlyNonEmptyArray<A>) => B) =>\n  reduceWithIndex(b, (_, b, a) => f(b, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 682,
        "to": 683
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap = <S>(S: Semigroup<S>) => <A>(f: (a: A) => S) => (as: ReadonlyNonEmptyArray<A>) =>\n  as.slice(1).reduce((s, a) => S.concat(s, f(a)), f(as[0]))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => S) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 691,
        "to": 692
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight = <A, B>(b: B, f: (a: A, b: B) => B): ((as: ReadonlyNonEmptyArray<A>) => B) =>\n  reduceRightWithIndex(b, (_, b, a) => f(b, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 698,
        "to": 699
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "const reduceWithIndex = <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (as: ReadonlyNonEmptyArray<A>): B =>\n  as.reduce((b, a, i) => f(i, b, a), b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 705,
        "to": 706
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "const foldMapWithIndex = <S>(S: Semigroup<S>) => <A>(f: (i: number, a: A) => S) => (\n  as: ReadonlyNonEmptyArray<A>\n) => as.slice(1).reduce((s, a, i) => S.concat(s, f(i + 1, a)), f(0, as[0]))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (i: number, a: A) => S) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 714,
        "to": 716
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "const reduceRightWithIndex = <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (\n  as: ReadonlyNonEmptyArray<A>\n): B => as.reduceRight((b, a, i) => f(i, a, b), b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 722,
        "to": 724
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (as: ReadonlyNonEmptyArray<A>) => HKT<F, ReadonlyNonEmptyArray<B>>) => {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 730,
        "to": 735
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: ApplicativeHKT<F>\n): (<A>(as: ReadonlyNonEmptyArray<HKT<F, A>>) => HKT<F, ReadonlyNonEmptyArray<A>>) => traverseWithIndex(F)((_, a) => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 741,
        "to": 743
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "const traverseWithIndex: PipeableTraverseWithIndex1<URI, number> = <F>(F: ApplicativeHKT<F>) => <A, B>(\n  f: (i: number, a: A) => HKT<F, B>\n) => (as: ReadonlyNonEmptyArray<A>): HKT<F, ReadonlyNonEmptyArray<B>> => {\n  let out: HKT<F, ReadonlyNonEmptyArray<B>> = F.map(f(0, head(as)), of)\n  for (let i = 1; i < as.length; i++) {\n    out = F.ap(\n      F.map(out, (bs) => (b: B) => pipe(bs, append(b))),\n      f(i, as[i])\n    )\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (i: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 749,
        "to": 760
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: Comonad1<URI>['extract'] = (as) => as[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 766,
        "to": 766
      }
    }
  },
  {
    "name": "getShow",
    "text": "const getShow = <A>(S: Show<A>): Show<ReadonlyNonEmptyArray<A>> => ({\n  show: (as) => `[${as.map(S.show).join(', ')}]`\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 794,
        "to": 796
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <A = never>(): Semigroup<ReadonlyNonEmptyArray<A>> => ({\n  concat\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 804,
        "to": 806
      }
    }
  },
  {
    "name": "getEq",
    "text": "const getEq = <A>(E: Eq<A>): Eq<ReadonlyNonEmptyArray<A>> =>\n  fromEquals((xs, ys) => xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 820,
        "to": 821
      }
    }
  },
  {
    "name": "tail",
    "text": "const tail = <A>(as: ReadonlyNonEmptyArray<A>): ReadonlyArray<A> => as.slice(1)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1069,
        "to": 1069
      }
    }
  },
  {
    "name": "last",
    "text": "const last = <A>(as: ReadonlyNonEmptyArray<A>): A => as[as.length - 1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1074,
        "to": 1074
      }
    }
  },
  {
    "name": "init",
    "text": "const init = <A>(as: ReadonlyNonEmptyArray<A>): ReadonlyArray<A> => as.slice(0, -1)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1087,
        "to": 1087
      }
    }
  },
  {
    "name": "min",
    "text": "const min = <A>(O: Ord<A>): ((as: ReadonlyNonEmptyArray<A>) => A) => {\n  const S = Se.min(O)\n  return (as) => as.reduce(S.concat)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1092,
        "to": 1095
      }
    }
  },
  {
    "name": "max",
    "text": "const max = <A>(O: Ord<A>): ((as: ReadonlyNonEmptyArray<A>) => A) => {\n  const S = Se.max(O)\n  return (as) => as.reduce(S.concat)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1100,
        "to": 1103
      }
    }
  },
  {
    "name": "concatAll",
    "text": "const concatAll = <A>(S: Semigroup<A>) => (as: ReadonlyNonEmptyArray<A>): A => as.reduce(S.concat)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1108,
        "to": 1108
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "const filterWithIndex = <A>(predicate: (i: number, a: A) => boolean) => (\n  as: ReadonlyNonEmptyArray<A>\n): Option<ReadonlyNonEmptyArray<A>> => fromReadonlyArray(as.filter((a, i) => predicate(i, a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "(i: number, a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1137,
        "to": 1139
      }
    }
  },
  {
    "name": "snoc",
    "text": "const snoc = <A>(init: ReadonlyArray<A>, end: A): ReadonlyNonEmptyArray<A> => concat(init, [end])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "init",
          "type": {
            "__tag": "Other",
            "values": "readonly A[]"
          }
        },
        {
          "name": "end",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1183,
        "to": 1183
      }
    }
  },
  {
    "name": "insertAt",
    "text": "const insertAt = <A>(i: number, a: A) => (as: ReadonlyArray<A>): Option<ReadonlyNonEmptyArray<A>> =>\n  i < 0 || i > as.length ? O.none : O.some(unsafeInsertAt(i, a, as))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "i",
          "type": {
            "__tag": "NumberT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyNonEmptyArray.ts",
      "lines": {
        "from": 1192,
        "to": 1193
      }
    }
  },
  {
    "name": "fromRecord",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// interop\n// -------------------------------------------------------------------------------------\n\n/**\n * @category interop\n * @since 2.5.0\n */\nexport function fromRecord<K extends string, A>(r: Record<K, A>): ReadonlyRecord<K, A> {\n  return Object.assign({}, r)\n}",
    "docs": "/**\n * @category interop\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Record<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 48,
        "to": 50
      }
    }
  },
  {
    "name": "toRecord",
    "text": "\n\n/**\n * @category interop\n * @since 2.5.0\n */\nexport function toRecord<K extends string, A>(r: ReadonlyRecord<K, A>): Record<K, A> {\n  return Object.assign({}, r)\n}",
    "docs": "/**\n * @category interop\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Record<K, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 56,
        "to": 58
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a `ReadonlyRecord` into a list of key/value pairs.\n *\n * @category destructors\n * @since 2.5.0\n */\nexport function toUnfoldable<F extends URIS>(\n  U: Unfoldable1<F>\n): <K extends string, A>(r: ReadonlyRecord<K, A>) => Kind<F, readonly [K, A]>",
    "docs": "/**\n * Unfolds a `ReadonlyRecord` into a list of key/value pairs.\n *\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 126,
        "to": 128
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(\n  U: Unfoldable<F>\n): <K extends string, A>(r: ReadonlyRecord<K, A>) => HKT<F, readonly [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 129,
        "to": 131
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <A>(r: ReadonlyRecord<string, A>) => HKT<F, readonly [string, A]> {\n  return (r) => {\n    const sas = toReadonlyArray(r)\n    const len = sas.length\n    return U.unfold(0, (b) => (b < len ? O.some([sas[b], b + 1]) : O.none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [string, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 132,
        "to": 138
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete a key and value from a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function deleteAt<K extends string>(\n  k: K\n): <KS extends string, A>(r: ReadonlyRecord<KS, A>) => ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>",
    "docs": "/**\n * Delete a key and value from a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Readonly<Record<KS, A>>) => Readonly<Record<string extends K ? string : Exclude<KS, K>, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 170,
        "to": 172
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\nexport function deleteAt(k: string): <A>(r: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A> {\n  return <A>(r: ReadonlyRecord<string, A>) => {\n    if (!_.has.call(r, k)) {\n      return r\n    }\n    const out: Record<string, A> = Object.assign({}, r)\n    delete out[k]\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 173,
        "to": 182
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a `ReadonlyRecord`, returning the value as well as the subsequent `ReadonlyRecord`.\n *\n * @since 2.5.0\n */\nexport function pop<K extends string>(\n  k: K\n): <KS extends string, A>(\n  r: ReadonlyRecord<KS, A>\n) => Option<readonly [A, ReadonlyRecord<string extends K ? string : Exclude<KS, K>, A>]>",
    "docs": "/**\n * Delete a key and value from a `ReadonlyRecord`, returning the value as well as the subsequent `ReadonlyRecord`.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Readonly<Record<KS, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, Readonly<Record<string extends K ? string : Exclude<KS, K>, A>>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 224,
        "to": 228
      }
    }
  },
  {
    "name": "pop",
    "text": "\nexport function pop(k: string): <A>(r: ReadonlyRecord<string, A>) => Option<readonly [A, ReadonlyRecord<string, A>]> {\n  const deleteAtk = deleteAt(k)\n  return (r) => {\n    const oa = lookup(k, r)\n    return O.isNone(oa) ? O.none : O.some([oa.value, deleteAtk(r)])\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<readonly [A, Readonly<Record<string, A>>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 229,
        "to": 235
      }
    }
  },
  {
    "name": "isSubrecord",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `ReadonlyRecord` contains all of the keys and values contained in another `ReadonlyRecord`.\n *\n * @since 2.5.0\n */\nexport function isSubrecord<A>(\n  E: Eq<A>\n): {\n  (that: ReadonlyRecord<string, A>): (me: ReadonlyRecord<string, A>) => boolean\n  (me: ReadonlyRecord<string, A>, that: ReadonlyRecord<string, A>): boolean\n}",
    "docs": "/**\n * Test whether one `ReadonlyRecord` contains all of the keys and values contained in another `ReadonlyRecord`.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: Readonly<Record<string, A>>): (me: Readonly<Record<string, A>>) => boolean; (me: Readonly<Record<string, A>>, that: Readonly<Record<string, A>>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 243,
        "to": 248
      }
    }
  },
  {
    "name": "isSubrecord",
    "text": "\nexport function isSubrecord<A>(\n  E: Eq<A>\n): (\n  me: ReadonlyRecord<string, A>,\n  that?: ReadonlyRecord<string, A>\n) => boolean | ((me: ReadonlyRecord<string, A>) => boolean) {\n  return (me, that?) => {\n    if (that === undefined) {\n      const isSubrecordE = isSubrecord(E)\n      return (that) => isSubrecordE(that, me)\n    }\n    for (const k in me) {\n      if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: Readonly<Record<string, A>>, that?: Readonly<Record<string, A>>) => boolean | ((me: Readonly<Record<string, A>>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 249,
        "to": 267
      }
    }
  },
  {
    "name": "lookup",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `ReadonlyRecord`.\n *\n * @since 2.5.0\n */\nexport function lookup(k: string): <A>(r: ReadonlyRecord<string, A>) => Option<A>",
    "docs": "/**\n * Lookup the value for a key in a `ReadonlyRecord`.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 275,
        "to": 275
      }
    }
  },
  {
    "name": "lookup",
    "text": "\nexport function lookup<A>(k: string, r: ReadonlyRecord<string, A>): Option<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 276,
        "to": 276
      }
    }
  },
  {
    "name": "lookup",
    "text": "\nexport function lookup<A>(\n  k: string,\n  r?: ReadonlyRecord<string, A>\n): Option<A> | ((r: ReadonlyRecord<string, A>) => Option<A>) {\n  if (r === undefined) {\n    return (r) => lookup(k, r)\n  }\n  return _.has.call(r, k) ? O.some(r[k]) : O.none\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").None | import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Some<A> | ((r: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 277,
        "to": 285
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\n\n/**\n * Map a `ReadonlyRecord` passing the keys to the iterating function.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function mapWithIndex<K extends string, A, B>(\n  f: (k: K, a: A) => B\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>",
    "docs": "/**\n * Map a `ReadonlyRecord` passing the keys to the iterating function.\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 298,
        "to": 300
      }
    }
  },
  {
    "name": "mapWithIndex",
    "text": "\nexport function mapWithIndex<A, B>(\n  f: (k: string, a: A) => B\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return (r) => {\n    const out: Record<string, B> = {}\n    for (const k in r) {\n      if (_.has.call(r, k)) {\n        out[k] = f(k, r[k])\n      }\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 301,
        "to": 313
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * Map a `ReadonlyRecord` passing the values to the iterating function.\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function map<A, B>(f: (a: A) => B): <K extends string>(fa: ReadonlyRecord<K, A>) => ReadonlyRecord<K, B>",
    "docs": "/**\n * Map a `ReadonlyRecord` passing the values to the iterating function.\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(fa: Readonly<Record<K, A>>) => Readonly<Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 321,
        "to": 321
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<A, B>(f: (a: A) => B): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return mapWithIndex((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 322,
        "to": 324
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduceWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, b: B, a: A) => B\n): (fa: ReadonlyRecord<K, A>) => B",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 329,
        "to": 332
      }
    }
  },
  {
    "name": "reduceWithIndex",
    "text": "\nexport function reduceWithIndex<A, B>(b: B, f: (k: string, b: B, a: A) => B): (fa: ReadonlyRecord<string, A>) => B {\n  return (fa) => {\n    let out = b\n    const ks = keys(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = f(k, out, fa[k])\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 333,
        "to": 344
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <K extends string, A>(f: (k: K, a: A) => M) => (fa: ReadonlyRecord<K, A>) => M",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(f: (k: K, a: A) => M) => (fa: Readonly<Record<K, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 349,
        "to": 351
      }
    }
  },
  {
    "name": "foldMapWithIndex",
    "text": "\nexport function foldMapWithIndex<M>(\n  M: Monoid<M>\n): <A>(f: (k: string, a: A) => M) => (fa: ReadonlyRecord<string, A>) => M {\n  return (f) => (fa) => {\n    let out = M.empty\n    const ks = keys(fa)\n    const len = ks.length\n    for (let i = 0; i < len; i++) {\n      const k = ks[i]\n      out = M.concat(out, f(k, fa[k]))\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (k: string, a: A) => M) => (fa: Readonly<Record<string, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 352,
        "to": 365
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduceRightWithIndex<K extends string, A, B>(\n  b: B,\n  f: (k: K, a: A, b: B) => B\n): (fa: ReadonlyRecord<K, A>) => B",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 370,
        "to": 373
      }
    }
  },
  {
    "name": "reduceRightWithIndex",
    "text": "\nexport function reduceRightWithIndex<A, B>(\n  b: B,\n  f: (k: string, a: A, b: B) => B\n): (fa: ReadonlyRecord<string, A>) => B {\n  return (fa) => {\n    let out = b\n    const ks = keys(fa)\n    const len = ks.length\n    for (let i = len - 1; i >= 0; i--) {\n      const k = ks[i]\n      out = f(k, fa[k], out)\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: string, a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 374,
        "to": 388
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function traverseWithIndex<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 401,
        "to": 405
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 406,
        "to": 410
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A, B>(\n  f: (k: K, a: A) => Kind2<F, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 411,
        "to": 415
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A, B>(\n  f: (k: K, a: A) => Kind2<F, E, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 416,
        "to": 420
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A, B>(\n  f: (k: K, a: A) => Kind<F, B>\n) => (ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 421,
        "to": 425
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 426,
        "to": 428
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <A, B>(f: (k: string, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>> {\n  return <A, B>(f: (k: string, a: A) => HKT<F, B>) => (ta: ReadonlyRecord<string, A>) => {\n    const ks = keys(ta)\n    if (ks.length === 0) {\n      return F.of(empty)\n    }\n    let fr: HKT<F, Record<string, B>> = F.of({})\n    for (const key of ks) {\n      fr = F.ap(\n        F.map(fr, (r) => (b: B) => {\n          r[key] = b\n          return r\n        }),\n        f(key, ta[key])\n      )\n    }\n    return fr\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 429,
        "to": 449
      }
    }
  },
  {
    "name": "traverse",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function traverse<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A, B>(\n  f: (a: A) => Kind3<F, R, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 454,
        "to": 458
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <R, A, B>(\n  f: (a: A) => Kind3<F, R, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind3<F, R, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 459,
        "to": 463
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A, B>(\n  f: (a: A) => Kind2<F, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 464,
        "to": 468
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A, B>(\n  f: (a: A) => Kind2<F, E, B>\n) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind2<F, E, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 469,
        "to": 473
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS>(\n  F: Applicative1<F>\n): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => Kind<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 474,
        "to": 476
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: ReadonlyRecord<K, A>) => HKT<F, ReadonlyRecord<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <K extends string>(ta: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 477,
        "to": 479
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => (ta: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>> {\n  const traverseWithIndexF = traverseWithIndex(F)\n  return (f) => traverseWithIndexF((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 480,
        "to": 485
      }
    }
  },
  {
    "name": "sequence",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function sequence<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 490,
        "to": 492
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A>(ta: ReadonlyRecord<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 493,
        "to": 495
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 496,
        "to": 498
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A>(ta: ReadonlyRecord<K, Kind2<F, E, A>>) => Kind2<F, E, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 499,
        "to": 501
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A>(ta: ReadonlyRecord<K, Kind<F, A>>) => Kind<F, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 502,
        "to": 504
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(\n  F: Applicative<F>\n): <K extends string, A>(ta: ReadonlyRecord<K, HKT<F, A>>) => HKT<F, ReadonlyRecord<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Readonly<Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 505,
        "to": 507
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(\n  F: Applicative<F>\n): <A>(ta: ReadonlyRecord<string, HKT<F, A>>) => HKT<F, ReadonlyRecord<string, A>> {\n  return traverseWithIndex(F)((_, a) => a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 508,
        "to": 512
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionMapWithIndex<K extends string, A, B, C>(\n  f: (key: K, a: A) => Either<B, C>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 541,
        "to": 543
      }
    }
  },
  {
    "name": "partitionMapWithIndex",
    "text": "\nexport function partitionMapWithIndex<A, B, C>(\n  f: (key: string, a: A) => Either<B, C>\n): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>> {\n  return (r) => {\n    const left: Record<string, B> = {}\n    const right: Record<string, C> = {}\n    for (const k in r) {\n      if (_.has.call(r, k)) {\n        const e = f(k, r[k])\n        switch (e._tag) {\n          case 'Left':\n            left[k] = e.left\n            break\n          case 'Right':\n            right[k] = e.right\n            break\n        }\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 544,
        "to": 565
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 570,
        "to": 572
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: ReadonlyRecord<K, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 573,
        "to": 575
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: ReadonlyRecord<string, A>) => Separated<ReadonlyRecord<string, A>, ReadonlyRecord<string, A>> {\n  return (r) => {\n    const left: Record<string, A> = {}\n    const right: Record<string, A> = {}\n    for (const k in r) {\n      if (_.has.call(r, k)) {\n        const a = r[k]\n        if (predicateWithIndex(k, a)) {\n          right[k] = a\n        } else {\n          left[k] = a\n        }\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 576,
        "to": 594
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filterMapWithIndex<K extends string, A, B>(\n  f: (key: K, a: A) => Option<B>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 600,
        "to": 602
      }
    }
  },
  {
    "name": "filterMapWithIndex",
    "text": "\nexport function filterMapWithIndex<A, B>(\n  f: (key: string, a: A) => Option<B>\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, B> {\n  return (r) => {\n    const out: Record<string, B> = {}\n    for (const k in r) {\n      if (_.has.call(r, k)) {\n        const ob = f(k, r[k])\n        if (_.isSome(ob)) {\n          out[k] = ob.value\n        }\n      }\n    }\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(key: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 603,
        "to": 618
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function filterWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, B>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 623,
        "to": 625
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: ReadonlyRecord<K, A>) => ReadonlyRecord<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<K, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 626,
        "to": 628
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: ReadonlyRecord<string, A>) => ReadonlyRecord<string, A> {\n  return (fa) => {\n    const out: Record<string, A> = {}\n    let changed = false\n    for (const key in fa) {\n      if (_.has.call(fa, key)) {\n        const a = fa[key]\n        if (predicateWithIndex(key, a)) {\n          out[key] = a\n        } else {\n          changed = true\n        }\n      }\n    }\n    return changed ? out : fa\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 629,
        "to": 647
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a `ReadonlyRecord` from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.5.0\n */\nexport function fromFoldable<F extends URIS3, A>(\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, readonly [string, A]>) => ReadonlyRecord<string, A>",
    "docs": "/**\n * Create a `ReadonlyRecord` from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 655,
        "to": 658
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, A>(\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, readonly [string, A]>) => ReadonlyRecord<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 659,
        "to": 662
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, A>(\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, readonly [string, A]>) => ReadonlyRecord<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 663,
        "to": 666
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(\n  M: Magma<A>,\n  F: FoldableHKT<F>\n): (fka: HKT<F, readonly [string, A]>) => ReadonlyRecord<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 667,
        "to": 670
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(\n  M: Magma<A>,\n  F: FoldableHKT<F>\n): (fka: HKT<F, readonly [string, A]>) => ReadonlyRecord<string, A> {\n  const fromFoldableMapM = fromFoldableMap(M, F)\n  return (fka) => fromFoldableMapM(fka, identity)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [string, A]>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 671,
        "to": 677
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\n\n/**\n * Create a `ReadonlyRecord` from a foldable collection using the specified functions to:\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { last } from 'fp-ts/Semigroup'\n * import { Foldable, zip } from 'fp-ts/ReadonlyArray'\n * import { identity } from 'fp-ts/function'\n * import { ReadonlyRecord, fromFoldableMap } from 'fp-ts/ReadonlyRecord'\n *\n * export const zipObject = <K extends string, A>(keys: ReadonlyArray<K>, values: ReadonlyArray<A>): ReadonlyRecord<K, A> =>\n *   fromFoldableMap(last<A>(), Foldable)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const users: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(last<User>(), Foldable)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.5.0\n */\nexport function fromFoldableMap<F extends URIS3, B>(\n  M: Magma<B>,\n  F: Foldable3<F>\n): <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>",
    "docs": "/**\n * Create a `ReadonlyRecord` from a foldable collection using the specified functions to:\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { last } from 'fp-ts/Semigroup'\n * import { Foldable, zip } from 'fp-ts/ReadonlyArray'\n * import { identity } from 'fp-ts/function'\n * import { ReadonlyRecord, fromFoldableMap } from 'fp-ts/ReadonlyRecord'\n *\n * export const zipObject = <K extends string, A>(keys: ReadonlyArray<K>, values: ReadonlyArray<A>): ReadonlyRecord<K, A> =>\n *   fromFoldableMap(last<A>(), Foldable)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const users: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(last<User>(), Foldable)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 714,
        "to": 717
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS2, B>(\n  M: Magma<B>,\n  F: Foldable2<F>\n): <E, A>(fa: Kind2<F, E, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 718,
        "to": 721
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS, B>(\n  M: Magma<B>,\n  F: Foldable1<F>\n): <A>(fa: Kind<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 722,
        "to": 725
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: FoldableHKT<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 726,
        "to": 729
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: FoldableHKT<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B> {\n  return <A>(ta: HKT<F, A>, f: (a: A) => readonly [string, B]) => {\n    return F.reduce<A, Record<string, B>>(ta, {}, (r, a) => {\n      const [k, b] = f(a)\n      r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b\n      return r\n    })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => readonly [string, B]) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 730,
        "to": 741
      }
    }
  },
  {
    "name": "every",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function every<A>(predicate: Predicate<A>): (r: ReadonlyRecord<string, A>) => boolean {\n  return (r) => {\n    for (const k in r) {\n      if (!predicate(r[k])) {\n        return false\n      }\n    }\n    return true\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 746,
        "to": 755
      }
    }
  },
  {
    "name": "some",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function some<A>(predicate: (a: A) => boolean): (r: ReadonlyRecord<string, A>) => boolean {\n  return (r) => {\n    for (const k in r) {\n      if (predicate(r[k])) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => boolean"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 760,
        "to": 769
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * @since 2.5.0\n */\nexport function elem<A>(\n  E: Eq<A>\n): {\n  (a: A): (fa: ReadonlyRecord<string, A>) => boolean\n  (a: A, fa: ReadonlyRecord<string, A>): boolean\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (a: A): (fa: Readonly<Record<string, A>>) => boolean; (a: A, fa: Readonly<Record<string, A>>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 775,
        "to": 780
      }
    }
  },
  {
    "name": "elem",
    "text": "\nexport function elem<A>(\n  E: Eq<A>\n): (a: A, fa?: ReadonlyRecord<string, A>) => boolean | ((fa: ReadonlyRecord<string, A>) => boolean) {\n  return (a, fa?) => {\n    if (fa === undefined) {\n      const elemE = elem(E)\n      return (fa) => elemE(a, fa)\n    }\n    for (const k in fa) {\n      if (E.equals(fa[k], a)) {\n        return true\n      }\n    }\n    return false\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, fa?: Readonly<Record<string, A>>) => boolean | ((fa: Readonly<Record<string, A>>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 781,
        "to": 796
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<A>(S: Show<A>): Show<ReadonlyRecord<string, A>> {\n  return {\n    show: (r) => {\n      const elements = collect((k, a: A) => `${JSON.stringify(k)}: ${S.show(a)}`)(r).join(', ')\n      return elements === '' ? '{}' : `{ ${elements} }`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1018,
        "to": 1025
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<K extends string, A>(E: Eq<A>): Eq<ReadonlyRecord<K, A>>",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1031,
        "to": 1031
      }
    }
  },
  {
    "name": "getEq",
    "text": "\nexport function getEq<A>(E: Eq<A>): Eq<ReadonlyRecord<string, A>> {\n  const isSubrecordE = isSubrecord(E)\n  return fromEquals((x, y) => isSubrecordE(x)(y) && isSubrecordE(y)(x))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1032,
        "to": 1035
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\n\n/**\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup` instance for their values.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid<K extends string, A>(S: Semigroup<A>): Monoid<ReadonlyRecord<K, A>>",
    "docs": "/**\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup` instance for their values.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat({ foo: 123 }, { foo: 456 }), { foo: 579 })\n *\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1050,
        "to": 1050
      }
    }
  },
  {
    "name": "getMonoid",
    "text": "\nexport function getMonoid<A>(S: Semigroup<A>): Monoid<ReadonlyRecord<string, A>> {\n  return {\n    concat: (first, second) => {\n      if (isEmpty(first)) {\n        return second\n      }\n      if (isEmpty(second)) {\n        return first\n      }\n      const r: Record<string, A> = Object.assign({}, first)\n      for (const k in second) {\n        if (_.has.call(second, k)) {\n          r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k]\n        }\n      }\n      return r\n    },\n    empty\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1051,
        "to": 1070
      }
    }
  },
  {
    "name": "hasOwnProperty",
    "text": "\n\n/**\n * Use [`has`](#has) instead.\n *\n * @since 2.5.0\n * @deprecated\n */\nexport function hasOwnProperty<K extends string>(k: string, r: ReadonlyRecord<K, unknown>): k is K",
    "docs": "/**\n * Use [`has`](#has) instead.\n *\n * @since 2.5.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1248,
        "to": 1248
      }
    }
  },
  {
    "name": "hasOwnProperty",
    "text": "\nexport function hasOwnProperty<K extends string>(this: any, k: string, r?: ReadonlyRecord<K, unknown>): k is K {\n  return _.has.call(r === undefined ? this : r, k)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "this",
          "type": {
            "__tag": "Any"
          }
        },
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 1249,
        "to": 1251
      }
    }
  },
  {
    "name": "size",
    "text": "const size = (r: ReadonlyRecord<string, unknown>): number => Object.keys(r).length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 65,
        "to": 65
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "const isEmpty = (r: ReadonlyRecord<string, unknown>): boolean => {\n  for (const k in r) {\n    if (_.has.call(r, k)) {\n      return false\n    }\n  }\n  return true\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 72,
        "to": 79
      }
    }
  },
  {
    "name": "keys",
    "text": "const keys = <K extends string>(r: ReadonlyRecord<K, unknown>): ReadonlyArray<K> =>\n  (Object.keys(r) as any).sort()",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly K[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 84,
        "to": 85
      }
    }
  },
  {
    "name": "collect",
    "text": "const collect = <K extends string, A, B>(f: (k: K, a: A) => B) => (\n  r: ReadonlyRecord<K, A>\n): ReadonlyArray<B> => {\n  const out: Array<B> = []\n  for (const key of keys(r)) {\n    out.push(f(key, r[key]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<K, A>>) => readonly B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 101,
        "to": 109
      }
    }
  },
  {
    "name": "upsertAt",
    "text": "const upsertAt = <A>(k: string, a: A) => (r: ReadonlyRecord<string, A>): ReadonlyRecord<string, A> => {\n  if (_.has.call(r, k) && r[k] === a) {\n    return r\n  }\n  const out: Record<string, A> = Object.assign({}, r)\n  out[k] = a\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 146,
        "to": 153
      }
    }
  },
  {
    "name": "has",
    "text": "const has = <K extends string>(k: string, r: ReadonlyRecord<K, unknown>): k is K => _.has.call(r, k)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<K, unknown>>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 162,
        "to": 162
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(k: string, a: A) => <K extends string>(\n  r: ReadonlyRecord<K, A>\n): Option<ReadonlyRecord<K, A>> => {\n  if (!has(k, r)) {\n    return O.none\n  }\n  if (r[k] === a) {\n    return O.some(r)\n  }\n  const out: Record<K, A> = Object.assign({}, r)\n  out[k] = a\n  return O.some(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 187,
        "to": 199
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(k: string, f: (a: A) => A) => <K extends string>(\n  r: ReadonlyRecord<K, A>\n): Option<ReadonlyRecord<K, A>> => {\n  if (!has(k, r)) {\n    return O.none\n  }\n  const next = f(r[k])\n  if (next === r[k]) {\n    return O.some(r)\n  }\n  const out: Record<K, A> = Object.assign({}, r)\n  out[k] = next\n  return O.some(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Readonly<Record<K, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Readonly<Record<K, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 204,
        "to": 217
      }
    }
  },
  {
    "name": "singleton",
    "text": "const singleton = <A>(k: string, a: A): ReadonlyRecord<string, A> => ({ [k]: a })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 396,
        "to": 396
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (fa: ReadonlyRecord<string, A>) => HKT<F, ReadonlyRecord<string, B>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), compact)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 518,
        "to": 523
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B, C>(\n  f: (a: A) => HKT<F, Either<B, C>>\n) => (fa: ReadonlyRecord<string, A>) => HKT<F, Separated<ReadonlyRecord<string, B>, ReadonlyRecord<string, C>>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), separate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 529,
        "to": 536
      }
    }
  },
  {
    "name": "filter",
    "text": "const filter: {\n  <A, B extends A>(refinement: Refinement<A, B>): (fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>\n  <A>(predicate: Predicate<A>): (fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>\n} = <A>(predicate: Predicate<A>): ((fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>) =>\n  filterWithIndex((_, a) => predicate(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 891,
        "to": 895
      }
    }
  },
  {
    "name": "filterMap",
    "text": "const filterMap: <A, B>(\n  f: (a: A) => Option<B>\n) => (fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>> = (f) => filterMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => Readonly<Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 901,
        "to": 903
      }
    }
  },
  {
    "name": "partition",
    "text": "const partition: {\n  <A, B extends A>(refinement: Refinement<A, B>): (\n    fa: Readonly<Record<string, A>>\n  ) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>\n  <A>(predicate: Predicate<A>): (\n    fa: Readonly<Record<string, A>>\n  ) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>\n} = <A>(\n  predicate: Predicate<A>\n): ((fa: Readonly<Record<string, A>>) => Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>) =>\n  partitionWithIndex((_, a) => predicate(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 909,
        "to": 919
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "const partitionMap: <A, B, C>(\n  f: (a: A) => Either<B, C>\n) => (fa: Readonly<Record<string, A>>) => Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>> = (f) =>\n  partitionMapWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, B>>, Readonly<Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 925,
        "to": 928
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Readonly<Record<string, A>>) => B = (b, f) =>\n  reduceWithIndex(b, (_, b, a) => f(b, a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 934,
        "to": 935
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Readonly<Record<string, A>>) => M = (M) => {\n  const foldMapWithIndexM = foldMapWithIndex(M)\n  return (f) => foldMapWithIndexM((_, a) => f(a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: Readonly<Record<string, A>>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 941,
        "to": 944
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Readonly<Record<string, A>>) => B = (b, f) =>\n  reduceRightWithIndex(b, (_, a, b) => f(a, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Readonly<Record<string, A>>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 950,
        "to": 951
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <A>(r: Readonly<Record<string, Option<A>>>): Readonly<Record<string, A>> => {\n  const out: Record<string, A> = {}\n  for (const k in r) {\n    if (_.has.call(r, k)) {\n      const oa = r[k]\n      if (_.isSome(oa)) {\n        out[k] = oa.value\n      }\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Readonly<Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 957,
        "to": 968
      }
    }
  },
  {
    "name": "separate",
    "text": "const separate = <A, B>(\n  r: Readonly<Record<string, Either<A, B>>>\n): Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>> => {\n  const left: Record<string, A> = {}\n  const right: Record<string, B> = {}\n  for (const k in r) {\n    if (_.has.call(r, k)) {\n      const e = r[k]\n      if (_.isLeft(e)) {\n        left[k] = e.left\n      } else {\n        right[k] = e.right\n      }\n    }\n  }\n  return separated(left, right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "Readonly<Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<A, B>>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Readonly<Record<string, A>>, Readonly<Record<string, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyRecord.ts",
      "lines": {
        "from": 974,
        "to": 990
      }
    }
  },
  {
    "name": "fromSet",
    "text": "\n\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport function fromSet<A>(s: Set<A>): ReadonlySet<A> {\n  return new Set(s)\n}",
    "docs": "/**\n * @category constructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "Set<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 18,
        "to": 20
      }
    }
  },
  {
    "name": "toSet",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function toSet<A>(s: ReadonlySet<A>): Set<A> {\n  return new Set(s)\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "ReadonlySet<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 26,
        "to": 28
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow<A>(S: Show<A>): Show<ReadonlySet<A>> {\n  return {\n    show: (s) => {\n      const entries: Array<string> = []\n      s.forEach((a) => {\n        entries.push(S.show(a))\n      })\n      return `new Set([${entries.sort().join(', ')}])`\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 34,
        "to": 44
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<ReadonlySet<A>> {\n  const subsetE = isSubset(E)\n  return fromEquals((x, y) => subsetE(x, y) && subsetE(y, x))\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 50,
        "to": 53
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * Projects a Set through a function\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function map<B>(E: Eq<B>): <A>(f: (x: A) => B) => (set: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      const v = f(e)\n      if (!elemE(v, r)) {\n        r.add(v)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * Projects a Set through a function\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => B) => (set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 66,
        "to": 78
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function chain<B>(E: Eq<B>): <A>(f: (x: A) => ReadonlySet<B>) => (set: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      f(e).forEach((e) => {\n        if (!elemE(e, r)) {\n          r.add(e)\n        }\n      })\n    })\n    return r\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => ReadonlySet<B>) => (set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 84,
        "to": 97
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filter<A, B extends A>(refinement: Refinement<A, B>): (set: ReadonlySet<A>) => ReadonlySet<B>",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 103,
        "to": 103
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => ReadonlySet<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 104,
        "to": 104
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: ReadonlySet<A>) => ReadonlySet<A> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const r = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        r.add(value)\n      }\n    }\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 105,
        "to": 119
      }
    }
  },
  {
    "name": "partition",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partition<A, B extends A>(\n  refinement: Refinement<A, B>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<B>>",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlySet<A>, ReadonlySet<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 124,
        "to": 126
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(\n  predicate: Predicate<A>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlySet<A>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 127,
        "to": 129
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(\n  predicate: Predicate<A>\n): (set: ReadonlySet<A>) => Separated<ReadonlySet<A>, ReadonlySet<A>> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const right = new Set<A>()\n    const left = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        right.add(value)\n      } else {\n        left.add(value)\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlySet<A>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 130,
        "to": 149
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function union<A>(\n  E: Eq<A>\n): {\n  (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>\n  (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>\n}",
    "docs": "/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>; (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 158,
        "to": 163
      }
    }
  },
  {
    "name": "union",
    "text": "\nexport function union<A>(\n  E: Eq<A>\n): (me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((me: ReadonlySet<A>) => ReadonlySet<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const unionE = union(E)\n      return (that) => unionE(me, that)\n    }\n    if (isEmpty(me)) {\n      return that\n    }\n    if (isEmpty(that)) {\n      return me\n    }\n    const r = new Set(me)\n    that.forEach((e) => {\n      if (!elemE(e, r)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((me: ReadonlySet<A>) => ReadonlySet<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 164,
        "to": 187
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function intersection<A>(\n  E: Eq<A>\n): {\n  (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>\n  (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>\n}",
    "docs": "/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>; (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 196,
        "to": 201
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A>(\n  E: Eq<A>\n): (me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((that: ReadonlySet<A>) => ReadonlySet<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const intersectionE = intersection(E)\n      return (that) => intersectionE(that, me)\n    }\n    if (isEmpty(me) || isEmpty(that)) {\n      return empty\n    }\n    const r = new Set<A>()\n    me.forEach((e) => {\n      if (elemE(e, that)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((that: ReadonlySet<A>) => ReadonlySet<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 202,
        "to": 222
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function partitionMap<B, C>(\n  EB: Eq<B>,\n  EC: Eq<C>\n): <A>(f: (a: A) => Either<B, C>) => (set: ReadonlySet<A>) => Separated<ReadonlySet<B>, ReadonlySet<C>> {\n  return <A>(f: (a: A) => Either<B, C>) => (set: ReadonlySet<A>) => {\n    const values = set.values()\n    let e: Next<A>\n    const left = new Set<B>()\n    const right = new Set<C>()\n    const hasB = elem(EB)\n    const hasC = elem(EC)\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const v = f(e.value)\n      switch (v._tag) {\n        case 'Left':\n          if (!hasB(v.left, left)) {\n            left.add(v.left)\n          }\n          break\n        case 'Right':\n          if (!hasC(v.right, right)) {\n            right.add(v.right)\n          }\n          break\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EB",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        },
        {
          "name": "EC",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (set: ReadonlySet<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlySet<B>, ReadonlySet<C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 227,
        "to": 256
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/ReadonlySet'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(new Set([1, 2]), difference(N.Eq)(new Set([1, 3]))), new Set([2]))\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function difference<A>(\n  E: Eq<A>\n): {\n  (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>\n  (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>\n}",
    "docs": "/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/ReadonlySet'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(new Set([1, 2]), difference(N.Eq)(new Set([1, 3]))), new Set([2]))\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: ReadonlySet<A>): (me: ReadonlySet<A>) => ReadonlySet<A>; (me: ReadonlySet<A>, that: ReadonlySet<A>): ReadonlySet<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 272,
        "to": 277
      }
    }
  },
  {
    "name": "difference",
    "text": "\nexport function difference<A>(\n  E: Eq<A>\n): (me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((me: ReadonlySet<A>) => ReadonlySet<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const differenceE = difference(E)\n      return (that) => differenceE(that, me)\n    }\n    return filter((a: A) => !elemE(a, that))(me)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: ReadonlySet<A>, that?: ReadonlySet<A>) => ReadonlySet<A> | ((me: ReadonlySet<A>) => ReadonlySet<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 278,
        "to": 289
      }
    }
  },
  {
    "name": "getUnionMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getUnionMonoid<A>(E: Eq<A>): Monoid<ReadonlySet<A>> {\n  return {\n    concat: union(E),\n    empty\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 295,
        "to": 300
      }
    }
  },
  {
    "name": "getIntersectionSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getIntersectionSemigroup<A>(E: Eq<A>): Semigroup<ReadonlySet<A>> {\n  return {\n    concat: intersection(E)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 306,
        "to": 310
      }
    }
  },
  {
    "name": "reduce",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function reduce<A>(O: Ord<A>): <B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlySet<A>) => B {\n  const toReadonlyArrayO = toReadonlyArray(O)\n  return (b, f) => (fa) => toReadonlyArrayO(fa).reduce(f, b)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(b: B, f: (b: B, a: A) => B) => (fa: ReadonlySet<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 315,
        "to": 318
      }
    }
  },
  {
    "name": "foldMap",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function foldMap<A, M>(O: Ord<A>, M: Monoid<M>): (f: (a: A) => M) => (fa: ReadonlySet<A>) => M {\n  const toReadonlyArrayO = toReadonlyArray(O)\n  return (f) => (fa) => toReadonlyArrayO(fa).reduce((b, a) => M.concat(b, f(a)), M.empty)\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(f: (a: A) => M) => (fa: ReadonlySet<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 323,
        "to": 326
      }
    }
  },
  {
    "name": "insert",
    "text": "\n\n/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.5.0\n */\nexport function insert<A>(E: Eq<A>): (a: A) => (set: ReadonlySet<A>) => ReadonlySet<A> {\n  const elemE = elem(E)\n  return (a) => (set) => {\n    if (!elemE(a)(set)) {\n      const r = new Set(set)\n      r.add(a)\n      return r\n    } else {\n      return set\n    }\n  }\n}",
    "docs": "/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 342,
        "to": 353
      }
    }
  },
  {
    "name": "separate",
    "text": "\n\n/**\n * @since 2.5.0\n */\nexport function separate<E, A>(\n  EE: Eq<E>,\n  EA: Eq<A>\n): (fa: ReadonlySet<Either<E, A>>) => Separated<ReadonlySet<E>, ReadonlySet<A>> {\n  return (fa) => {\n    const elemEE = elem(EE)\n    const elemEA = elem(EA)\n    const left: Set<E> = new Set()\n    const right: Set<A> = new Set()\n    fa.forEach((e) => {\n      switch (e._tag) {\n        case 'Left':\n          if (!elemEE(e.left, left)) {\n            left.add(e.left)\n          }\n          break\n        case 'Right':\n          if (!elemEA(e.right, right)) {\n            right.add(e.right)\n          }\n          break\n      }\n    })\n    return separated(left, right)\n  }\n}",
    "docs": "/**\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlySet<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<ReadonlySet<E>, ReadonlySet<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 407,
        "to": 432
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.5.0\n */\nexport function filterMap<B>(E: Eq<B>): <A>(f: (a: A) => Option<B>) => (fa: ReadonlySet<A>) => ReadonlySet<B> {\n  const elemE = elem(E)\n  return (f) => (fa) => {\n    const r: Set<B> = new Set()\n    fa.forEach((a) => {\n      const ob = f(a)\n      if (ob._tag === 'Some' && !elemE(ob.value, r)) {\n        r.add(ob.value)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fa: ReadonlySet<A>) => ReadonlySet<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 438,
        "to": 450
      }
    }
  },
  {
    "name": "isSubset",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * `true` if and only if every element in the first set is an element of the second set\n *\n * @since 2.5.0\n */\nexport function isSubset<A>(\n  E: Eq<A>\n): {\n  (that: ReadonlySet<A>): (me: ReadonlySet<A>) => boolean\n  (me: ReadonlySet<A>, that: ReadonlySet<A>): boolean\n}",
    "docs": "/**\n * `true` if and only if every element in the first set is an element of the second set\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: ReadonlySet<A>): (me: ReadonlySet<A>) => boolean; (me: ReadonlySet<A>, that: ReadonlySet<A>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 500,
        "to": 505
      }
    }
  },
  {
    "name": "isSubset",
    "text": "\nexport function isSubset<A>(\n  E: Eq<A>\n): (me: ReadonlySet<A>, that?: ReadonlySet<A>) => boolean | ((me: ReadonlySet<A>) => boolean) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const isSubsetE = isSubset(E)\n      return (that) => isSubsetE(that, me)\n    }\n    return every((a: A) => elemE(a, that))(me)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: ReadonlySet<A>, that?: ReadonlySet<A>) => boolean | ((me: ReadonlySet<A>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 506,
        "to": 517
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of a set\n *\n * @since 2.5.0\n */\nexport function elem<A>(\n  E: Eq<A>\n): {\n  (a: A): (set: ReadonlySet<A>) => boolean\n  (a: A, set: ReadonlySet<A>): boolean\n}",
    "docs": "/**\n * Test if a value is a member of a set\n *\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (a: A): (set: ReadonlySet<A>) => boolean; (a: A, set: ReadonlySet<A>): boolean; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 525,
        "to": 530
      }
    }
  },
  {
    "name": "elem",
    "text": "\nexport function elem<A>(E: Eq<A>): (a: A, set?: ReadonlySet<A>) => boolean | ((set: ReadonlySet<A>) => boolean) {\n  return (a, set?) => {\n    if (set === undefined) {\n      const elemE = elem(E)\n      return (set) => elemE(a, set)\n    }\n    const values = set.values()\n    let e: Next<A>\n    let found = false\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!found && !(e = values.next()).done) {\n      found = E.equals(a, e.value)\n    }\n    return found\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, set?: ReadonlySet<A>) => boolean | ((set: ReadonlySet<A>) => boolean)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 531,
        "to": 546
      }
    }
  },
  {
    "name": "singleton",
    "text": "const singleton = <A>(a: A): ReadonlySet<A> => new Set([a])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 334,
        "to": 334
      }
    }
  },
  {
    "name": "remove",
    "text": "const remove = <A>(E: Eq<A>) => (a: A) => (set: ReadonlySet<A>): ReadonlySet<A> =>\n  filter((ax: A) => !E.equals(a, ax))(set)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 361,
        "to": 362
      }
    }
  },
  {
    "name": "toggle",
    "text": "const toggle = <A>(E: Eq<A>): ((a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>) => {\n  const elemE = elem(E)\n  const removeE = remove(E)\n  const insertE = insert(E)\n  return (a) => (set) => (elemE(a, set) ? removeE : insertE)(a)(set)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: ReadonlySet<A>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 372,
        "to": 377
      }
    }
  },
  {
    "name": "fromReadonlyArray",
    "text": "const fromReadonlyArray = <A>(E: Eq<A>) => (as: ReadonlyArray<A>): ReadonlySet<A> => {\n  const len = as.length\n  const out = new Set<A>()\n  const has = elem(E)\n  for (let i = 0; i < len; i++) {\n    const a = as[i]\n    if (!has(a, out)) {\n      out.add(a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 385,
        "to": 396
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <A>(E: Eq<A>): ((fa: ReadonlySet<Option<A>>) => ReadonlySet<A>) => filterMap(E)(identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: ReadonlySet<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => ReadonlySet<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 402,
        "to": 402
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "const isEmpty = <A>(set: ReadonlySet<A>): boolean => set.size === 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "set",
          "type": {
            "__tag": "Other",
            "values": "ReadonlySet<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 466,
        "to": 466
      }
    }
  },
  {
    "name": "size",
    "text": "const size = <A>(set: ReadonlySet<A>): number => set.size",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "set",
          "type": {
            "__tag": "Other",
            "values": "ReadonlySet<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 473,
        "to": 473
      }
    }
  },
  {
    "name": "some",
    "text": "const some = <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>): boolean => {\n  const values = set.values()\n  let e: Next<A>\n  let found = false\n  // tslint:disable-next-line: strict-boolean-expressions\n  while (!found && !(e = values.next()).done) {\n    found = predicate(e.value)\n  }\n  return found\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 478,
        "to": 487
      }
    }
  },
  {
    "name": "every",
    "text": "const every = <A>(predicate: Predicate<A>): ((set: ReadonlySet<A>) => boolean) => not(some(not(predicate)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 492,
        "to": 492
      }
    }
  },
  {
    "name": "toReadonlyArray",
    "text": "const toReadonlyArray = <A>(O: Ord<A>) => (set: ReadonlySet<A>): ReadonlyArray<A> => {\n  const out: Array<A> = []\n  set.forEach((e) => out.push(e))\n  return out.sort(O.compare)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: ReadonlySet<A>) => readonly A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlySet.ts",
      "lines": {
        "from": 553,
        "to": 557
      }
    }
  },
  {
    "name": "fst",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function fst<A, E>(ea: readonly [A, E]): A {\n  return ea[0]\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 30,
        "to": 32
      }
    }
  },
  {
    "name": "snd",
    "text": "\n\n/**\n * @category destructors\n * @since 2.5.0\n */\nexport function snd<A, E>(ea: readonly [A, E]): E {\n  return ea[1]\n}",
    "docs": "/**\n * @category destructors\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 38,
        "to": 40
      }
    }
  },
  {
    "name": "getApply",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getApply<S>(S: Semigroup<S>): Apply2C<URI, S> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))]\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 52,
        "to": 59
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getApplicative<M>(M: Monoid<M>): Applicative2C<URI, M> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"ReadonlyTuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 69,
        "to": 78
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getChain<S>(S: Semigroup<S>): Chain2C<URI, S> {\n  const A = getApply(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    chain: (ma, f) => {\n      const [b, s] = f(fst(ma))\n      return [b, S.concat(snd(ma), s)]\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"ReadonlyTuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 84,
        "to": 96
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getMonad<M>(M: Monoid<M>): Monad2C<URI, M> {\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"ReadonlyTuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 102,
        "to": 112
      }
    }
  },
  {
    "name": "getChainRec",
    "text": "\n\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getChainRec<M>(M: Monoid<M>): ChainRec2C<URI, M> {\n  const chainRec = <A, B>(a: A, f: (a: A) => readonly [Either<A, B>, M]): readonly [B, M] => {\n    let result: readonly [Either<A, B>, M] = f(a)\n    let acc: M = M.empty\n    let s: Either<A, B> = fst(result)\n    while (s._tag === 'Left') {\n      acc = M.concat(acc, snd(result))\n      result = f(s.left)\n      s = fst(result)\n    }\n    return [s.right, M.concat(acc, snd(result))]\n  }\n\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    chainRec\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.5.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ChainRec\").ChainRec2C<\"ReadonlyTuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 118,
        "to": 140
      }
    }
  },
  {
    "name": "swap",
    "text": "const swap = <A, E>(ea: readonly [A, E]): readonly [E, A] => [snd(ea), fst(ea)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "readonly [A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "readonly [E, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 46,
        "to": 46
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(\n  mapSnd: (e: E) => G,\n  mapFst: (a: A) => B\n) => (fa: readonly [A, E]) => readonly [B, G] = (f, g) => (fa) => [g(fst(fa)), f(snd(fa))]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: readonly [A, E]) => [B, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 183,
        "to": 186
      }
    }
  },
  {
    "name": "mapFst",
    "text": "const mapFst: <A, B>(f: (a: A) => B) => <E>(fa: readonly [A, E]) => readonly [B, E] = (f) => (fa) => [\n  f(fst(fa)),\n  snd(fa)\n]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 196,
        "to": 199
      }
    }
  },
  {
    "name": "mapSnd",
    "text": "const mapSnd: <E, G>(f: (e: E) => G) => <A>(fa: readonly [A, E]) => readonly [A, G] = (f) => (fa) => [\n  fst(fa),\n  f(snd(fa))\n]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: readonly [A, E]) => [A, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 209,
        "to": 212
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <A, B>(ab: readonly [B, A]) => <C>(bc: readonly [C, B]) => readonly [C, A] = (ab) => (bc) => [\n  fst(bc),\n  snd(ab)\n]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "readonly [B, A]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<C>(bc: readonly [C, B]) => [C, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 218,
        "to": 221
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: readonly [A, E]) => B) => (wa: readonly [A, E]) => readonly [B, E] = (f) => (\n  wa\n) => [f(wa), snd(wa)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: readonly [A, E]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: readonly [A, E]) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 227,
        "to": 229
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: readonly [A, E]) => B = (b, f) => (fa) =>\n  f(b, fst(fa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 251,
        "to": 252
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M = () => {\n  return (f) => (fa) => f(fst(fa))\n}",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: readonly [A, E]) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 258,
        "to": 260
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: readonly [A, E]) => B = (b, f) => (fa) =>\n  f(fst(fa), b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: readonly [A, E]) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 266,
        "to": 267
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <E>(as: readonly [A, E]) => HKT<F, readonly [B, E]>) => {\n  return (f) => (ta) => F.map(f(fst(ta)), (b) => [b, snd(ta)])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(as: readonly [A, E]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [B, E]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 272,
        "to": 276
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <A, E>(\n  fas: readonly [HKT<F, A>, E]\n): HKT<F, readonly [A, E]> => {\n  return F.map(fst(fas), (a) => [a, snd(fas)])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(fas: readonly [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, E]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [A, E]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ReadonlyTuple.ts",
      "lines": {
        "from": 281,
        "to": 285
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\n\n/**\n * Unfolds a `Record` into a list of key/value pairs.\n *\n * @since 2.0.0\n */\nexport function toUnfoldable<F extends URIS>(\n  U: Unfoldable1<F>\n): <K extends string, A>(r: Record<K, A>) => Kind<F, [K, A]>",
    "docs": "/**\n * Unfolds a `Record` into a list of key/value pairs.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <K extends string, A>(r: Record<K, A>) => HKT<F, [K, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [K, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "toUnfoldable",
    "text": "\nexport function toUnfoldable<F>(U: Unfoldable<F>): <A>(r: Record<string, A>) => HKT<F, [string, A]> {\n  return (r) => {\n    const sas = toArray(r)\n    const len = sas.length\n    return U.unfold(0, (b) => (b < len ? O.some([sas[b], b + 1]) : O.none))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "U",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Unfoldable\").Unfoldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [string, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 93,
        "to": 99
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\n\n/**\n * Delete a key and value from a `Record`.\n *\n * @since 2.0.0\n */\nexport function deleteAt<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>",
    "docs": "/**\n * Delete a key and value from a `Record`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Record<KS, A>) => Record<string extends K ? string : Exclude<KS, K>, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 125,
        "to": 127
      }
    }
  },
  {
    "name": "deleteAt",
    "text": "\nexport function deleteAt(k: string): <A>(r: Record<string, A>) => Record<string, A> {\n  return <A>(r: Record<string, A>) => {\n    if (!_hasOwnProperty.call(r, k)) {\n      return r\n    }\n    const out: Record<string, A> = Object.assign({}, r)\n    delete out[k]\n    return out\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 128,
        "to": 137
      }
    }
  },
  {
    "name": "pop",
    "text": "\n\n/**\n * Delete a key and value from a `Record`, returning the value as well as the subsequent `Record`.\n *\n * @since 2.0.0\n */\nexport function pop<K extends string>(\n  k: K\n): <KS extends string, A>(r: Record<KS, A>) => Option<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>",
    "docs": "/**\n * Delete a key and value from a `Record`, returning the value as well as the subsequent `Record`.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "Other",
            "values": "K"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<KS extends string, A>(r: Record<KS, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[A, Record<string extends K ? string : Exclude<KS, K>, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 162,
        "to": 164
      }
    }
  },
  {
    "name": "pop",
    "text": "\nexport function pop(k: string): <A>(r: Record<string, A>) => Option<[A, Record<string, A>]> {\n  const deleteAtk = deleteAt(k)\n  return (r) => {\n    const oa = lookup(k, r)\n    return O.isNone(oa) ? O.none : O.some([oa.value, deleteAtk(r)])\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(r: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<[A, Record<string, A>]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 165,
        "to": 171
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function traverseWithIndex<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 243,
        "to": 247
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A, B>(\n  f: (k: K, a: A) => Kind3<F, R, E, B>\n) => (ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 248,
        "to": 252
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 253,
        "to": 255
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind2<F, E, B>) => (ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 256,
        "to": 258
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A, B>(f: (k: K, a: A) => Kind<F, B>) => (ta: Record<K, A>) => Kind<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 259,
        "to": 261
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <K extends string, A, B>(f: (k: K, a: A) => HKT<F, B>) => (ta: Record<K, A>) => HKT<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A, B>(f: (k: K, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 262,
        "to": 264
      }
    }
  },
  {
    "name": "traverseWithIndex",
    "text": "\nexport function traverseWithIndex<F>(\n  F: Applicative<F>\n): <A, B>(f: (k: string, a: A) => HKT<F, B>) => (ta: Record<string, A>) => HKT<F, Record<string, B>> {\n  return RR.traverseWithIndex(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (k: string, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 265,
        "to": 269
      }
    }
  },
  {
    "name": "traverse",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function traverse<F extends URIS3>(\n  F: Applicative3<F>\n): <R, E, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 274,
        "to": 276
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <R, A, B>(f: (a: A) => Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => Kind3<F, R, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 277,
        "to": 279
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2>(\n  F: Applicative2<F>\n): <E, A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 280,
        "to": 282
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <A, B>(f: (a: A) => Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => Kind2<F, E, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 283,
        "to": 285
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F extends URIS>(\n  F: Applicative1<F>\n): <A, B>(f: (a: A) => Kind<F, B>) => <K extends string>(ta: Record<K, A>) => Kind<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 286,
        "to": 288
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => <K extends string>(ta: Record<K, A>) => HKT<F, Record<K, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <K extends string>(ta: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 289,
        "to": 291
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<F>(\n  F: Applicative<F>\n): <A, B>(f: (a: A) => HKT<F, B>) => (ta: Record<string, A>) => HKT<F, Record<string, B>> {\n  return RR.traverse(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 292,
        "to": 296
      }
    }
  },
  {
    "name": "sequence",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function sequence<F extends URIS3>(\n  F: Applicative3<F>\n): <K extends string, R, E, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, E, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 301,
        "to": 303
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS3, E>(\n  F: Applicative3C<F, E>\n): <K extends string, R, A>(ta: Record<K, Kind3<F, R, E, A>>) => Kind3<F, R, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, R, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 304,
        "to": 306
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2>(\n  F: Applicative2<F>\n): <K extends string, E, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, E, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 307,
        "to": 309
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS2, E>(\n  F: Applicative2C<F, E>\n): <K extends string, A>(ta: Record<K, Kind2<F, E, A>>) => Kind2<F, E, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 310,
        "to": 312
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F extends URIS>(\n  F: Applicative1<F>\n): <K extends string, A>(ta: Record<K, Kind<F, A>>) => Kind<F, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 313,
        "to": 315
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(F: Applicative<F>): <K extends string, A>(ta: Record<K, HKT<F, A>>) => HKT<F, Record<K, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string, A>(ta: Record<K, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 316,
        "to": 316
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<F>(F: Applicative<F>): <A>(ta: Record<string, HKT<F, A>>) => HKT<F, Record<string, A>> {\n  return RR.sequence(F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: Record<string, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 317,
        "to": 319
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partitionWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Record<string, A>, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 355,
        "to": 357
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Separated<Record<string, A>, Record<string, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Record<string, A>, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 358,
        "to": 360
      }
    }
  },
  {
    "name": "partitionWithIndex",
    "text": "\nexport function partitionWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: Record<string, A>) => Separated<Record<string, A>, Record<string, A>> {\n  return RR.partitionWithIndex(predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Record<string, A>, Record<string, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 361,
        "to": 365
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function filterWithIndex<K extends string, A, B extends A>(\n  refinementWithIndex: RefinementWithIndex<K, A, B>\n): (fa: Record<K, A>) => Record<string, B>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinementWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").RefinementWithIndex<K, A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 377,
        "to": 379
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<K extends string, A>(\n  predicateWithIndex: PredicateWithIndex<K, A>\n): (fa: Record<K, A>) => Record<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<K, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<K, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 380,
        "to": 382
      }
    }
  },
  {
    "name": "filterWithIndex",
    "text": "\nexport function filterWithIndex<A>(\n  predicateWithIndex: PredicateWithIndex<string, A>\n): (fa: Record<string, A>) => Record<string, A> {\n  return RR.filterWithIndex(predicateWithIndex)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicateWithIndex",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/FilterableWithIndex\").PredicateWithIndex<string, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Record<string, A>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 383,
        "to": 387
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\n\n/**\n * Create a `Record` from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.0.0\n */\nexport function fromFoldable<F extends URIS3, A>(\n  M: Magma<A>,\n  F: Foldable3<F>\n): <R, E>(fka: Kind3<F, R, E, [string, A]>) => Record<string, A>",
    "docs": "/**\n * Create a `Record` from a foldable collection of key/value pairs, using the\n * specified `Magma` to combine values for duplicate keys.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 395,
        "to": 398
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS2, A>(\n  M: Magma<A>,\n  F: Foldable2<F>\n): <E>(fka: Kind2<F, E, [string, A]>) => Record<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 399,
        "to": 402
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F extends URIS, A>(\n  M: Magma<A>,\n  F: Foldable1<F>\n): (fka: Kind<F, [string, A]>) => Record<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 403,
        "to": 406
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(M: Magma<A>, F: FoldableHKT<F>): (fka: HKT<F, [string, A]>) => Record<string, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 407,
        "to": 407
      }
    }
  },
  {
    "name": "fromFoldable",
    "text": "\nexport function fromFoldable<F, A>(M: Magma<A>, F: FoldableHKT<F>): (fka: HKT<F, [string, A]>) => Record<string, A> {\n  return RR.fromFoldable(M, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<A>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fka: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [string, A]>) => Record<string, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 408,
        "to": 410
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\n\n/**\n * Create a `Record` from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { last } from 'fp-ts/Semigroup'\n * import { Foldable, zip } from 'fp-ts/Array'\n * import { identity } from 'fp-ts/function'\n * import { fromFoldableMap } from 'fp-ts/Record'\n *\n * export const zipObject = <K extends string, A>(keys: Array<K>, values: Array<A>): Record<K, A> =>\n *   fromFoldableMap(last<A>(), Foldable)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const users: Array<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(last<User>(), Foldable)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.0.0\n */\nexport function fromFoldableMap<F extends URIS3, B>(\n  M: Magma<B>,\n  F: Foldable3<F>\n): <R, E, A>(fa: Kind3<F, R, E, A>, f: (a: A) => [string, B]) => Record<string, B>",
    "docs": "/**\n * Create a `Record` from a foldable collection using the specified functions to\n *\n * - map to key/value pairs\n * - combine values for duplicate keys.\n *\n * @example\n * import { last } from 'fp-ts/Semigroup'\n * import { Foldable, zip } from 'fp-ts/Array'\n * import { identity } from 'fp-ts/function'\n * import { fromFoldableMap } from 'fp-ts/Record'\n *\n * export const zipObject = <K extends string, A>(keys: Array<K>, values: Array<A>): Record<K, A> =>\n *   fromFoldableMap(last<A>(), Foldable)(zip(keys, values), identity)\n *\n * assert.deepStrictEqual(zipObject(['a', 'b'], [1, 2, 3]), { a: 1, b: 2 })\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const users: Array<User> = [\n *   { id: 'id1', name: 'name1' },\n *   { id: 'id2', name: 'name2' },\n *   { id: 'id1', name: 'name3' }\n * ]\n *\n * assert.deepStrictEqual(fromFoldableMap(last<User>(), Foldable)(users, user => [user.id, user]), {\n *   id1: { id: 'id1', name: 'name3' },\n *   id2: { id: 'id2', name: 'name2' }\n * })\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 447,
        "to": 450
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS2, B>(\n  M: Magma<B>,\n  F: Foldable2<F>\n): <E, A>(fa: Kind2<F, E, A>, f: (a: A) => [string, B]) => Record<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 451,
        "to": 454
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F extends URIS, B>(\n  M: Magma<B>,\n  F: Foldable1<F>\n): <A>(fa: Kind<F, A>, f: (a: A) => [string, B]) => Record<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 455,
        "to": 458
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: FoldableHKT<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 459,
        "to": 462
      }
    }
  },
  {
    "name": "fromFoldableMap",
    "text": "\nexport function fromFoldableMap<F, B>(\n  M: Magma<B>,\n  F: FoldableHKT<F>\n): <A>(fa: HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B> {\n  return RR.fromFoldableMap(M, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Magma\").Magma<B>"
          }
        },
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Foldable\").Foldable<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, f: (a: A) => [string, B]) => Record<string, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 463,
        "to": 468
      }
    }
  },
  {
    "name": "collect",
    "text": "const collect = <K extends string, A, B>(f: (k: K, a: A) => B) => (r: Record<K, A>): Array<B> => {\n  const out: Array<B> = []\n  for (const key of keys(r)) {\n    out.push(f(key, r[key]))\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(k: K, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(r: Record<K, A>) => B[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 67,
        "to": 73
      }
    }
  },
  {
    "name": "updateAt",
    "text": "const updateAt = <A>(k: string, a: A): (<K extends string>(r: Record<K, A>) => Option<Record<K, A>>) =>\n  modifyAt(k, () => a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 142,
        "to": 143
      }
    }
  },
  {
    "name": "modifyAt",
    "text": "const modifyAt = <A>(k: string, f: (a: A) => A) => <K extends string>(r: Record<K, A>): Option<Record<K, A>> => {\n  if (!has(k, r)) {\n    return O.none\n  }\n  const out: Record<K, A> = Object.assign({}, r)\n  out[k] = f(r[k])\n  return O.some(out)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "k",
          "type": {
            "__tag": "StringT"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<K extends string>(r: Record<K, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<Record<K, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 148,
        "to": 155
      }
    }
  },
  {
    "name": "wither",
    "text": "const wither: PipeableWither1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, Option<B>>) => (fa: Record<string, A>) => HKT<F, Record<string, B>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), compact)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>>) => (fa: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, Record<string, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 325,
        "to": 330
      }
    }
  },
  {
    "name": "wilt",
    "text": "const wilt: PipeableWilt1<URI> = <F>(\n  F: Applicative<F>\n): (<A, B, C>(\n  f: (a: A) => HKT<F, Either<B, C>>\n) => (fa: Record<string, A>) => HKT<F, Separated<Record<string, B>, Record<string, C>>>) => {\n  const traverseF = traverse(F)\n  return (f) => (fa) => F.map(pipe(fa, traverseF(f)), separate)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>>) => (fa: Record<string, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Record<string, B>, Record<string, C>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Record.ts",
      "lines": {
        "from": 336,
        "to": 343
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(...rings: { [K in keyof A]: Ring<A[K]> }): Ring<Readonly<A>> =>\n  ({\n    add: (x: any, y: any) => rings.map((R, i) => R.add(x[i], y[i])),\n    zero: rings.map((R) => R.zero),\n    mul: (x: any, y: any) => rings.map((R, i) => R.mul(x[i], y[i])),\n    one: rings.map((R) => R.one),\n    sub: (x: any, y: any) => rings.map((R, i) => R.sub(x[i], y[i]))\n  } as any)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "rings",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ring.ts",
      "lines": {
        "from": 48,
        "to": 55
      }
    }
  },
  {
    "name": "negate",
    "text": "const negate = <A>(R: Ring<A>) => (a: A) => R.sub(R.zero, a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "R",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ring\").Ring<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Ring.ts",
      "lines": {
        "from": 66,
        "to": 66
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function fold<A>(\n  S: Semigroup<A>\n): {\n  (startWith: A): (as: ReadonlyArray<A>) => A\n  (startWith: A, as: ReadonlyArray<A>): A\n}",
    "docs": "/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (startWith: A): (as: readonly A[]) => A; (startWith: A, as: readonly A[]): A; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 361,
        "to": 366
      }
    }
  },
  {
    "name": "fold",
    "text": "\nexport function fold<A>(S: Semigroup<A>): (startWith: A, as?: ReadonlyArray<A>) => A | ((as: ReadonlyArray<A>) => A) {\n  const concatAllS = concatAll(S)\n  return (startWith, as?) => (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(startWith: A, as?: readonly A[]) => A | ((as: readonly A[]) => A)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 367,
        "to": 370
      }
    }
  },
  {
    "name": "min",
    "text": "const min = <A>(O: Ord<A>): Semigroup<A> => ({\n  concat: Or.min(O)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 76,
        "to": 78
      }
    }
  },
  {
    "name": "max",
    "text": "const max = <A>(O: Ord<A>): Semigroup<A> => ({\n  concat: Or.max(O)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 94,
        "to": 96
      }
    }
  },
  {
    "name": "constant",
    "text": "const constant = <A>(a: A): Semigroup<A> => ({\n  concat: () => a\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 102,
        "to": 104
      }
    }
  },
  {
    "name": "reverse",
    "text": "const reverse = <A>(S: Semigroup<A>): Semigroup<A> => ({\n  concat: (x, y) => S.concat(y, x)\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(\n  semigroups: { [K in keyof A]: Semigroup<A[K]> }\n): Semigroup<{ readonly [K in keyof A]: A[K] }> => ({\n  concat: (first, second) => {\n    const r: A = {} as any\n    for (const k in semigroups) {\n      if (_.has.call(semigroups, k)) {\n        r[k] = semigroups[k].concat(first[k], second[k])\n      }\n    }\n    return r\n  }\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "semigroups",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<{ readonly [K in keyof A]: A[K]; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 148,
        "to": 160
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...semigroups: { [K in keyof A]: Semigroup<A[K]> }\n): Semigroup<Readonly<A>> => ({\n  concat: (first, second) => semigroups.map((s, i) => s.concat(first[i], second[i])) as any\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "semigroups",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 180,
        "to": 184
      }
    }
  },
  {
    "name": "intercalate",
    "text": "const intercalate = <A>(middle: A) => (S: Semigroup<A>): Semigroup<A> => ({\n  concat: (x, y) => S.concat(x, S.concat(middle, y))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "middle",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(S: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 201,
        "to": 203
      }
    }
  },
  {
    "name": "first",
    "text": "const first = <A = never>(): Semigroup<A> => ({ concat: identity })",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 220,
        "to": 220
      }
    }
  },
  {
    "name": "last",
    "text": "const last = <A = never>(): Semigroup<A> => ({ concat: (_, y) => y })",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 233,
        "to": 233
      }
    }
  },
  {
    "name": "concatAll",
    "text": "const concatAll = <A>(S: Semigroup<A>) => (startWith: A) => (as: ReadonlyArray<A>): A =>\n  as.reduce(S.concat, startWith)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(startWith: A) => (as: readonly A[]) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 261,
        "to": 262
      }
    }
  },
  {
    "name": "getObjectSemigroup",
    "text": "const getObjectSemigroup = <A extends object = never>(): Semigroup<A> => ({\n  concat: (first, second) => Object.assign({}, first, second)\n})",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Semigroup.ts",
      "lines": {
        "from": 275,
        "to": 277
      }
    }
  },
  {
    "name": "separated",
    "text": "const separated = <E, A>(left: E, right: A): Separated<E, A> => ({ left, right })",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 41,
        "to": 41
      }
    }
  },
  {
    "name": "map",
    "text": "const map = <A, B>(f: (a: A) => B) => <E>(fa: Separated<E, A>): Separated<E, B> =>\n  separated(left(fa), f(right(fa)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 62,
        "to": 63
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft = <E, G>(f: (e: E) => G) => <A>(fa: Separated<E, A>): Separated<G, A> =>\n  separated(f(left(fa)), right(fa))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 71,
        "to": 72
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap = <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Separated<E, A>): Separated<G, B> =>\n  separated(f(left(fa)), g(right(fa)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 80,
        "to": 81
      }
    }
  },
  {
    "name": "left",
    "text": "const left = <E, A>(s: Separated<E, A>): E => s.left",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "E"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 141,
        "to": 141
      }
    }
  },
  {
    "name": "right",
    "text": "const right = <E, A>(s: Separated<E, A>): A => s.right",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Separated.ts",
      "lines": {
        "from": 146,
        "to": 146
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function map<B>(E: Eq<B>): <A>(f: (x: A) => B) => (set: Set<A>) => Set<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      const v = f(e)\n      if (!elemE(v, r)) {\n        r.add(v)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => B) => (set: Set<A>) => Set<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 34,
        "to": 46
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function chain<B>(E: Eq<B>): <A>(f: (x: A) => Set<B>) => (set: Set<A>) => Set<B> {\n  const elemE = elem(E)\n  return (f) => (set) => {\n    const r = new Set<B>()\n    set.forEach((e) => {\n      f(e).forEach((e) => {\n        if (!elemE(e, r)) {\n          r.add(e)\n        }\n      })\n    })\n    return r\n  }\n}",
    "docs": "/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (x: A) => Set<B>) => (set: Set<A>) => Set<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 54,
        "to": 67
      }
    }
  },
  {
    "name": "filter",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function filter<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Set<B>",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 78,
        "to": 78
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: Set<A>) => Set<A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 79,
        "to": 79
      }
    }
  },
  {
    "name": "filter",
    "text": "\nexport function filter<A>(predicate: Predicate<A>): (set: Set<A>) => Set<A> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const r = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        r.add(value)\n      }\n    }\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 80,
        "to": 94
      }
    }
  },
  {
    "name": "partition",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partition<A, B extends A>(refinement: Refinement<A, B>): (set: Set<A>) => Separated<Set<A>, Set<B>>",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "refinement",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Refinement<A, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Set<A>, Set<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 99,
        "to": 99
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(predicate: Predicate<A>): (set: Set<A>) => Separated<Set<A>, Set<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Set<A>, Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 100,
        "to": 100
      }
    }
  },
  {
    "name": "partition",
    "text": "\nexport function partition<A>(predicate: Predicate<A>): (set: Set<A>) => Separated<Set<A>, Set<A>> {\n  return (set) => {\n    const values = set.values()\n    let e: Next<A>\n    const right = new Set<A>()\n    const left = new Set<A>()\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const value = e.value\n      if (predicate(value)) {\n        right.add(value)\n      } else {\n        left.add(value)\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "predicate",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Predicate<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Set<A>, Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 101,
        "to": 118
      }
    }
  },
  {
    "name": "union",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function union<A>(\n  E: Eq<A>\n): {\n  (that: Set<A>): (me: Set<A>) => Set<A>\n  (me: Set<A>, that: Set<A>): Set<A>\n}",
    "docs": "/**\n * Form the union of two sets\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: Set<A>): (me: Set<A>) => Set<A>; (me: Set<A>, that: Set<A>): Set<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 127,
        "to": 132
      }
    }
  },
  {
    "name": "union",
    "text": "\nexport function union<A>(E: Eq<A>): (me: Set<A>, that?: Set<A>) => Set<A> | ((me: Set<A>) => Set<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const unionE = union(E)\n      return (that) => unionE(me, that)\n    }\n    if (isEmpty(me)) {\n      return that\n    }\n    if (isEmpty(that)) {\n      return me\n    }\n    const r = new Set(me)\n    that.forEach((e) => {\n      if (!elemE(e, r)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: Set<A>, that?: Set<A>) => Set<A> | ((me: Set<A>) => Set<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 133,
        "to": 154
      }
    }
  },
  {
    "name": "intersection",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function intersection<A>(\n  E: Eq<A>\n): {\n  (that: Set<A>): (me: Set<A>) => Set<A>\n  (me: Set<A>, that: Set<A>): Set<A>\n}",
    "docs": "/**\n * The set of elements which are in both the first and second set\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: Set<A>): (me: Set<A>) => Set<A>; (me: Set<A>, that: Set<A>): Set<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 163,
        "to": 168
      }
    }
  },
  {
    "name": "intersection",
    "text": "\nexport function intersection<A>(E: Eq<A>): (me: Set<A>, that?: Set<A>) => Set<A> | ((that: Set<A>) => Set<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const intersectionE = intersection(E)\n      return (that) => intersectionE(that, me)\n    }\n    if (isEmpty(me) || isEmpty(that)) {\n      return new Set()\n    }\n    const r = new Set<A>()\n    me.forEach((e) => {\n      if (elemE(e, that)) {\n        r.add(e)\n      }\n    })\n    return r\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: Set<A>, that?: Set<A>) => Set<A> | ((that: Set<A>) => Set<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 169,
        "to": 187
      }
    }
  },
  {
    "name": "partitionMap",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function partitionMap<B, C>(\n  EB: Eq<B>,\n  EC: Eq<C>\n): <A>(f: (a: A) => Either<B, C>) => (set: Set<A>) => Separated<Set<B>, Set<C>> {\n  return <A>(f: (a: A) => Either<B, C>) => (set: Set<A>) => {\n    const values = set.values()\n    let e: Next<A>\n    const left = new Set<B>()\n    const right = new Set<C>()\n    const hasB = elem(EB)\n    const hasC = elem(EC)\n    // tslint:disable-next-line: strict-boolean-expressions\n    while (!(e = values.next()).done) {\n      const v = f(e.value)\n      switch (v._tag) {\n        case 'Left':\n          if (!hasB(v.left, left)) {\n            left.add(v.left)\n          }\n          break\n        case 'Right':\n          if (!hasC(v.right, right)) {\n            right.add(v.right)\n          }\n          break\n      }\n    }\n    return separated(left, right)\n  }\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EB",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        },
        {
          "name": "EC",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<C>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<B, C>) => (set: Set<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Set<B>, Set<C>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 192,
        "to": 221
      }
    }
  },
  {
    "name": "difference",
    "text": "\n\n// TODO: remove non-curried overloading in v3\n/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/Set'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(new Set([1, 2]), difference(N.Eq)(new Set([1, 3]))), new Set([2]))\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function difference<A>(\n  E: Eq<A>\n): {\n  (that: Set<A>): (me: Set<A>) => Set<A>\n  (me: Set<A>, that: Set<A>): Set<A>\n}",
    "docs": "/**\n * Form the set difference (`x` - `y`)\n *\n * @example\n * import { difference } from 'fp-ts/Set'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(new Set([1, 2]), difference(N.Eq)(new Set([1, 3]))), new Set([2]))\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ (that: Set<A>): (me: Set<A>) => Set<A>; (me: Set<A>, that: Set<A>): Set<A>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 237,
        "to": 242
      }
    }
  },
  {
    "name": "difference",
    "text": "\nexport function difference<A>(E: Eq<A>): (me: Set<A>, that?: Set<A>) => Set<A> | ((me: Set<A>) => Set<A>) {\n  const elemE = elem(E)\n  return (me, that?) => {\n    if (that === undefined) {\n      const differenceE = difference(E)\n      return (that) => differenceE(that, me)\n    }\n    return filter((a: A) => !elemE(a, that))(me)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(me: Set<A>, that?: Set<A>) => Set<A> | ((me: Set<A>) => Set<A>)"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 243,
        "to": 252
      }
    }
  },
  {
    "name": "getUnionMonoid",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getUnionMonoid<A>(E: Eq<A>): Monoid<Set<A>> {\n  return {\n    concat: union(E),\n    empty: new Set()\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 258,
        "to": 263
      }
    }
  },
  {
    "name": "getIntersectionSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getIntersectionSemigroup<A>(E: Eq<A>): Semigroup<Set<A>> {\n  return {\n    concat: intersection(E)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 269,
        "to": 273
      }
    }
  },
  {
    "name": "insert",
    "text": "\n\n/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function insert<A>(E: Eq<A>): (a: A) => (set: Set<A>) => Set<A> {\n  const elemE = elem(E)\n  return (a) => (set) => {\n    if (!elemE(a)(set)) {\n      const r = new Set(set)\n      r.add(a)\n      return r\n    } else {\n      return set\n    }\n  }\n}",
    "docs": "/**\n * Insert a value into a set\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 299,
        "to": 310
      }
    }
  },
  {
    "name": "separate",
    "text": "\n\n/**\n * @since 2.0.0\n */\nexport function separate<E, A>(EE: Eq<E>, EA: Eq<A>): (fa: Set<Either<E, A>>) => Separated<Set<E>, Set<A>> {\n  return (fa) => {\n    const elemEE = elem(EE)\n    const elemEA = elem(EA)\n    const left: Set<E> = new Set()\n    const right: Set<A> = new Set()\n    fa.forEach((e) => {\n      switch (e._tag) {\n        case 'Left':\n          if (!elemEE(e.left, left)) {\n            left.add(e.left)\n          }\n          break\n        case 'Right':\n          if (!elemEA(e.right, right)) {\n            right.add(e.right)\n          }\n          break\n      }\n    })\n    return separated(left, right)\n  }\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Set<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Separated\").Separated<Set<E>, Set<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 363,
        "to": 385
      }
    }
  },
  {
    "name": "filterMap",
    "text": "\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport function filterMap<B>(E: Eq<B>): <A>(f: (a: A) => Option<B>) => (fa: Set<A>) => Set<B> {\n  const elemE = elem(E)\n  return (f) => (fa) => {\n    const r: Set<B> = new Set()\n    fa.forEach((a) => {\n      const ob = f(a)\n      if (ob._tag === 'Some' && !elemE(ob.value, r)) {\n        r.add(ob.value)\n      }\n    })\n    return r\n  }\n}",
    "docs": "/**\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<B>) => (fa: Set<A>) => Set<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 391,
        "to": 403
      }
    }
  },
  {
    "name": "singleton",
    "text": "const singleton = <A>(a: A): Set<A> => new Set([a])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 291,
        "to": 291
      }
    }
  },
  {
    "name": "remove",
    "text": "const remove = <A>(E: Eq<A>) => (a: A) => (set: Set<A>): Set<A> => filter((ax: A) => !E.equals(a, ax))(set)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 318,
        "to": 318
      }
    }
  },
  {
    "name": "toggle",
    "text": "const toggle = <A>(E: Eq<A>): ((a: A) => (set: Set<A>) => Set<A>) => {\n  const elemE = elem(E)\n  const removeE = remove(E)\n  const insertE = insert(E)\n  return (a) => (set) => (elemE(a, set) ? removeE : insertE)(a)(set)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => (set: Set<A>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 328,
        "to": 333
      }
    }
  },
  {
    "name": "fromArray",
    "text": "const fromArray = <A>(E: Eq<A>) => (as: Array<A>): Set<A> => {\n  const len = as.length\n  const out = new Set<A>()\n  const has = elem(E)\n  for (let i = 0; i < len; i++) {\n    const a = as[i]\n    if (!has(a, out)) {\n      out.add(a)\n    }\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: A[]) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 341,
        "to": 352
      }
    }
  },
  {
    "name": "compact",
    "text": "const compact = <A>(E: Eq<A>): ((fa: Set<Option<A>>) => Set<A>) => filterMap(E)(identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: Set<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>>) => Set<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 358,
        "to": 358
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "const isEmpty = <A>(set: Set<A>): boolean => set.size === 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "set",
          "type": {
            "__tag": "Other",
            "values": "Set<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 419,
        "to": 419
      }
    }
  },
  {
    "name": "size",
    "text": "const size = <A>(set: Set<A>): number => set.size",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "set",
          "type": {
            "__tag": "Other",
            "values": "Set<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 426,
        "to": 426
      }
    }
  },
  {
    "name": "toArray",
    "text": "const toArray = <A>(O: Ord<A>) => (set: Set<A>): Array<A> => {\n  const out: Array<A> = []\n  set.forEach((e) => out.push(e))\n  return out.sort(O.compare)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "O",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Ord\").Ord<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(set: Set<A>) => A[]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Set.ts",
      "lines": {
        "from": 461,
        "to": 465
      }
    }
  },
  {
    "name": "struct",
    "text": "const struct = <A>(shows: { [K in keyof A]: Show<A[K]> }): Show<{ readonly [K in keyof A]: A[K] }> => ({\n  show: (a) => {\n    let s = '{'\n    for (const k in shows) {\n      if (_.has.call(shows, k)) {\n        s += ` ${k}: ${shows[k].show(a[k])},`\n      }\n    }\n    if (s.length > 1) {\n      s = s.slice(0, -1) + ' '\n    }\n    s += '}'\n    return s\n  }\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "shows",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<{ readonly [K in keyof A]: A[K]; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Show.ts",
      "lines": {
        "from": 34,
        "to": 48
      }
    }
  },
  {
    "name": "tuple",
    "text": "const tuple = <A extends ReadonlyArray<unknown>>(\n  ...shows: { [K in keyof A]: Show<A[K]> }\n): Show<Readonly<A>> => ({\n  show: (t) => `[${t.map((a, i) => shows[i].show(a)).join(', ')}]`\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "shows",
          "type": {
            "__tag": "Other",
            "values": "{ [K in keyof A]: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A[K]>; }"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<Readonly<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Show.ts",
      "lines": {
        "from": 54,
        "to": 58
      }
    }
  },
  {
    "name": "get",
    "text": "const get: <S>() => State<S, S> = () => (s) => [s, s]",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [S, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 34,
        "to": 34
      }
    }
  },
  {
    "name": "put",
    "text": "const put: <S>(s: S) => State<S, void> = (s) => () => [undefined, s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [any, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 42,
        "to": 42
      }
    }
  },
  {
    "name": "modify",
    "text": "const modify: <S>(f: (s: S) => S) => State<S, void> = (f) => (s) => [undefined, f(s)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [any, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "gets",
    "text": "const gets: <S, A>(f: (s: S) => A) => State<S, A> = (f) => (s) => [f(s), s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => [A, S]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 58,
        "to": 58
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: State<E, A>) => State<E, B> = (f) => (fa) => (s1) => {\n  const [a, s2] = fa(s1)\n  return [f(a), s2]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 82,
        "to": 85
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <E, A>(fa: State<E, A>) => <B>(fab: State<E, (a: A) => B>) => State<E, B> = (fa) => (fab) => (s1) => {\n  const [f, s2] = fab(s1)\n  const [a, s3] = fa(s2)\n  return [f(a), s3]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, (a: A) => B>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 93,
        "to": 97
      }
    }
  },
  {
    "name": "of",
    "text": "const of: Pointed2<URI>['of'] = (a) => (s) => [a, s]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: E) => [A, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 103,
        "to": 103
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <E, A, B>(f: (a: A) => State<E, B>) => (ma: State<E, A>) => State<E, B> = (f) => (ma) => (s1) => {\n  const [a, s2] = ma(s1)\n  return f(a)(s2)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<E, A>) => (s1: E) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 111,
        "to": 114
      }
    }
  },
  {
    "name": "evaluate",
    "text": "const evaluate = <S>(s: S) => <A>(ma: State<S, A>): A => ma(s)[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 266,
        "to": 266
      }
    }
  },
  {
    "name": "execute",
    "text": "const execute = <S>(s: S) => <A>(ma: State<S, A>): S => ma(s)[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 273,
        "to": 273
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, S, B>(f: (index: number, a: A) => State<S, B>) => (\n  as: ReadonlyArray<A>\n): State<S, ReadonlyArray<B>> => (s) => {\n  let lastState = s\n  const values = []\n  for (let i = 0; i < as.length; i++) {\n    const [newValue, newState] = f(i, as[i])(lastState)\n    values.push(newValue)\n    lastState = newState\n  }\n  return [values, lastState]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 313,
        "to": 324
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, S, B>(\n  f: (a: A) => State<S, B>\n): ((as: ReadonlyArray<A>) => State<S, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 331,
        "to": 333
      }
    }
  },
  {
    "name": "evalState",
    "text": "const evalState: <S, A>(ma: State<S, A>, s: S) => A = (ma, s) => ma(s)[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 354,
        "to": 354
      }
    }
  },
  {
    "name": "execState",
    "text": "const execState: <S, A>(ma: State<S, A>, s: S) => S = (ma, s) => ma(s)[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "S"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/State.ts",
      "lines": {
        "from": 362,
        "to": 362
      }
    }
  },
  {
    "name": "rightTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightTask<S, R, E = never, A = never>(ma: Task<A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightTask(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "leftTask",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftTask<S, R, E = never, A = never>(me: Task<E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftTask(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 90,
        "to": 92
      }
    }
  },
  {
    "name": "fromTaskEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromTaskEither<S, R, E, A>(ma: TaskEither<E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromTaskEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "rightReader",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightReader<S, R, E = never, A = never>(ma: Reader<R, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightReader(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "leftReader",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftReader<S, R, E = never, A = never>(me: Reader<R, E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftReader(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Reader\").Reader<R, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 114,
        "to": 116
      }
    }
  },
  {
    "name": "fromIOEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromIOEither<S, R, E, A>(ma: IOEither<E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromIOEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "fromReaderEither",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function fromReaderEither<S, R, E, A>(ma: ReaderEither<R, E, A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.fromReaderEither(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderEither\").ReaderEither<R, E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 130,
        "to": 132
      }
    }
  },
  {
    "name": "rightIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function rightIO<S, R, E = never, A = never>(ma: IO<A>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.rightIO(ma))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 138,
        "to": 140
      }
    }
  },
  {
    "name": "leftIO",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function leftIO<S, R, E = never, A = never>(me: IO<E>): StateReaderTaskEither<S, R, E, A> {\n  return fromReaderTaskEither(RTE.leftIO(me))\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 146,
        "to": 148
      }
    }
  },
  {
    "name": "fromReaderTaskEitherK",
    "text": "\n\n/**\n * @category combinators\n * @since 2.4.0\n */\nexport function fromReaderTaskEitherK<R, E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => ReaderTaskEither<R, E, B>\n): <S>(...a: A) => StateReaderTaskEither<S, R, E, B> {\n  return (...a) => fromReaderTaskEither(f(...a))\n}",
    "docs": "/**\n * @category combinators\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 295,
        "to": 299
      }
    }
  },
  {
    "name": "run",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\n/* istanbul ignore next */\nexport function run<S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S, r: R): Promise<Either<E, [A, S]>> {\n  return ma(s)(r)()\n}",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        },
        {
          "name": "r",
          "type": {
            "__tag": "Other",
            "values": "R"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, [A, S]>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 1088,
        "to": 1090
      }
    }
  },
  {
    "name": "left",
    "text": "const left: <S, R, E = never, A = never>(e: E) => StateReaderTaskEither<S, R, E, A> = (e) => () => RTE.left(e)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 68,
        "to": 68
      }
    }
  },
  {
    "name": "rightState",
    "text": "const rightState: <S, R, E = never, A = never>(ma: State<S, A>) => StateReaderTaskEither<S, R, E, A> = (sa) =>\n  flow(sa, RTE.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "sa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<unknown, never, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 154,
        "to": 155
      }
    }
  },
  {
    "name": "leftState",
    "text": "const leftState: <S, R, E = never, A = never>(me: State<S, E>) => StateReaderTaskEither<S, R, E, A> = (me) => (\n  s\n) => RTE.left(me(s)[0])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "me",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, [A, S]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 161,
        "to": 163
      }
    }
  },
  {
    "name": "get",
    "text": "const get = <S, R, E = never>(): StateReaderTaskEither<S, R, E, S> => (s) => RTE.of([s, s])",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 179,
        "to": 179
      }
    }
  },
  {
    "name": "put",
    "text": "const put = <S, R, E = never>(s: S): StateReaderTaskEither<S, R, E, void> => () => RTE.of([undefined, s])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 187,
        "to": 187
      }
    }
  },
  {
    "name": "modify",
    "text": "const modify = <S, R, E = never>(f: (s: S) => S): StateReaderTaskEither<S, R, E, void> => (s) =>\n  RTE.of([undefined, f(s)])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, void>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 195,
        "to": 196
      }
    }
  },
  {
    "name": "gets",
    "text": "const gets = <S, R, E = never, A = never>(f: (s: S) => A): StateReaderTaskEither<S, R, E, A> => (s) =>\n  RTE.of([f(s), s])",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(s: S) => A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 204,
        "to": 205
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "const fromIOEitherK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): (<S, R>(...a: A) => StateReaderTaskEither<S, R, E, B>) => (...a) => fromIOEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 243,
        "to": 245
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW = <E2, A, B>(f: (a: A) => IOEither<E2, B>) => <S, R, E1>(\n  ma: StateReaderTaskEither<S, R, E1, A>\n): StateReaderTaskEither<S, R, E1 | E2, B> => pipe(ma, chainW<S, R, E2, A, B>(fromIOEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 253,
        "to": 255
      }
    }
  },
  {
    "name": "fromTaskEitherK",
    "text": "const fromTaskEitherK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => TaskEither<E, B>\n): (<S, R>(...a: A) => StateReaderTaskEither<S, R, E, B>) => (...a) => fromTaskEither(f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 269,
        "to": 271
      }
    }
  },
  {
    "name": "chainTaskEitherKW",
    "text": "const chainTaskEitherKW = <E2, A, B>(f: (a: A) => TaskEither<E2, B>) => <S, R, E1>(\n  ma: StateReaderTaskEither<S, R, E1, A>\n): StateReaderTaskEither<S, R, E1 | E2, B> => pipe(ma, chainW<S, R, E2, A, B>(fromTaskEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 279,
        "to": 281
      }
    }
  },
  {
    "name": "chainReaderTaskEitherKW",
    "text": "const chainReaderTaskEitherKW = <R, E2, A, B>(f: (a: A) => ReaderTaskEither<R, E2, B>) => <S, E1>(\n  ma: StateReaderTaskEither<S, R, E1, A>\n): StateReaderTaskEither<S, R, E1 | E2, B> => pipe(ma, chainW<S, R, E2, A, B>(fromReaderTaskEitherK(f)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 307,
        "to": 309
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <S, R>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, B> = (f, g) => (fa) =>\n  _bimap(fa, f, g)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 375,
        "to": 379
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(\n  f: (e: E) => G\n) => <S, R, A>(fa: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, G, A> = (f) => (fa) =>\n  _mapLeft(fa, f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 387,
        "to": 390
      }
    }
  },
  {
    "name": "altW",
    "text": "const altW = <S, R2, E2, B>(that: () => StateReaderTaskEither<S, R2, E2, B>) => <R1, E1, A>(\n  fa: StateReaderTaskEither<S, R1, E1, A>\n): StateReaderTaskEither<S, R1 & R2, E2, A | B> => (r) =>\n  pipe(\n    fa(r),\n    RTE.altW(() => that()(r))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "that",
          "type": {
            "__tag": "Other",
            "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R2, E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R1, E1, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R1, E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R1 & R2, E2, B | A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 462,
        "to": 468
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <S, R, E, A, B>(\n  f: (index: number, a: A) => StateReaderTaskEither<S, R, E, B>\n) => (as: ReadonlyArray<A>): StateReaderTaskEither<S, R, E, ReadonlyArray<B>> => (s) => (r) => () =>\n  as.reduce<Promise<Either<E, [Array<B>, S]>>>(\n    (acc, a, i) =>\n      acc.then((ebs) =>\n        E.isLeft(ebs)\n          ? acc\n          : f(\n              i,\n              a\n            )(ebs.right[1])(r)().then((eb) => {\n              if (E.isLeft(eb)) {\n                return eb\n              }\n              const [b, s] = eb.right\n              ebs.right[0].push(b)\n              ebs.right[1] = s\n              return ebs\n            })\n      ),\n    Promise.resolve(E.right([[], s]))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 957,
        "to": 979
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <S, R, E, A, B>(\n  f: (a: A) => StateReaderTaskEither<S, R, E, B>\n): ((as: ReadonlyArray<A>) => StateReaderTaskEither<S, R, E, ReadonlyArray<B>>) =>\n  traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 986,
        "to": 989
      }
    }
  },
  {
    "name": "evalState",
    "text": "const evalState: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, A> = (\n  fsa,\n  s\n) =>\n  pipe(\n    fsa(s),\n    RTE.map(([a]) => a)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fsa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 1058,
        "to": 1065
      }
    }
  },
  {
    "name": "execState",
    "text": "const execState: <S, R, E, A>(ma: StateReaderTaskEither<S, R, E, A>, s: S) => ReaderTaskEither<R, E, S> = (\n  fsa,\n  s\n) =>\n  pipe(\n    fsa(s),\n    RTE.map(([_, s]) => s)\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fsa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateReaderTaskEither\").StateReaderTaskEither<S, R, E, A>"
          }
        },
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReaderTaskEither\").ReaderTaskEither<R, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateReaderTaskEither.ts",
      "lines": {
        "from": 1074,
        "to": 1081
      }
    }
  },
  {
    "name": "of",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function of<F extends URIS3>(F: Pointed3<F>): <A, S, R, E>(a: A) => StateT3<F, S, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS3, E>(F: Pointed3C<F, E>): <A, S, R>(a: A) => StateT3<F, S, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 48,
        "to": 48
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS2>(F: Pointed2<F>): <A, S, E>(a: A) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, E>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 49,
        "to": 49
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS2, E>(F: Pointed2C<F, E>): <A, S>(a: A) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F extends URIS>(F: Pointed1<F>): <A, S>(a: A) => StateT1<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 51,
        "to": 51
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F>(F: Pointed<F>): <A, S>(a: A) => StateT<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 52,
        "to": 52
      }
    }
  },
  {
    "name": "of",
    "text": "\nexport function of<F>(F: Pointed<F>): <A, S>(a: A) => StateT<F, S, A> {\n  return (a) => (s) => F.of([a, s])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 53,
        "to": 55
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <S, R, E>(fa: StateT3<F, S, R, E, A>) => StateT3<F, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S, R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 60,
        "to": 62
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <A, B>(f: (a: A) => B) => <S, R>(fa: StateT3<F, S, R, E, A>) => StateT3<F, S, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S, R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 63,
        "to": 65
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <S, E>(fa: StateT2<F, S, E, A>) => StateT2<F, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <A, B>(f: (a: A) => B) => <S>(fa: StateT2<F, S, E, A>) => StateT2<F, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 69,
        "to": 71
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS>(\n  F: Functor1<F>\n): <A, B>(f: (a: A) => B) => <S>(fa: StateT1<F, S, A>) => StateT1<F, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 72,
        "to": 74
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <S>(fa: StateT<F, S, A>) => StateT<F, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 75,
        "to": 75
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <S>(fa: StateT<F, S, A>) => StateT<F, S, B> {\n  return (f) => (fa) => (s) => F.map(fa(s), ([a, s1]) => [f(a), s1])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <S>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 76,
        "to": 78
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function ap<M extends URIS3>(\n  M: Chain3<M>\n): <S, R, E, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 83,
        "to": 85
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <S, R, A>(fa: StateT3<M, S, R, E, A>) => <B>(fab: StateT3<M, S, R, E, (a: A) => B>) => StateT3<M, S, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 86,
        "to": 88
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M extends URIS2>(\n  M: Chain2<M>\n): <S, E, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, E, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 89,
        "to": 91
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <S, A>(fa: StateT2<M, S, E, A>) => <B>(fab: StateT2<M, S, E, (a: A) => B>) => StateT2<M, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 92,
        "to": 94
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M extends URIS>(\n  M: Chain1<M>\n): <S, A>(fa: StateT1<M, S, A>) => <B>(fab: StateT1<M, S, (a: A) => B>) => StateT1<M, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 95,
        "to": 97
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M>(\n  M: Chain<M>\n): <S, A>(fa: StateT<M, S, A>) => <B>(fab: StateT<M, S, (a: A) => B>) => StateT<M, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 98,
        "to": 100
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<M>(\n  M: Chain<M>\n): <S, A>(fa: StateT<M, S, A>) => <B>(fab: StateT<M, S, (a: A) => B>) => StateT<M, S, B> {\n  return (fa) => (fab) => (s) => M.chain(fab(s), ([f, s]) => M.map(fa(s), ([a, s]) => [f(a), s]))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, A>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, (a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 101,
        "to": 105
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chain<M extends URIS3>(\n  M: Chain3<M>\n): <A, S, R, E, B>(f: (a: A) => StateT3<M, S, R, E, B>) => (ma: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 110,
        "to": 112
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3, E>(\n  M: Chain3C<M, E>\n): <A, S, R, B>(f: (a: A) => StateT3<M, S, R, E, B>) => (ma: StateT3<M, S, R, E, A>) => StateT3<M, S, R, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<M, S, R, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 113,
        "to": 115
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2>(\n  M: Chain2<M>\n): <A, S, E, B>(f: (a: A) => StateT2<M, S, E, B>) => (ma: StateT2<M, S, E, A>) => StateT2<M, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, E, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, E>(\n  M: Chain2C<M, E>\n): <A, S, B>(f: (a: A) => StateT2<M, S, E, B>) => (ma: StateT2<M, S, E, A>) => StateT2<M, S, E, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<M, S, E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 119,
        "to": 121
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS>(\n  M: Chain1<M>\n): <A, S, B>(f: (a: A) => StateT1<M, S, B>) => (ma: StateT1<M, S, A>) => StateT1<M, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 122,
        "to": 124
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Chain<M>\n): <A, S, B>(f: (a: A) => StateT<M, S, B>) => (ma: StateT<M, S, A>) => StateT<M, S, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 125,
        "to": 127
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M>(\n  M: Chain<M>\n): <A, S, B>(f: (a: A) => StateT<M, S, B>) => (ma: StateT<M, S, A>) => StateT<M, S, B> {\n  return (f) => (ma) => (s) => M.chain(ma(s), ([a, s1]) => f(a)(s1))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<M, S, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 128,
        "to": 132
      }
    }
  },
  {
    "name": "fromState",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromState<F extends URIS3>(F: Pointed3<F>): <S, A, R, E>(sa: State<S, A>) => StateT3<F, S, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A, R, E>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 137,
        "to": 137
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F extends URIS3, E>(F: Pointed3C<F, E>): <S, A, R>(sa: State<S, A>) => StateT3<F, S, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A, R>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 138,
        "to": 138
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F extends URIS2>(F: Pointed2<F>): <S, A, E>(sa: State<S, A>) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A, E>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 139,
        "to": 139
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F extends URIS2, E>(F: Pointed2C<F, E>): <S, A>(sa: State<S, A>) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 140,
        "to": 140
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F extends URIS>(F: Pointed1<F>): <S, A>(sa: State<S, A>) => StateT1<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 141,
        "to": 141
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F>(F: Pointed<F>): <S, A>(sa: State<S, A>) => StateT<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 142,
        "to": 142
      }
    }
  },
  {
    "name": "fromState",
    "text": "\nexport function fromState<F>(F: Pointed<F>): <S, A>(sa: State<S, A>) => StateT<F, S, A> {\n  return (sa) => (s) => F.of(sa(s))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, A>(sa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/State\").State<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 143,
        "to": 145
      }
    }
  },
  {
    "name": "fromF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function fromF<F extends URIS3>(F: Functor3<F>): <R, E, A, S>(ma: Kind3<F, R, E, A>) => StateT3<F, S, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 150,
        "to": 150
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <R, A, S>(ma: Kind3<F, R, E, A>) => StateT3<F, S, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 151,
        "to": 153
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS2>(F: Functor2<F>): <E, A, S>(ma: Kind2<F, E, A>) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 154,
        "to": 154
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS2, E>(F: Functor2C<F, E>): <A, S>(ma: Kind2<F, E, A>) => StateT2<F, S, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 155,
        "to": 155
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F extends URIS>(F: Functor1<F>): <A, S>(ma: Kind<F, A>) => StateT1<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 156,
        "to": 156
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F>(F: Functor<F>): <A, S>(ma: HKT<F, A>) => StateT<F, S, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 157,
        "to": 157
      }
    }
  },
  {
    "name": "fromF",
    "text": "\nexport function fromF<F>(F: Functor<F>): <A, S>(ma: HKT<F, A>) => StateT<F, S, A> {\n  return (ma) => (s) => F.map(ma, (a) => [a, s])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 158,
        "to": 160
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function evaluate<F extends URIS3>(\n  F: Functor3<F>\n): <S>(s: S) => <R, E, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, A>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 165,
        "to": 167
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <S>(s: S) => <R, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 168,
        "to": 170
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F extends URIS2>(\n  F: Functor2<F>\n): <S>(s: S) => <E, A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 171,
        "to": 173
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <S>(s: S) => <A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 174,
        "to": 176
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F extends URIS>(F: Functor1<F>): <S>(s: S) => <A>(ma: StateT1<F, S, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 177,
        "to": 177
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 178,
        "to": 178
      }
    }
  },
  {
    "name": "evaluate",
    "text": "\nexport function evaluate<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, A> {\n  return (s) => (ma) => F.map(ma(s), ([a]) => a)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 179,
        "to": 181
      }
    }
  },
  {
    "name": "execute",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function execute<F extends URIS3>(\n  F: Functor3<F>\n): <S>(s: S) => <R, E, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, S>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 186,
        "to": 188
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <S>(s: S) => <R, A>(ma: StateT3<F, S, R, E, A>) => Kind3<F, R, E, S>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <R, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT3<F, S, R, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 189,
        "to": 191
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F extends URIS2>(F: Functor2<F>): <S>(s: S) => <E, A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, S>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 192,
        "to": 192
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <S>(s: S) => <A>(ma: StateT2<F, S, E, A>) => Kind2<F, E, S>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT2<F, S, E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 193,
        "to": 195
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F extends URIS>(F: Functor1<F>): <S>(s: S) => <A>(ma: StateT1<F, S, A>) => Kind<F, S>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT1<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 196,
        "to": 196
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, S>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 197,
        "to": 197
      }
    }
  },
  {
    "name": "execute",
    "text": "\nexport function execute<F>(F: Functor<F>): <S>(s: S) => <A>(ma: StateT<F, S, A>) => HKT<F, S> {\n  return (s) => (ma) => F.map(ma(s), snd)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(s: S) => <A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateT<F, S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 198,
        "to": 200
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport function getStateM<M extends URIS3>(M: Monad3<M>): StateM3<M>",
    "docs": "/**\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 335,
        "to": 335
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\nexport function getStateM<M extends URIS3, E>(M: Monad3C<M, E>): StateM3C<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM3C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 337,
        "to": 337
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\nexport function getStateM<M extends URIS2>(M: Monad2<M>): StateM2<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 339,
        "to": 339
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\nexport function getStateM<M extends URIS2, E>(M: Monad2C<M, E>): StateM2C<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 341,
        "to": 341
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\nexport function getStateM<M extends URIS>(M: Monad1<M>): StateM1<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 343,
        "to": 343
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\nexport function getStateM<M>(M: Monad<M>): StateM<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 345,
        "to": 345
      }
    }
  },
  {
    "name": "getStateM",
    "text": "\n/** @deprecated */\n/* istanbul ignore next */\nexport function getStateM<M>(M: Monad<M>): StateM<M> {\n  const _ap = ap(M)\n  const _map = map(M)\n  const _chain = chain(M)\n  const _evaluate = evaluate(M)\n  const _execute = execute(M)\n\n  return {\n    map: (fa, f) => pipe(fa, _map(f)),\n    ap: (fab, fa) => pipe(fab, _ap(fa)),\n    of: of(M),\n    chain: (ma, f) => pipe(ma, _chain(f)),\n    get: () => (s) => M.of([s, s]),\n    put: (s) => () => M.of([undefined, s]),\n    modify: (f) => (s) => M.of([undefined, f(s)]),\n    gets: (f) => (s) => M.of([f(s), s]),\n    fromState: fromState(M),\n    fromM: fromF(M),\n    evalState: (fa, s) => pipe(fa, _evaluate(s)),\n    execState: (fa, s) => pipe(fa, _execute(s))\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/StateT\").StateM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/StateT.ts",
      "lines": {
        "from": 348,
        "to": 369
      }
    }
  },
  {
    "name": "seek",
    "text": "\n\n/**\n * Reposition the focus at the specified position\n *\n * @since 2.0.0\n */\nexport function seek<S>(s: S): <A>(wa: Store<S, A>) => Store<S, A> {\n  return (wa) => ({ peek: wa.peek, pos: s })\n}",
    "docs": "/**\n * Reposition the focus at the specified position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "Other",
            "values": "S"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 28,
        "to": 30
      }
    }
  },
  {
    "name": "seeks",
    "text": "\n\n/**\n * Reposition the focus at the specified position, which depends on the current position\n *\n * @since 2.0.0\n */\nexport function seeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => Store<S, A> {\n  return (wa) => ({ peek: wa.peek, pos: f(wa.pos) })\n}",
    "docs": "/**\n * Reposition the focus at the specified position, which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 37,
        "to": 39
      }
    }
  },
  {
    "name": "peeks",
    "text": "\n\n/**\n * Extract a value from a position which depends on the current position\n *\n * @since 2.0.0\n */\nexport function peeks<S>(f: Endomorphism<S>): <A>(wa: Store<S, A>) => A {\n  return (wa) => wa.peek(f(wa.pos))\n}",
    "docs": "/**\n * Extract a value from a position which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Endomorphism<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 46,
        "to": 48
      }
    }
  },
  {
    "name": "experiment",
    "text": "\n\n/**\n * Extract a collection of values from positions which depend on the current position\n *\n * @since 2.0.0\n */\nexport function experiment<F extends URIS3>(\n  F: Functor3<F>\n): <R, E, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>",
    "docs": "/**\n * Extract a collection of values from positions which depend on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 55,
        "to": 57
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS3, E>(\n  F: Functor3C<F, E>\n): <R, S>(f: (s: S) => Kind3<F, R, E, S>) => <A>(wa: Store<S, A>) => Kind3<F, R, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 58,
        "to": 60
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS2>(\n  F: Functor2<F>\n): <E, S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS2, E>(\n  F: Functor2C<F, E>\n): <S>(f: (s: S) => Kind2<F, E, S>) => <A>(wa: Store<S, A>) => Kind2<F, E, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 64,
        "to": 66
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F extends URIS>(\n  F: Functor1<F>\n): <S>(f: (s: S) => Kind<F, S>) => <A>(wa: Store<S, A>) => Kind<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F>(F: FunctorHKT<F>): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 70,
        "to": 70
      }
    }
  },
  {
    "name": "experiment",
    "text": "\nexport function experiment<F>(F: FunctorHKT<F>): <S>(f: (s: S) => HKT<F, S>) => <A>(wa: Store<S, A>) => HKT<F, A> {\n  return (f) => (wa) => F.map(f(wa.pos), (s) => wa.peek(s))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S>(f: (s: S) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, S>) => <A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<S, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 71,
        "to": 73
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: Store<E, A>) => B) => (wa: Store<E, A>) => Store<E, B> = (f) => (wa) => ({\n  peek: (s) => f({ peek: wa.peek, pos: s }),\n  pos: wa.pos\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => { peek: (s: E) => B; pos: E; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 92,
        "to": 95
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: <E, A>(wa: Store<E, A>) => A = (wa) => wa.peek(wa.pos)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 101,
        "to": 101
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Store<E, A>) => Store<E, B> = (f) => (fa) => ({\n  peek: (s) => f(fa.peek(s)),\n  pos: fa.pos\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Store\").Store<E, A>) => { peek: (s: E) => B; pos: E; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Store.ts",
      "lines": {
        "from": 120,
        "to": 123
      }
    }
  },
  {
    "name": "isEmpty",
    "text": "const isEmpty = (s: string): boolean => s.length === 0",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/string.ts",
      "lines": {
        "from": 81,
        "to": 81
      }
    }
  },
  {
    "name": "size",
    "text": "const size = (s: string): number => s.length",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "s",
          "type": {
            "__tag": "StringT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/string.ts",
      "lines": {
        "from": 88,
        "to": 88
      }
    }
  },
  {
    "name": "split",
    "text": "\n\n/**\n * Compose a value acting on a tuple from two values, each acting on one of the components of the tuple.\n *\n * Specializing `split` to function application would look like this:\n *\n * ```purescript\n * split :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which takes a tuple and maps `f`\n * over the first element and `g` over the second.  Just like `bi-map` would do for the `bi-functor` instance of tuple.\n *\n * @since 2.10.0\n */\nexport function split<F extends URIS4>(\n  S: Strong4<F>,\n  C: Category4<F>\n): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>",
    "docs": "/**\n * Compose a value acting on a tuple from two values, each acting on one of the components of the tuple.\n *\n * Specializing `split` to function application would look like this:\n *\n * ```purescript\n * split :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)\n * ```\n *\n * We take two functions, `f` and `g`, and we transform them into a single function which takes a tuple and maps `f`\n * over the first element and `g` over the second.  Just like `bi-map` would do for the `bi-functor` instance of tuple.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 89,
        "to": 92
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<F extends URIS3>(\n  S: Strong3<F>,\n  C: Category3<F>\n): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 93,
        "to": 96
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<F extends URIS2>(\n  S: Strong2<F>,\n  C: Category2<F>\n): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 97,
        "to": 100
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<F>(\n  S: Strong<F>,\n  C: Category<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 101,
        "to": 104
      }
    }
  },
  {
    "name": "split",
    "text": "\nexport function split<F>(\n  S: Strong<F>,\n  C: Category<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]> {\n  return <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) =>\n    C.compose(S.second<B, C, D>(pcd), S.first<A, B, C>(pab))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 105,
        "to": 111
      }
    }
  },
  {
    "name": "fanOut",
    "text": "\n\n/**\n * Compose a value which introduces a tuple from two values, each introducing one side of the tuple.\n *\n * This combinator is useful when assembling values from smaller components, because it provides a way to support two\n * different types of output.\n *\n * Specializing `fanOut` to function application would look like this:\n *\n * ```purescript\n * fanOut :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n * ```\n *\n * We take two functions, `f` and `g`, with the same parameter type and we transform them into a single function which\n * takes one parameter and returns a tuple of the results of running `f` and `g` on the parameter, respectively.  This\n * allows us to run two parallel computations on the same input and return both results in a tuple.\n *\n * @since 2.10.0\n */\nexport function fanOut<F extends URIS4>(\n  S: Strong4<F>,\n  C: Category4<F>\n): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>",
    "docs": "/**\n * Compose a value which introduces a tuple from two values, each introducing one side of the tuple.\n *\n * This combinator is useful when assembling values from smaller components, because it provides a way to support two\n * different types of output.\n *\n * Specializing `fanOut` to function application would look like this:\n *\n * ```purescript\n * fanOut :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n * ```\n *\n * We take two functions, `f` and `g`, with the same parameter type and we transform them into a single function which\n * takes one parameter and returns a tuple of the results of running `f` and `g` on the parameter, respectively.  This\n * allows us to run two parallel computations on the same input and return both results in a tuple.\n *\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 131,
        "to": 134
      }
    }
  },
  {
    "name": "fanOut",
    "text": "\nexport function fanOut<F extends URIS3>(\n  S: Strong3<F>,\n  C: Category3<F>\n): <R, A, B, C>(pab: Kind3<F, R, A, B>, pac: Kind3<F, R, A, C>) => Kind3<F, R, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "fanOut",
    "text": "\nexport function fanOut<F extends URIS2>(\n  S: Strong2<F>,\n  C: Category2<F>\n): <A, B, C>(pab: Kind2<F, A, B>, pac: Kind2<F, A, C>) => Kind2<F, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 139,
        "to": 142
      }
    }
  },
  {
    "name": "fanOut",
    "text": "\nexport function fanOut<F>(\n  S: Strong<F>,\n  C: Category<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 143,
        "to": 146
      }
    }
  },
  {
    "name": "fanOut",
    "text": "\nexport function fanOut<F>(\n  S: Strong<F>,\n  C: Category<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]> {\n  const splitSC = split(S, C)\n  return <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>): HKT2<F, A, [B, C]> =>\n    C.compose(\n      splitSC(pab, pac),\n      S.promap<A, A, A, [A, A]>(C.id<A>(), identity, (a) => [a, a])\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        },
        {
          "name": "C",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 147,
        "to": 157
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n\n/**\n * Use [`split`](#split) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function splitStrong<F extends URIS4>(\n  F: Category4<F> & Strong4<F>\n): <S, R, A, B, C, D>(pab: Kind4<F, S, R, A, B>, pcd: Kind4<F, S, R, C, D>) => Kind4<F, S, R, [A, C], [B, D]>",
    "docs": "/**\n * Use [`split`](#split) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 169,
        "to": 171
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\n/** @deprecated */\nexport function splitStrong<F extends URIS3>(\n  F: Category3<F> & Strong3<F>\n): <R, A, B, C, D>(pab: Kind3<F, R, A, B>, pcd: Kind3<F, R, C, D>) => Kind3<F, R, [A, C], [B, D]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 173,
        "to": 175
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\n/** @deprecated */\nexport function splitStrong<F extends URIS2>(\n  F: Category2<F> & Strong2<F>\n): <A, B, C, D>(pab: Kind2<F, A, B>, pcd: Kind2<F, C, D>) => Kind2<F, [A, C], [B, D]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 177,
        "to": 179
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\n/** @deprecated */\nexport function splitStrong<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 181,
        "to": 183
      }
    }
  },
  {
    "name": "splitStrong",
    "text": "\nexport function splitStrong<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C, D>(pab: HKT2<F, A, B>, pcd: HKT2<F, C, D>) => HKT2<F, [A, C], [B, D]> {\n  return split(F, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C, D>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pcd: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, C, D>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, [A, C], [B, D]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 184,
        "to": 188
      }
    }
  },
  {
    "name": "fanout",
    "text": "\n\n/**\n * Use [`fanOut`](#fanout) instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function fanout<F extends URIS4>(\n  F: Category4<F> & Strong4<F>\n): <S, R, A, B, C>(pab: Kind4<F, S, R, A, B>, pac: Kind4<F, S, R, A, C>) => Kind4<F, S, R, A, [B, C]>",
    "docs": "/**\n * Use [`fanOut`](#fanout) instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category4<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong4<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<F, S, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 196,
        "to": 198
      }
    }
  },
  {
    "name": "fanout",
    "text": "\n/** @deprecated */\nexport function fanout<F extends URIS3>(\n  F: Category3<F> & Strong3<F>\n): <R, A, B, C>(pab: Kind3<F, R, A, B>, pac: Kind3<F, R, A, C>) => Kind3<F, R, A, [B, C]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category3<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 200,
        "to": 202
      }
    }
  },
  {
    "name": "fanout",
    "text": "\n/** @deprecated */\nexport function fanout<F extends URIS2>(\n  F: Category2<F> & Strong2<F>\n): <A, B, C>(pab: Kind2<F, A, B>, pac: Kind2<F, A, C>) => Kind2<F, A, [B, C]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category2<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 204,
        "to": 206
      }
    }
  },
  {
    "name": "fanout",
    "text": "\n/** @deprecated */\nexport function fanout<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 208,
        "to": 210
      }
    }
  },
  {
    "name": "fanout",
    "text": "\nexport function fanout<F>(\n  F: Category<F> & Strong<F>\n): <A, B, C>(pab: HKT2<F, A, B>, pac: HKT2<F, A, C>) => HKT2<F, A, [B, C]> {\n  return fanOut(F, F)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Category\").Category<F> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Strong\").Strong<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B, C>(pab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, B>, pac: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, C>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT2<F, A, [B, C]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Strong.ts",
      "lines": {
        "from": 211,
        "to": 215
      }
    }
  },
  {
    "name": "delay",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = append('b')\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(log, ['a', 'b', 'd', 'c'])\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function delay(millis: number): <A>(ma: Task<A>) => Task<A> {\n  return (ma) => () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        // tslint:disable-next-line: no-floating-promises\n        ma().then(resolve)\n      }, millis)\n    })\n}",
    "docs": "/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = append('b')\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(log, ['a', 'b', 'd', 'c'])\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "millis",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 85,
        "to": 93
      }
    }
  },
  {
    "name": "getRaceMonoid",
    "text": "\n\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid<A = never>(): Monoid<Task<A>> {\n  return {\n    concat: (x, y) => () => Promise.race([x(), y()]),\n    empty: never\n  }\n}",
    "docs": "/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 204,
        "to": 209
      }
    }
  },
  {
    "name": "fromIO",
    "text": "const fromIO: FromIO1<URI>['fromIO'] = (ma) => () => Promise.resolve(ma())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 53,
        "to": 53
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Task<A>) => Task<B> = (f) => (fa) => () => fa().then(f)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => () => Promise<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 119,
        "to": 119
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Task<A>) => <B>(fab: Task<(a: A) => B>) => Task<B> = (fa) => (fab) => () =>\n  Promise.all([fab(), fa()]).then(([f, a]) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<(a: A) => B>) => () => Promise<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 127,
        "to": 128
      }
    }
  },
  {
    "name": "of",
    "text": "const of: Pointed1<URI>['of'] = (a) => () => Promise.resolve(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => Promise<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 134,
        "to": 134
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain: <A, B>(f: (a: A) => Task<B>) => (ma: Task<A>) => Task<B> = (f) => (ma) => () =>\n  ma().then((a) => f(a)())",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<A>) => () => Promise<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 142,
        "to": 143
      }
    }
  },
  {
    "name": "never",
    "text": "const never: Task<never> = () => new Promise((_) => undefined)",
    "docs": "",
    "signature": {
      "parameters": [],
      "returnType": {
        "__tag": "Other",
        "values": "Promise<never>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 420,
        "to": 420
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, B>(f: (index: number, a: A) => Task<B>) => (\n  as: ReadonlyArray<A>\n): Task<ReadonlyArray<B>> => () => Promise.all(as.map((x, i) => f(i, x)()))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 467,
        "to": 469
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, B>(f: (a: A) => Task<B>): ((as: ReadonlyArray<A>) => Task<ReadonlyArray<B>>) =>\n  traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 476,
        "to": 477
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <A, B>(f: (index: number, a: A) => Task<B>) => (\n  as: ReadonlyArray<A>\n): Task<ReadonlyArray<B>> => () =>\n  as.reduce<Promise<Array<B>>>(\n    (acc, a, i) =>\n      acc.then((bs) =>\n        f(i, a)().then((b) => {\n          bs.push(b)\n          return bs\n        })\n      ),\n    Promise.resolve([])\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 493,
        "to": 505
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray = <A, B>(f: (a: A) => Task<B>): ((as: ReadonlyArray<A>) => Task<ReadonlyArray<B>>) =>\n  traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Task.ts",
      "lines": {
        "from": 512,
        "to": 513
      }
    }
  },
  {
    "name": "getApplicativeTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation<E>(A: Apply1<T.URI>, S: Semigroup<E>): Applicative2C<URI, E> {\n  const ap = ap_(A, E.getApplicativeValidation(S))\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => pipe(fab, ap(fa)),\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<\"Task\">"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 552,
        "to": 561
      }
    }
  },
  {
    "name": "getAltTaskValidation",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getAltTaskValidation<E>(S: Semigroup<E>): Alt2C<URI, E> {\n  const alt = ET.altValidation(T.Monad, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    alt: (fa, that) => pipe(fa, alt(that))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 567,
        "to": 575
      }
    }
  },
  {
    "name": "getFilterable",
    "text": "\n\n/**\n * @category instances\n * @since 2.1.0\n */\nexport function getFilterable<E>(M: Monoid<E>): Filterable2C<URI, E> {\n  const F = E.getFilterable(M)\n  const C = getCompactable(M)\n\n  const filter = filter_(T.Functor, F)\n  const filterMap = filterMap_(T.Functor, F)\n  const partition = partition_(T.Functor, F)\n  const partitionMap = partitionMap_(T.Functor, F)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    compact: C.compact,\n    separate: C.separate,\n    filter: <A>(fa: TaskEither<E, A>, predicate: Predicate<A>) => pipe(fa, filter(predicate)),\n    filterMap: (fa, f) => pipe(fa, filterMap(f)),\n    partition: <A>(fa: TaskEither<E, A>, predicate: Predicate<A>) => pipe(fa, partition(predicate)),\n    partitionMap: (fa, f) => pipe(fa, partitionMap(f))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.1.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Filterable\").Filterable2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 595,
        "to": 614
      }
    }
  },
  {
    "name": "taskify",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\n/**\n * Convert a node style callback function to one returning a `TaskEither`\n *\n * **Note**. If the function `f` admits multiple overloadings, `taskify` will pick last one. If you want a different\n * behaviour, add an explicit type annotation\n *\n * ```ts\n * // readFile admits multiple overloadings\n *\n * // const readFile: (a: string) => TaskEither<NodeJS.ErrnoException, Buffer>\n * const readFile = taskify(fs.readFile)\n *\n * const readFile2: (filename: string, encoding: string) => TaskEither<NodeJS.ErrnoException, Buffer> = taskify(\n *   fs.readFile\n * )\n * ```\n *\n * @example\n * import { taskify } from 'fp-ts/TaskEither'\n * import * as fs from 'fs'\n *\n * // const stat: (a: string | Buffer) => TaskEither<NodeJS.ErrnoException, fs.Stats>\n * const stat = taskify(fs.stat)\n * assert.strictEqual(stat.length, 0)\n *\n * @since 2.0.0\n */\nexport function taskify<L, R>(f: (cb: (e: L | null | undefined, r?: R) => void) => void): () => TaskEither<L, R>",
    "docs": "/**\n * Convert a node style callback function to one returning a `TaskEither`\n *\n * **Note**. If the function `f` admits multiple overloadings, `taskify` will pick last one. If you want a different\n * behaviour, add an explicit type annotation\n *\n * ```ts\n * // readFile admits multiple overloadings\n *\n * // const readFile: (a: string) => TaskEither<NodeJS.ErrnoException, Buffer>\n * const readFile = taskify(fs.readFile)\n *\n * const readFile2: (filename: string, encoding: string) => TaskEither<NodeJS.ErrnoException, Buffer> = taskify(\n *   fs.readFile\n * )\n * ```\n *\n * @example\n * import { taskify } from 'fp-ts/TaskEither'\n * import * as fs from 'fs'\n *\n * // const stat: (a: string | Buffer) => TaskEither<NodeJS.ErrnoException, fs.Stats>\n * const stat = taskify(fs.stat)\n * assert.strictEqual(stat.length, 0)\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1012,
        "to": 1012
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, L, R>(\n  f: (a: A, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1013,
        "to": 1015
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, L, R>(\n  f: (a: A, b: B, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1016,
        "to": 1018
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, L, R>(\n  f: (a: A, b: B, c: C, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1019,
        "to": 1021
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, D, L, R>(\n  f: (a: A, b: B, c: C, d: D, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C, d: D) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1022,
        "to": 1024
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<A, B, C, D, E, L, R>(\n  f: (a: A, b: B, c: C, d: D, e: E, cb: (e: L | null | undefined, r?: R) => void) => void\n): (a: A, b: B, c: C, d: D, e: E) => TaskEither<L, R>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B, c: C, d: D, e: E, cb: (e: L, r?: R) => void) => void"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, b: B, c: C, d: D, e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1025,
        "to": 1027
      }
    }
  },
  {
    "name": "taskify",
    "text": "\nexport function taskify<L, R>(f: Function): () => TaskEither<L, R> {\n  return function () {\n    const args = Array.prototype.slice.call(arguments)\n    return () =>\n      new Promise((resolve) => {\n        const cbResolver = (e: L, r: R) => (e != null ? resolve(E.left(e)) : resolve(E.right(r)))\n        f.apply(null, args.concat(cbResolver))\n      })\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "Function"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<L, R>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1028,
        "to": 1037
      }
    }
  },
  {
    "name": "getTaskValidation",
    "text": "\n\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation<E>(\n  SE: Semigroup<E>\n): Monad2C<URI, E> & Bifunctor2<URI> & Alt2C<URI, E> & MonadTask2C<URI, E> & MonadThrow2C<URI, E> {\n  const applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE)\n  const altTaskValidation = getAltTaskValidation(SE)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: applicativeTaskValidation.ap,\n    of,\n    chain: _chain,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: altTaskValidation.alt,\n    fromIO,\n    fromTask,\n    throwError\n  }\n}",
    "docs": "/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category instances\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Bifunctor\").Bifunctor2<\"TaskEither\"> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Alt\").Alt2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask2C<\"TaskEither\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1285,
        "to": 1304
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch = <E, A>(f: Lazy<Promise<A>>, onRejected: (reason: unknown) => E): TaskEither<E, A> => () =>\n  f().then(E.right, (reason) => E.left(onRejected(reason)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<Promise<A>>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 258,
        "to": 259
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "const tryCatchK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Promise<B>,\n  onRejected: (reason: unknown) => E\n): ((...a: A) => TaskEither<E, B>) => (...a) => tryCatch(() => f(...a), onRejected)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => Promise<B>"
          }
        },
        {
          "name": "onRejected",
          "type": {
            "__tag": "Other",
            "values": "(reason: unknown) => E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 267,
        "to": 270
      }
    }
  },
  {
    "name": "fromIOEitherK",
    "text": "const fromIOEitherK = <E, A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => IOEither<E, B>\n): ((...a: A) => TaskEither<E, B>) => flow(f, fromIOEither)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 331,
        "to": 333
      }
    }
  },
  {
    "name": "chainIOEitherKW",
    "text": "const chainIOEitherKW: <E2, A, B>(\n  f: (a: A) => IOEither<E2, B>\n) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B> = (f) => chainW(fromIOEitherK(f))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IOEither\").IOEither<E2, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E1>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E1, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E2 | E1, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 341,
        "to": 343
      }
    }
  },
  {
    "name": "getCompactable",
    "text": "const getCompactable = <E>(M: Monoid<E>): Compactable2C<URI, E> => {\n  const C = E.getCompactable(M)\n  return {\n    URI,\n    _E: undefined as any,\n    compact: compact_(T.Functor, C),\n    separate: separate_(T.Functor, C, E.Functor)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Compactable\").Compactable2C<\"TaskEither\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 581,
        "to": 589
      }
    }
  },
  {
    "name": "bracket",
    "text": "const bracket = <E, A, B>(\n  acquire: TaskEither<E, A>,\n  use: (a: A) => TaskEither<E, B>,\n  release: (a: A, e: Either<E, B>) => TaskEither<E, void>\n): TaskEither<E, B> =>\n  pipe(\n    acquire,\n    chain((a) =>\n      pipe(\n        use(a),\n        T.chain((e) =>\n          pipe(\n            release(a, e),\n            chain(() => T.of(e))\n          )\n        )\n      )\n    )\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "acquire",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>"
          }
        },
        {
          "name": "use",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        },
        {
          "name": "release",
          "type": {
            "__tag": "Other",
            "values": "(a: A, e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Either\").Either<E, B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, void>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1047,
        "to": 1065
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, B, E>(\n  f: (index: number, a: A) => TaskEither<E, B>\n): ((as: ReadonlyArray<A>) => TaskEither<E, ReadonlyArray<B>>) =>\n  flow(T.traverseArrayWithIndex(f), T.map(E.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1132,
        "to": 1135
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray = <A, B, E>(\n  f: (a: A) => TaskEither<E, B>\n): ((as: ReadonlyArray<A>) => TaskEither<E, ReadonlyArray<B>>) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1142,
        "to": 1144
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <A, B, E>(f: (index: number, a: A) => TaskEither<E, B>) => (\n  as: ReadonlyArray<A>\n): TaskEither<E, ReadonlyArray<B>> => () =>\n  as.reduce<Promise<Either<E, Array<B>>>>(\n    (acc, a, i) =>\n      acc.then((ebs) =>\n        E.isLeft(ebs)\n          ? acc\n          : f(i, a)().then((eb) => {\n              if (E.isLeft(eb)) {\n                return eb\n              }\n              ebs.right.push(eb.right)\n              return ebs\n            })\n      ),\n    Promise.resolve(E.right([]))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1160,
        "to": 1177
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray = <A, B, E>(\n  f: (a: A) => TaskEither<E, B>\n): ((as: ReadonlyArray<A>) => TaskEither<E, ReadonlyArray<B>>) => traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1184,
        "to": 1186
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <E, A>(S: Semigroup<A>): Semigroup<TaskEither<E, A>> =>\n  getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskEither\").TaskEither<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskEither.ts",
      "lines": {
        "from": 1275,
        "to": 1276
      }
    }
  },
  {
    "name": "fromIO",
    "text": "const fromIO: FromIO1<URI>['fromIO'] = (ma) => fromTask(T.fromIO(ma))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ma",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/IO\").IO<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 90,
        "to": 90
      }
    }
  },
  {
    "name": "tryCatch",
    "text": "const tryCatch = <A>(f: Lazy<Promise<A>>): TaskOption<A> => () =>\n  f().then(\n    (a) => O.some(a),\n    () => O.none\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<Promise<A>>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 196,
        "to": 200
      }
    }
  },
  {
    "name": "tryCatchK",
    "text": "const tryCatchK = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => Promise<B>\n): ((...a: A) => TaskOption<B>) => (...a) => tryCatch(() => f(...a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(...a: A) => Promise<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(...a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 208,
        "to": 210
      }
    }
  },
  {
    "name": "traverseArrayWithIndex",
    "text": "const traverseArrayWithIndex = <A, B>(\n  f: (index: number, a: A) => TaskOption<B>\n): ((as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>>) => flow(T.traverseArrayWithIndex(f), T.map(O.sequenceArray))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 747,
        "to": 749
      }
    }
  },
  {
    "name": "traverseArray",
    "text": "const traverseArray: <A, B>(\n  f: (a: A) => TaskOption<B>\n) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>> = (f) => traverseArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 756,
        "to": 758
      }
    }
  },
  {
    "name": "traverseSeqArrayWithIndex",
    "text": "const traverseSeqArrayWithIndex = <A, B>(f: (index: number, a: A) => TaskOption<B>) => (\n  as: ReadonlyArray<A>\n): TaskOption<ReadonlyArray<B>> => () =>\n  as.reduce<Promise<Option<Array<B>>>>(\n    (acc, a, i) =>\n      acc.then((obs) =>\n        O.isNone(obs)\n          ? acc\n          : f(i, a)().then((ob) => {\n              if (O.isNone(ob)) {\n                return ob\n              }\n              obs.value.push(ob.value)\n              return obs\n            })\n      ),\n    Promise.resolve(O.some([]))\n  )",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(index: number, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 774,
        "to": 791
      }
    }
  },
  {
    "name": "traverseSeqArray",
    "text": "const traverseSeqArray: <A, B>(\n  f: (a: A) => TaskOption<B>\n) => (as: ReadonlyArray<A>) => TaskOption<ReadonlyArray<B>> = (f) => traverseSeqArrayWithIndex((_, a) => f(a))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(as: readonly A[]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskOption\").TaskOption<readonly B[]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskOption.ts",
      "lines": {
        "from": 798,
        "to": 800
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicative<E>(A: Apply1<T.URI>, S: Semigroup<E>): Applicative2C<URI, E> {\n  const { ap } = getApply(A, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap,\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<\"Task\">"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"TaskThese\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 294,
        "to": 303
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport function getChain<E>(S: Semigroup<E>): Chain2C<URI, E> {\n  const A = getApply(T.ApplicativePar, S)\n  const chain = TT.chain(T.Monad, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    chain: (ma, f) => pipe(ma, chain(f))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"TaskThese\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 309,
        "to": 319
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.4.0\n */\nexport function getMonad<E>(S: Semigroup<E>): Monad2C<URI, E> & MonadTask2C<URI, E> {\n  const A = getApplicative(T.ApplicativePar, S)\n  const C = getChain(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    of,\n    chain: C.chain,\n    fromIO,\n    fromTask\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"TaskThese\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadTask\").MonadTask2C<\"TaskThese\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 325,
        "to": 338
      }
    }
  },
  {
    "name": "getApply",
    "text": "const getApply = <E>(A: Apply1<T.URI>, S: Semigroup<E>): Apply2C<URI, E> => {\n  const ap = TT.ap(A, S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => pipe(fab, ap(fa))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "A",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<\"Task\">"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"TaskThese\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 280,
        "to": 288
      }
    }
  },
  {
    "name": "toTuple",
    "text": "const toTuple = <E, A>(e: E, a: A): ((fa: TaskThese<E, A>) => Task<[E, A]>) =>\n  toTuple2(\n    () => e,\n    () => a\n  ) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskThese\").TaskThese<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Task\").Task<[E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 492,
        "to": 496
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "const getSemigroup = <E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<TaskThese<E, A>> =>\n  getApplySemigroup(T.ApplySeq)(TH.getSemigroup(SE, SA))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TaskThese\").TaskThese<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TaskThese.ts",
      "lines": {
        "from": 519,
        "to": 520
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function left<E = never, A = never>(left: E): These<E, A> {\n  return { _tag: 'Left', left }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 66,
        "to": 68
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function right<E = never, A = never>(right: A): These<E, A> {\n  return { _tag: 'Right', right }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 74,
        "to": 76
      }
    }
  },
  {
    "name": "both",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function both<E, A>(left: E, right: A): These<E, A> {\n  return { _tag: 'Both', left, right }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "left",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "right",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<E, A>(SE: Show<E>, SA: Show<A>): Show<These<E, A>> {\n  return {\n    show: match(\n      (l) => `left(${SE.show(l)})`,\n      (a) => `right(${SA.show(a)})`,\n      (l, a) => `both(${SE.show(l)}, ${SA.show(a)})`\n    )\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 141,
        "to": 149
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<E, A>(EE: Eq<E>, EA: Eq<A>): Eq<These<E, A>> {\n  return fromEquals((x, y) =>\n    isLeft(x)\n      ? isLeft(y) && EE.equals(x.left, y.left)\n      : isRight(x)\n      ? isRight(y) && EA.equals(x.right, y.right)\n      : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right)\n  )\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "EE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<E>"
          }
        },
        {
          "name": "EA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 155,
        "to": 163
      }
    }
  },
  {
    "name": "getSemigroup",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getSemigroup<E, A>(SE: Semigroup<E>, SA: Semigroup<A>): Semigroup<These<E, A>> {\n  return {\n    concat: (x, y) =>\n      isLeft(x)\n        ? isLeft(y)\n          ? left(SE.concat(x.left, y.left))\n          : isRight(y)\n          ? both(x.left, y.right)\n          : both(SE.concat(x.left, y.left), y.right)\n        : isRight(x)\n        ? isLeft(y)\n          ? both(y.left, x.right)\n          : isRight(y)\n          ? right(SA.concat(x.right, y.right))\n          : both(y.left, SA.concat(x.right, y.right))\n        : isLeft(y)\n        ? both(SE.concat(x.left, y.left), x.right)\n        : isRight(y)\n        ? both(x.left, SA.concat(x.right, y.right))\n        : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right))\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "SE",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "SA",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 169,
        "to": 190
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.7.0\n */\nexport function getApplicative<E>(S: Semigroup<E>): Applicative2C<URI, E> {\n  const A = getApply(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    of\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.7.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"These\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 224,
        "to": 233
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport function getChain<E>(S: Semigroup<E>): Chain2C<URI, E> {\n  const A = getApply(S)\n\n  const chain = <A, B>(ma: These<E, A>, f: (a: A) => These<E, B>): These<E, B> => {\n    if (isLeft(ma)) {\n      return ma\n    }\n    if (isRight(ma)) {\n      return f(ma.right)\n    }\n    const fb = f(ma.right)\n    return isLeft(fb)\n      ? left(S.concat(ma.left, fb.left))\n      : isRight(fb)\n      ? both(ma.left, fb.right)\n      : both(S.concat(ma.left, fb.left), fb.right)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    chain\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"These\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 239,
        "to": 264
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonad<E>(S: Semigroup<E>): Monad2C<URI, E> & MonadThrow2C<URI, E> {\n  const C = getChain(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    of,\n    ap: C.ap,\n    chain: C.chain,\n    throwError: left\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"These\", E> & import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/MonadThrow\").MonadThrow2C<\"These\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 270,
        "to": 281
      }
    }
  },
  {
    "name": "getLeft",
    "text": "\n\n/**\n * Returns an `E` value if possible\n *\n * @example\n * import { getLeft, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getLeft<E, A>(fa: These<E, A>): Option<E> {\n  return isLeft(fa) ? some(fa.left) : isRight(fa) ? none : some(fa.left)\n}",
    "docs": "/**\n * Returns an `E` value if possible\n *\n * @example\n * import { getLeft, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 297,
        "to": 299
      }
    }
  },
  {
    "name": "getRight",
    "text": "\n\n/**\n * Returns an `A` value if possible\n *\n * @example\n * import { getRight, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRight(left('a')), none)\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(both('a', 1)), some(1))\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getRight<E, A>(fa: These<E, A>): Option<A> {\n  return isLeft(fa) ? none : isRight(fa) ? some(fa.right) : some(fa.right)\n}",
    "docs": "/**\n * Returns an `A` value if possible\n *\n * @example\n * import { getRight, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRight(left('a')), none)\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(both('a', 1)), some(1))\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 315,
        "to": 317
      }
    }
  },
  {
    "name": "isLeft",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isLeft<E, A>(fa: These<E, A>): fa is Left<E> {\n  return fa._tag === 'Left'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Left`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 325,
        "to": 327
      }
    }
  },
  {
    "name": "isRight",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isRight<E, A>(fa: These<E, A>): fa is Right<A> {\n  return fa._tag === 'Right'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Right`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 335,
        "to": 337
      }
    }
  },
  {
    "name": "isBoth",
    "text": "\n\n/**\n * Returns `true` if the these is an instance of `Both`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */\nexport function isBoth<E, A>(fa: These<E, A>): fa is Both<E, A> {\n  return fa._tag === 'Both'\n}",
    "docs": "/**\n * Returns `true` if the these is an instance of `Both`, `false` otherwise\n *\n * @category guards\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "BoolT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 345,
        "to": 347
      }
    }
  },
  {
    "name": "leftOrBoth",
    "text": "\n\n// TODO: make lazy in v3\n/**\n * @example\n * import { leftOrBoth, left, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))\n * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function leftOrBoth<E>(e: E): <A>(ma: Option<A>) => These<E, A> {\n  return (ma) => (isNone(ma) ? left(e) : both(e, ma.value))\n}",
    "docs": "/**\n * @example\n * import { leftOrBoth, left, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))\n * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 361,
        "to": 363
      }
    }
  },
  {
    "name": "rightOrBoth",
    "text": "\n\n// TODO: make lazy in v3\n/**\n * @example\n * import { rightOrBoth, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))\n * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function rightOrBoth<A>(a: A): <E>(me: Option<E>) => These<E, A> {\n  return (me) => (isNone(me) ? right(a) : both(me.value, a))\n}",
    "docs": "/**\n * @example\n * import { rightOrBoth, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))\n * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(me: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 377,
        "to": 379
      }
    }
  },
  {
    "name": "getLeftOnly",
    "text": "\n\n/**\n * Returns the `E` value if and only if the value is constructed with `Left`\n *\n * @example\n * import { getLeftOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))\n * assert.deepStrictEqual(getLeftOnly(right(1)), none)\n * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getLeftOnly<E, A>(fa: These<E, A>): Option<E> {\n  return isLeft(fa) ? some(fa.left) : none\n}",
    "docs": "/**\n * Returns the `E` value if and only if the value is constructed with `Left`\n *\n * @example\n * import { getLeftOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))\n * assert.deepStrictEqual(getLeftOnly(right(1)), none)\n * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 395,
        "to": 397
      }
    }
  },
  {
    "name": "getRightOnly",
    "text": "\n\n/**\n * Returns the `A` value if and only if the value is constructed with `Right`\n *\n * @example\n * import { getRightOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRightOnly(left('a')), none)\n * assert.deepStrictEqual(getRightOnly(right(1)), some(1))\n * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function getRightOnly<E, A>(fa: These<E, A>): Option<A> {\n  return isRight(fa) ? some(fa.right) : none\n}",
    "docs": "/**\n * Returns the `A` value if and only if the value is constructed with `Right`\n *\n * @example\n * import { getRightOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRightOnly(left('a')), none)\n * assert.deepStrictEqual(getRightOnly(right(1)), some(1))\n * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)\n *\n * @category destructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 413,
        "to": 415
      }
    }
  },
  {
    "name": "fromOptions",
    "text": "\n\n/**\n * Takes a pair of `Option`s and attempts to create a `These` from them\n *\n * @example\n * import { fromOptions, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromOptions(none, none), none)\n * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))\n * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))\n * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromOptions<E, A>(fe: Option<E>, fa: Option<A>): Option<These<E, A>> {\n  return isNone(fe)\n    ? isNone(fa)\n      ? none\n      : some(right(fa.value))\n    : isNone(fa)\n    ? some(left(fe.value))\n    : some(both(fe.value, fa.value))\n}",
    "docs": "/**\n * Takes a pair of `Option`s and attempts to create a `These` from them\n *\n * @example\n * import { fromOptions, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromOptions(none, none), none)\n * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))\n * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))\n * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "fe",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<E>"
          }
        },
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Option\").Option<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 432,
        "to": 440
      }
    }
  },
  {
    "name": "matchW",
    "text": "const matchW = <E, B, A, C, D>(onLeft: (e: E) => B, onRight: (a: A) => C, onBoth: (e: E, a: A) => D) => (\n  fa: These<E, A>\n): B | C | D => {\n  switch (fa._tag) {\n    case 'Left':\n      return onLeft(fa.left)\n    case 'Right':\n      return onRight(fa.right)\n    case 'Both':\n      return onBoth(fa.left, fa.right)\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "onLeft",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => B"
          }
        },
        {
          "name": "onRight",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => C"
          }
        },
        {
          "name": "onBoth",
          "type": {
            "__tag": "Other",
            "values": "(e: E, a: A) => D"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B | C | D"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 92,
        "to": 103
      }
    }
  },
  {
    "name": "getApply",
    "text": "const getApply = <E>(S: Semigroup<E>): Apply2C<URI, E> => ({\n  URI,\n  _E: undefined as any,\n  map: _map,\n  ap: (fab, fa) =>\n    isLeft(fab)\n      ? isLeft(fa)\n        ? left(S.concat(fab.left, fa.left))\n        : isRight(fa)\n        ? left(fab.left)\n        : left(S.concat(fab.left, fa.left))\n      : isRight(fab)\n      ? isLeft(fa)\n        ? left(fa.left)\n        : isRight(fa)\n        ? right(fab.right(fa.right))\n        : both(fa.left, fab.right(fa.right))\n      : isLeft(fa)\n      ? left(S.concat(fab.left, fa.left))\n      : isRight(fa)\n      ? both(fab.left, fab.right(fa.right))\n      : both(S.concat(fab.left, fa.left), fab.right(fa.right))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"These\", E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 196,
        "to": 218
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: These<E, A>) => These<G, B> = (f, g) => (fa) =>\n  isLeft(fa) ? left(f(fa.left)) : isRight(fa) ? right(g(fa.right)) : both(f(fa.left), g(fa.right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 478,
        "to": 479
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "const mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: These<E, A>) => These<G, A> = (f) => (fa) =>\n  isLeft(fa) ? left(f(fa.left)) : isBoth(fa) ? both(f(fa.left), fa.right) : fa",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 487,
        "to": 488
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: These<E, A>) => These<E, B> = (f) => (fa) =>\n  isLeft(fa) ? fa : isRight(fa) ? right(f(fa.right)) : both(fa.left, f(fa.right))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 497,
        "to": 498
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => <E>(fa: These<E, A>) => B = (b, f) => (fa) =>\n  isLeft(fa) ? b : isRight(fa) ? f(b, fa.right) : f(b, fa.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 504,
        "to": 505
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => <E>(fa: These<E, A>) => M = (M) => (f) => (fa) =>\n  isLeft(fa) ? M.empty : isRight(fa) ? f(fa.right) : f(fa.right)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 511,
        "to": 512
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => <E>(fa: These<E, A>) => B = (b, f) => (fa) =>\n  isLeft(fa) ? b : isRight(fa) ? f(fa.right, b) : f(fa.right, b)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 518,
        "to": 519
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <E>(ta: These<E, A>) => HKT<F, These<E, B>>) => (f) => (ta) =>\n  isLeft(ta) ? F.of(ta) : isRight(ta) ? F.map(f(ta.right), right) : F.map(f(ta.right), (b) => both(ta.left, b))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 524,
        "to": 527
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <E, A>(\n  ta: These<E, HKT<F, A>>\n): HKT<F, These<E, A>> => {\n  return isLeft(ta) ? F.of(ta) : isRight(ta) ? F.map(ta.right, right) : F.map(ta.right, (b) => both(ta.left, b))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 532,
        "to": 536
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "const toTuple2 = <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: These<E, A>): readonly [E, A] =>\n  isLeft(fa) ? [fa.left, a()] : isRight(fa) ? [e(), fa.right] : [fa.left, fa.right]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => readonly [E, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 668,
        "to": 669
      }
    }
  },
  {
    "name": "toTuple",
    "text": "const toTuple = <E, A>(e: E, a: A): ((fa: These<E, A>) => [E, A]) =>\n  toTuple2(\n    () => e,\n    () => a\n  ) as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "e",
          "type": {
            "__tag": "Other",
            "values": "E"
          }
        },
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>) => [E, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/These.ts",
      "lines": {
        "from": 681,
        "to": 685
      }
    }
  },
  {
    "name": "right",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function right<F extends URIS3>(F: Pointed3<F>): <A, R, FE, E = never>(a: A) => Kind3<F, R, FE, These<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, FE, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 19,
        "to": 19
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS3, FE>(F: Pointed3C<F, FE>): <A, R, E = never>(a: A) => Kind3<F, R, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 20,
        "to": 20
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS2>(F: Pointed2<F>): <A, FE, E = never>(a: A) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, FE, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 21,
        "to": 21
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS2, FE>(F: Pointed2C<F, FE>): <A, E = never>(a: A) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 22,
        "to": 22
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F extends URIS>(F: Pointed1<F>): <A, E = never>(a: A) => Kind<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 23,
        "to": 23
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 24,
        "to": 24
      }
    }
  },
  {
    "name": "right",
    "text": "\nexport function right<F>(F: Pointed<F>): <A, E = never>(a: A) => HKT<F, These<E, A>> {\n  return flow(T.right, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 25,
        "to": 27
      }
    }
  },
  {
    "name": "left",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function left<F extends URIS3>(F: Pointed3<F>): <E, R, FE, A = never>(e: E) => Kind3<F, R, FE, These<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, FE, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 32,
        "to": 32
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS3, FE>(F: Pointed3C<F, FE>): <E, R, A = never>(e: E) => Kind3<F, R, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 33,
        "to": 33
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS2>(F: Pointed2<F>): <E, FE, A = never>(e: E) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, FE, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 34,
        "to": 34
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS2, FE>(F: Pointed2C<F, FE>): <E, A = never>(e: E) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 35,
        "to": 35
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F extends URIS>(F: Pointed1<F>): <E, A = never>(e: E) => Kind<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 36,
        "to": 36
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 37,
        "to": 37
      }
    }
  },
  {
    "name": "left",
    "text": "\nexport function left<F>(F: Pointed<F>): <E, A = never>(e: E) => HKT<F, These<E, A>> {\n  return flow(T.left, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 38,
        "to": 40
      }
    }
  },
  {
    "name": "both",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function both<F extends URIS3>(F: Pointed3<F>): <E, A, R, FE>(e: E, a: A) => Kind3<F, R, FE, These<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, R, FE>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 45,
        "to": 45
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F extends URIS3, FE>(F: Pointed3C<F, FE>): <E, A, R>(e: E, a: A) => Kind3<F, R, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, R>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 46,
        "to": 46
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F extends URIS2>(F: Pointed2<F>): <E, A, FE>(e: E, a: A) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, FE>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 47,
        "to": 47
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F extends URIS2, FE>(F: Pointed2C<F, FE>): <E, A>(e: E, a: A) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 48,
        "to": 48
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F extends URIS>(F: Pointed1<F>): <E, A>(e: E, a: A) => Kind<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 49,
        "to": 49
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F>(F: Pointed<F>): <E, A = never>(e: E, a: A) => HKT<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 50,
        "to": 50
      }
    }
  },
  {
    "name": "both",
    "text": "\nexport function both<F>(F: Pointed<F>): <E, A = never>(e: E, a: A) => HKT<F, These<E, A>> {\n  return flow(T.both, F.of)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 51,
        "to": 53
      }
    }
  },
  {
    "name": "rightF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function rightF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, These<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 58,
        "to": 60
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, A, E = never>(fa: Kind3<F, R, FE, A>) => Kind3<F, R, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 61,
        "to": 63
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS2>(\n  F: Functor2<F>\n): <FE, A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 64,
        "to": 66
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <A, E = never>(fa: Kind2<F, FE, A>) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 67,
        "to": 69
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F extends URIS>(F: Functor1<F>): <A, E = never>(fa: Kind<F, A>) => Kind<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 70,
        "to": 70
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 71,
        "to": 71
      }
    }
  },
  {
    "name": "rightF",
    "text": "\nexport function rightF<F>(F: Functor<F>): <A, E = never>(fa: HKT<F, A>) => HKT<F, These<E, A>> {\n  return (fa) => F.map(fa, T.right)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E = never>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 72,
        "to": 74
      }
    }
  },
  {
    "name": "leftF",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function leftF<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, These<E, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 79,
        "to": 81
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, E, A = never>(fe: Kind3<F, R, FE, E>) => Kind3<F, R, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 82,
        "to": 84
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS2>(\n  F: Functor2<F>\n): <FE, E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 85,
        "to": 87
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 88,
        "to": 90
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 91,
        "to": 91
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, These<E, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "leftF",
    "text": "\nexport function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, These<E, A>> {\n  return (fe) => F.map(fe, T.left)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A = never>(fe: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, E>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 93,
        "to": 95
      }
    }
  },
  {
    "name": "map",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function map<F extends URIS3>(\n  F: Functor3<F>\n): <A, B>(f: (a: A) => B) => <R, FE, E>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, FE, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 100,
        "to": 102
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <A, B>(f: (a: A) => B) => <R, E>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <R, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 103,
        "to": 105
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2>(\n  F: Functor2<F>\n): <A, B>(f: (a: A) => B) => <FE, E>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <FE, E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 106,
        "to": 108
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 109,
        "to": 111
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F extends URIS>(\n  F: Functor1<F>\n): <A, B>(f: (a: A) => B) => <E>(fa: Kind<F, These<E, A>>) => Kind<F, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 112,
        "to": 114
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, These<E, A>>) => HKT<F, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 115,
        "to": 115
      }
    }
  },
  {
    "name": "map",
    "text": "\nexport function map<F>(F: Functor<F>): <A, B>(f: (a: A) => B) => <E>(fa: HKT<F, These<E, A>>) => HKT<F, These<E, B>> {\n  return map_(F, T.Functor)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => B) => <E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 116,
        "to": 118
      }
    }
  },
  {
    "name": "ap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function ap<F extends URIS3, E>(\n  F: Apply3<F>,\n  S: Semigroup<E>\n): <R, FE, A>(\n  fa: Kind3<F, R, FE, These<E, A>>\n) => <B>(fab: Kind3<F, R, FE, These<E, (a: A) => B>>) => Kind3<F, R, FE, These<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 123,
        "to": 128
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS3, FE, E>(\n  F: Apply3C<F, FE>,\n  S: Semigroup<E>\n): <R, A>(\n  fa: Kind3<F, R, FE, These<E, A>>\n) => <B>(fab: Kind3<F, R, FE, These<E, (a: A) => B>>) => Kind3<F, R, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply3C<F, FE>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 129,
        "to": 134
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2, E>(\n  F: Apply2<F>,\n  S: Semigroup<E>\n): <FE, A>(fa: Kind2<F, FE, These<E, A>>) => <B>(fab: Kind2<F, FE, These<E, (a: A) => B>>) => Kind2<F, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 135,
        "to": 138
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS2, FE, E>(\n  F: Apply2C<F, FE>,\n  S: Semigroup<E>\n): <A>(fa: Kind2<F, FE, These<E, A>>) => <B>(fab: Kind2<F, FE, These<E, (a: A) => B>>) => Kind2<F, FE, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<F, FE>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 139,
        "to": 142
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F extends URIS, E>(\n  F: Apply1<F>,\n  S: Semigroup<E>\n): <A>(fa: Kind<F, These<E, A>>) => <B>(fab: Kind<F, These<E, (a: A) => B>>) => Kind<F, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 143,
        "to": 146
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, E>(\n  F: Apply<F>,\n  S: Semigroup<E>\n): <A>(fa: HKT<F, These<E, A>>) => <B>(fab: HKT<F, These<E, (a: A) => B>>) => HKT<F, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 147,
        "to": 150
      }
    }
  },
  {
    "name": "ap",
    "text": "\nexport function ap<F, E>(\n  F: Apply<F>,\n  S: Semigroup<E>\n): <A>(fa: HKT<F, These<E, A>>) => <B>(fab: HKT<F, These<E, (a: A) => B>>) => HKT<F, These<E, B>> {\n  return ap_(F, T.getApply(S))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply<F>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => <B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, (a: A) => B>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 151,
        "to": 156
      }
    }
  },
  {
    "name": "chain",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function chain<M extends URIS3, E>(\n  M: Monad3<M>,\n  S: Semigroup<E>\n): <A, R, ME, B>(\n  f: (a: A) => Kind3<M, R, ME, These<E, B>>\n) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, These<E, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, ME, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 161,
        "to": 166
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS3, ME, E>(\n  M: Monad3C<M, ME>,\n  S: Semigroup<E>\n): <A, R, B>(\n  f: (a: A) => Kind3<M, R, ME, These<E, B>>\n) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, ME>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, R, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 167,
        "to": 172
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, E>(\n  M: Monad2<M>,\n  S: Semigroup<E>\n): <A, ME, B>(f: (a: A) => Kind2<M, ME, These<E, B>>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, ME, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 173,
        "to": 176
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS2, ME, E>(\n  M: Monad2C<M, ME>,\n  S: Semigroup<E>\n): <A, B>(f: (a: A) => Kind2<M, ME, These<E, B>>) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, ME>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 177,
        "to": 180
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M extends URIS, E>(\n  M: Monad1<M>,\n  S: Semigroup<E>\n): <A, B>(f: (a: A) => Kind<M, These<E, B>>) => (ma: Kind<M, These<E, A>>) => Kind<M, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 181,
        "to": 184
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M, E>(\n  M: Monad<M>,\n  S: Semigroup<E>\n): <A, B>(f: (a: A) => HKT<M, These<E, B>>) => (ma: HKT<M, These<E, A>>) => HKT<M, These<E, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 185,
        "to": 188
      }
    }
  },
  {
    "name": "chain",
    "text": "\nexport function chain<M, E>(\n  M: Monad<M>,\n  S: Semigroup<E>\n): <A, B>(f: (a: A) => HKT<M, These<E, B>>) => (ma: HKT<M, These<E, A>>) => HKT<M, These<E, B>> {\n  const _left = left(M)\n  return (f) => (ma) =>\n    M.chain(\n      ma,\n      T.match(_left, f, (e1, a) =>\n        M.map(\n          f(a),\n          T.match(\n            (e2) => T.left(S.concat(e1, e2)),\n            (b) => T.both(e1, b),\n            (e2, b) => T.both(S.concat(e1, e2), b)\n          )\n        )\n      )\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        },
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 189,
        "to": 208
      }
    }
  },
  {
    "name": "bimap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function bimap<F extends URIS3>(\n  F: Functor3<F>\n): <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <R, FE>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, B>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R, FE>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 213,
        "to": 218
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, G, A, B>(\n  f: (e: E) => G,\n  g: (a: A) => B\n) => <R>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <R>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 219,
        "to": 224
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS2>(\n  F: Functor2<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => <FE>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 225,
        "to": 227
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 228,
        "to": 230
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F extends URIS>(\n  F: Functor1<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: Kind<F, These<E, A>>) => Kind<F, These<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 231,
        "to": 233
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F>(\n  F: Functor<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT<F, These<E, A>>) => HKT<F, These<G, B>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 234,
        "to": 236
      }
    }
  },
  {
    "name": "bimap",
    "text": "\nexport function bimap<F>(\n  F: Functor<F>\n): <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: HKT<F, These<E, A>>) => HKT<F, These<G, B>> {\n  return (f, g) => (fea) => F.map(fea, T.bimap(f, g))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 237,
        "to": 241
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function mapLeft<F extends URIS3>(\n  F: Functor3<F>\n): <E, G>(f: (e: E) => G) => <R, FE, A>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, A>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <R, FE, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 246,
        "to": 248
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, G>(f: (e: E) => G) => <R, A>(fea: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <R, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 249,
        "to": 251
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS2>(\n  F: Functor2<F>\n): <E, G>(f: (e: E) => G) => <FE, A>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <FE, A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 252,
        "to": 254
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, G>(f: (e: E) => G) => <A>(fea: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 255,
        "to": 257
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F extends URIS>(\n  F: Functor1<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: Kind<F, These<E, A>>) => Kind<F, These<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 258,
        "to": 260
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F>(\n  F: Functor<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: HKT<F, These<E, A>>) => HKT<F, These<G, A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 261,
        "to": 263
      }
    }
  },
  {
    "name": "mapLeft",
    "text": "\nexport function mapLeft<F>(\n  F: Functor<F>\n): <E, G>(f: (e: E) => G) => <A>(fea: HKT<F, These<E, A>>) => HKT<F, These<G, A>> {\n  return (f) => (fea) => F.map(fea, T.mapLeft(f))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, G>(f: (e: E) => G) => <A>(fea: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<G, A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 264,
        "to": 268
      }
    }
  },
  {
    "name": "match",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function match<F extends URIS3>(\n  F: Functor3<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => <S, R>(ma: Kind3<F, S, R, These<E, A>>) => Kind3<F, S, R, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <S, R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, S, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, S, R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 273,
        "to": 279
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS3, R>(\n  F: Functor3C<F, R>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => <S>(ma: Kind3<F, S, R, These<E, A>>) => Kind3<F, S, R, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, R>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <S>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, S, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, S, R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 280,
        "to": 286
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS2>(\n  F: Functor2<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => <R>(ma: Kind2<F, R, These<E, A>>) => Kind2<F, R, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => <R>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 287,
        "to": 293
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<M extends URIS2, R>(\n  F: Functor2C<M, R>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (ma: Kind2<M, R, These<E, A>>) => Kind2<M, R, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<M, R>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 294,
        "to": 300
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F extends URIS>(\n  F: Functor1<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (ma: Kind<F, These<E, A>>) => Kind<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 301,
        "to": 307
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (ma: HKT<F, These<E, A>>) => HKT<F, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 308,
        "to": 314
      }
    }
  },
  {
    "name": "match",
    "text": "\nexport function match<F>(\n  F: Functor<F>\n): <E, B, A>(\n  onLeft: (e: E) => B,\n  onRight: (a: A) => B,\n  onBoth: (e: E, a: A) => B\n) => (ma: HKT<F, These<E, A>>) => HKT<F, B> {\n  return (onLeft, onRight, onBoth) => (ma) => F.map(ma, T.match(onLeft, onRight, onBoth))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => B, onRight: (a: A) => B, onBoth: (e: E, a: A) => B) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 315,
        "to": 323
      }
    }
  },
  {
    "name": "matchE",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function matchE<M extends URIS3>(\n  M: Chain3<M>\n): <E, R, ME, B, A>(\n  onLeft: (e: E) => Kind3<M, R, ME, B>,\n  onRight: (a: A) => Kind3<M, R, ME, B>,\n  onBoth: (e: E, a: A) => Kind3<M, R, ME, B>\n) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, B>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, ME, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 328,
        "to": 334
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS3, ME>(\n  M: Chain3C<M, ME>\n): <E, R, B, A>(\n  onLeft: (e: E) => Kind3<M, R, ME, B>,\n  onRight: (a: A) => Kind3<M, R, ME, B>,\n  onBoth: (e: E, a: A) => Kind3<M, R, ME, B>\n) => (ma: Kind3<M, R, ME, These<E, A>>) => Kind3<M, R, ME, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain3C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, R, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, ME, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 335,
        "to": 341
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2>(\n  M: Chain2<M>\n): <E, ME, B, A>(\n  onLeft: (e: E) => Kind2<M, ME, B>,\n  onRight: (a: A) => Kind2<M, ME, B>,\n  onBoth: (e: E, a: A) => Kind2<M, ME, B>\n) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, ME, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 342,
        "to": 348
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS2, ME>(\n  M: Chain2C<M, ME>\n): <E, B, A>(\n  onLeft: (e: E) => Kind2<M, ME, B>,\n  onRight: (a: A) => Kind2<M, ME, B>,\n  onBoth: (e: E, a: A) => Kind2<M, ME, B>\n) => (ma: Kind2<M, ME, These<E, A>>) => Kind2<M, ME, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<M, ME>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, ME, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 349,
        "to": 355
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M extends URIS>(\n  M: Chain1<M>\n): <E, B, A>(\n  onLeft: (e: E) => Kind<M, B>,\n  onRight: (a: A) => Kind<M, B>,\n  onBoth: (e: E, a: A) => Kind<M, B>\n) => (ma: Kind<M, These<E, A>>) => Kind<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 356,
        "to": 362
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <E, B, A>(\n  onLeft: (e: E) => HKT<M, B>,\n  onRight: (a: A) => HKT<M, B>,\n  onBoth: (e: E, a: A) => HKT<M, B>\n) => (ma: HKT<M, These<E, A>>) => HKT<M, B>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 363,
        "to": 369
      }
    }
  },
  {
    "name": "matchE",
    "text": "\nexport function matchE<M>(\n  M: Chain<M>\n): <E, B, A>(\n  onLeft: (e: E) => HKT<M, B>,\n  onRight: (a: A) => HKT<M, B>,\n  onBoth: (e: E, a: A) => HKT<M, B>\n) => (ma: HKT<M, These<E, A>>) => HKT<M, B> {\n  return (onLeft, onRight, onBoth) => (ma) => M.chain(ma, T.match(onLeft, onRight, onBoth))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, B, A>(onLeft: (e: E) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onRight: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>, onBoth: (e: E, a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>) => (ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 370,
        "to": 378
      }
    }
  },
  {
    "name": "swap",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function swap<F extends URIS3>(\n  F: Functor3<F>\n): <R, FE, E, A>(ma: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<A, E>>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, FE, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 383,
        "to": 385
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <R, E, A>(ma: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, These<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 386,
        "to": 388
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS2>(\n  F: Functor2<F>\n): <FE, E, A>(ma: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<FE, E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 389,
        "to": 391
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A>(ma: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, These<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 392,
        "to": 394
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F extends URIS>(F: Functor1<F>): <E, A>(ma: Kind<F, These<E, A>>) => Kind<F, These<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 395,
        "to": 395
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F>(F: Functor<F>): <E, A>(ma: HKT<F, These<E, A>>) => HKT<F, These<A, E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 396,
        "to": 396
      }
    }
  },
  {
    "name": "swap",
    "text": "\nexport function swap<F>(F: Functor<F>): <E, A>(ma: HKT<F, These<E, A>>) => HKT<F, These<A, E>> {\n  return (ma) => F.map(ma, T.swap)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<A, E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 397,
        "to": 399
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\n\n/**\n * @since 2.10.0\n */\nexport function toTuple2<F extends URIS3>(\n  F: Functor3<F>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => <R, FE>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, readonly [E, A]>",
    "docs": "/**\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => <R, FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 404,
        "to": 406
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F extends URIS3, FE>(\n  F: Functor3C<F, FE>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => <R>(fa: Kind3<F, R, FE, These<E, A>>) => Kind3<F, R, FE, readonly [E, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor3C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => <R>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<F, R, FE, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 407,
        "to": 409
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F extends URIS2>(\n  F: Functor2<F>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => <FE>(fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, readonly [E, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => <FE>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 410,
        "to": 412
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F extends URIS2, FE>(\n  F: Functor2C<F, FE>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: Kind2<F, FE, These<E, A>>) => Kind2<F, FE, readonly [E, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor2C<F, FE>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<F, FE, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 413,
        "to": 415
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F extends URIS>(\n  F: Functor1<F>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: Kind<F, These<E, A>>) => Kind<F, readonly [E, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 416,
        "to": 418
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F>(\n  F: Functor<F>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: HKT<F, These<E, A>>) => HKT<F, readonly [E, A]>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 419,
        "to": 421
      }
    }
  },
  {
    "name": "toTuple2",
    "text": "\nexport function toTuple2<F>(\n  F: Functor<F>\n): <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: HKT<F, These<E, A>>) => HKT<F, readonly [E, A]> {\n  return (e, a) => (fa) => F.map(fa, T.toTuple2(e, a))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Functor\").Functor<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A>(e: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<E>, a: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/function\").Lazy<A>) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/These\").These<E, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, readonly [E, A]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 422,
        "to": 426
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\n\n/**\n * @since 2.4.0\n * @deprecated\n */\nexport function getTheseM<M extends URIS2>(M: Monad2<M>): TheseM2<M>",
    "docs": "/**\n * @since 2.4.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 555,
        "to": 555
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\n/** @deprecated */\nexport function getTheseM<M extends URIS>(M: Monad1<M>): TheseM1<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 557,
        "to": 557
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\n/** @deprecated */\nexport function getTheseM<M>(M: Monad<M>): TheseM<M>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 559,
        "to": 559
      }
    }
  },
  {
    "name": "getTheseM",
    "text": "\n/** @deprecated */\n/* istanbul ignore next */\nexport function getTheseM<M>(M: Monad<M>): TheseM<M> {\n  const _map = map(M)\n  const _bimap = bimap(M)\n  const _mapLeft = mapLeft(M)\n  const _fold = matchE(M)\n  const _toTuple2: <E, A>(e: Lazy<E>, a: Lazy<A>) => (fa: HKT<M, T.These<E, A>>) => HKT<M, [E, A]> = toTuple2(M) as any\n  const of = right(M)\n\n  const mapT = <E, A, B>(fa: TheseT<M, E, A>, f: (a: A) => B): TheseT<M, E, B> => pipe(fa, _map(f))\n\n  return {\n    map: mapT,\n    bimap: (fea, f, g) => pipe(fea, _bimap(f, g)),\n    mapLeft: (fea, f) => pipe(fea, _mapLeft(f)),\n    fold: (fa, onLeft, onRight, onBoth) => pipe(fa, _fold(onLeft, onRight, onBoth)),\n    swap: swap(M),\n    rightM: rightF(M),\n    leftM: leftF(M),\n    left: left(M),\n    right: right(M),\n    both: both(M),\n    toTuple: (fa, e, a) =>\n      pipe(\n        fa,\n        _toTuple2(\n          () => e,\n          () => a\n        )\n      ),\n    getMonad: (S) => {\n      const _ap = ap(M, S)\n      const _chain = chain(M, S)\n      return {\n        _E: undefined as any,\n        map: mapT,\n        of,\n        ap: (fab, fa) => pipe(fab, _ap(fa)),\n        chain: (ma, f) => pipe(ma, _chain(f))\n      }\n    }\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/TheseT\").TheseM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/TheseT.ts",
      "lines": {
        "from": 562,
        "to": 603
      }
    }
  },
  {
    "name": "tracks",
    "text": "\n\n// TODO: curry in v3\n/**\n * Extracts a value at a relative position which depends on the current value.\n *\n * @since 2.0.0\n */\nexport function tracks<P, A>(M: Monoid<P>, f: (a: A) => P): (wa: Traced<P, A>) => A {\n  return (wa) => wa(f(wa(M.empty)))\n}",
    "docs": "/**\n * Extracts a value at a relative position which depends on the current value.\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<P>"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 27,
        "to": 29
      }
    }
  },
  {
    "name": "listen",
    "text": "\n\n/**\n * Get the current position\n *\n * @since 2.0.0\n */\nexport function listen<P, A>(wa: Traced<P, A>): Traced<P, [A, P]> {\n  return (e) => [wa(e), e]\n}",
    "docs": "/**\n * Get the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, [A, P]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 36,
        "to": 38
      }
    }
  },
  {
    "name": "listens",
    "text": "\n\n/**\n * Get a value which depends on the current position\n *\n * @since 2.0.0\n */\nexport function listens<P, B>(f: (p: P) => B): <A>(wa: Traced<P, A>) => Traced<P, [A, B]> {\n  return (wa) => (e) => [wa(e), f(e)]\n}",
    "docs": "/**\n * Get a value which depends on the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, [A, B]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 45,
        "to": 47
      }
    }
  },
  {
    "name": "censor",
    "text": "\n\n/**\n * Apply a function to the current position\n *\n * @since 2.0.0\n */\nexport function censor<P>(f: (p: P) => P): <A>(wa: Traced<P, A>) => Traced<P, A> {\n  return (wa) => (e) => wa(f(e))\n}",
    "docs": "/**\n * Apply a function to the current position\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(p: P) => P"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<P, A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 54,
        "to": 56
      }
    }
  },
  {
    "name": "getComonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getComonad<P>(monoid: Monoid<P>): Comonad2C<URI, P> {\n  function extend<A, B>(wa: Traced<P, A>, f: (wa: Traced<P, A>) => B): Traced<P, B> {\n    return (p1) => f((p2) => wa(monoid.concat(p1, p2)))\n  }\n\n  function extract<A>(wa: Traced<P, A>): A {\n    return wa(monoid.empty)\n  }\n\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    extend,\n    extract\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "monoid",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<P>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Comonad\").Comonad2C<\"Traced\", P>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 62,
        "to": 78
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Traced<E, A>) => Traced<E, B> = (f) => (fa) => (p) => f(fa(p))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traced\").Traced<E, A>) => (p: E) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traced.ts",
      "lines": {
        "from": 98,
        "to": 98
      }
    }
  },
  {
    "name": "traverse",
    "text": "\n\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n\n/**\n * `traverse` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function traverse<T extends URIS, G extends URIS>(\n  T: Traversable1<T>,\n  G: Traversable1<G>\n): {\n  <F extends URIS>(F: Applicative1<F>): <A, B>(\n    f: (a: A) => Kind<F, B>\n  ) => (tga: Kind<T, Kind<G, A>>) => Kind<F, Kind<T, Kind<G, B>>>\n  <F>(F: Applicative<F>): <A, B>(f: (a: A) => HKT<F, B>) => (tga: Kind<T, Kind<G, A>>) => HKT<F, Kind<T, Kind<G, B>>>\n}",
    "docs": "/**\n * `traverse` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <F extends \"ReadonlyRecord\" | \"Option\" | \"ReadonlyNonEmptyArray\" | \"NonEmptyArray\" | \"Eq\" | \"Ord\" | \"IO\" | \"Task\" | \"ReadonlyArray\" | \"Array\" | \"Identity\" | \"Record\" | \"TaskOption\" | \"Tree\" | \"Test\">(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>): <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, B>) => (tga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>>; <F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>): <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (tga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, B>>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 357,
        "to": 365
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<T, G>(\n  T: Traversable<T>,\n  G: Traversable<G>\n): <F>(F: Applicative<F>) => <A, B>(f: (a: A) => HKT<F, B>) => (tga: HKT<T, HKT<G, A>>) => HKT<F, HKT<T, HKT<G, B>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (tga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 366,
        "to": 369
      }
    }
  },
  {
    "name": "traverse",
    "text": "\nexport function traverse<T, G>(\n  T: Traversable<T>,\n  G: Traversable<G>\n): <F>(F: Applicative<F>) => <A, B>(f: (a: A) => HKT<F, B>) => (tga: HKT<T, HKT<G, A>>) => HKT<F, HKT<T, HKT<G, B>>> {\n  return (F) => {\n    const traverseT = T.traverse(F)\n    const traverseG = G.traverse(F)\n    return (f) => (fga) => traverseT(fga, (ga) => traverseG(ga, f))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>) => <A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (tga: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, B>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 370,
        "to": 379
      }
    }
  },
  {
    "name": "sequence",
    "text": "\n\n/**\n * `sequence` composition.\n *\n * @category combinators\n * @since 2.10.0\n */\nexport function sequence<T extends URIS, G extends URIS>(\n  T: Traversable1<T>,\n  G: Traversable1<G>\n): {\n  <F extends URIS>(F: Applicative1<F>): <A>(tgfa: Kind<T, Kind<G, Kind<F, A>>>) => Kind<F, Kind<T, Kind<G, A>>>\n  <F>(F: Applicative<F>): <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>>\n}",
    "docs": "/**\n * `sequence` composition.\n *\n * @category combinators\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "{ <F extends \"ReadonlyRecord\" | \"Option\" | \"ReadonlyNonEmptyArray\" | \"NonEmptyArray\" | \"Eq\" | \"Ord\" | \"IO\" | \"Task\" | \"ReadonlyArray\" | \"Array\" | \"Identity\" | \"Record\" | \"TaskOption\" | \"Tree\" | \"Test\">(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative1<F>): <A>(tgfa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<G, A>>>; <F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>): <A>(tgfa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>>; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 387,
        "to": 393
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<T, G>(\n  T: Traversable<T>,\n  G: Traversable<G>\n): <F>(F: Applicative<F>) => <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>) => <A>(tgfa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 394,
        "to": 397
      }
    }
  },
  {
    "name": "sequence",
    "text": "\nexport function sequence<T, G>(\n  T: Traversable<T>,\n  G: Traversable<G>\n): <F>(F: Applicative<F>) => <A>(tgfa: HKT<T, HKT<G, HKT<F, A>>>) => HKT<F, HKT<T, HKT<G, A>>> {\n  return (F) => {\n    const sequenceT = T.sequence(F)\n    const sequenceG = G.sequence(F)\n    return (fgha) => sequenceT(T.map(fgha, sequenceG))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "T",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<T>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<F>(F: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>) => <A>(tgfa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<T, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<G, A>>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 398,
        "to": 407
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\n\n/**\n * Use\n * - [`traverse`](#traverse)\n * - [`sequence`](#sequence)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport function getTraversableComposition<F extends URIS, G extends URIS>(\n  F: Traversable1<F>,\n  G: Traversable1<G>\n): TraversableComposition11<F, G>",
    "docs": "/**\n * Use\n * - [`traverse`](#traverse)\n * - [`sequence`](#sequence)\n *\n * instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable1<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition11<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 532,
        "to": 535
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\n/** @deprecated */\nexport function getTraversableComposition<F, G>(F: Traversable<F>, G: Traversable<G>): TraversableComposition<F, G>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 537,
        "to": 537
      }
    }
  },
  {
    "name": "getTraversableComposition",
    "text": "\n/** @deprecated */\nexport function getTraversableComposition<F, G>(F: Traversable<F>, G: Traversable<G>): TraversableComposition<F, G> {\n  const map = getFunctorComposition(F, G).map\n  const FC = getFoldableComposition(F, G)\n  const _traverse = traverse(F, G)\n  const _sequence = sequence(F, G)\n  return {\n    map,\n    reduce: FC.reduce,\n    foldMap: FC.foldMap,\n    reduceRight: FC.reduceRight,\n    traverse: (H) => {\n      const traverseH = _traverse(H)\n      return (fga, f) => pipe(fga, traverseH(f))\n    },\n    sequence: (H) => {\n      const sequenceH = _sequence(H)\n      return (fgha) => pipe(fgha, sequenceH)\n    }\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<F>"
          }
        },
        {
          "name": "G",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").Traversable<G>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Traversable\").TraversableComposition<F, G>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Traversable.ts",
      "lines": {
        "from": 539,
        "to": 558
      }
    }
  },
  {
    "name": "make",
    "text": "\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport function make<A>(value: A, forest: Forest<A> = []): Tree<A> {\n  return {\n    value,\n    forest\n  }\n}",
    "docs": "/**\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "value",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "forest",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 50,
        "to": 55
      }
    }
  },
  {
    "name": "getShow",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow<A>(S: Show<A>): Show<Tree<A>> {\n  const show = (t: Tree<A>): string => {\n    return A.isEmpty(t.forest)\n      ? `make(${S.show(t.value)})`\n      : `make(${S.show(t.value)}, [${t.forest.map(show).join(', ')}])`\n  }\n  return {\n    show\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Show\").Show<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 61,
        "to": 70
      }
    }
  },
  {
    "name": "getEq",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getEq<A>(E: Eq<A>): Eq<Tree<A>> {\n  let SA: Eq<Array<Tree<A>>>\n  const R: Eq<Tree<A>> = fromEquals((x, y) => E.equals(x.value, y.value) && SA.equals(x.forest, y.forest))\n  SA = A.getEq(R)\n  return R\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 76,
        "to": 81
      }
    }
  },
  {
    "name": "drawForest",
    "text": "\n\n/**\n * Neat 2-dimensional drawing of a forest\n *\n * @since 2.0.0\n */\nexport function drawForest(forest: Forest<string>): string {\n  return draw('\\n', forest)\n}",
    "docs": "/**\n * Neat 2-dimensional drawing of a forest\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "forest",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<string>"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 101,
        "to": 103
      }
    }
  },
  {
    "name": "drawTree",
    "text": "\n\n/**\n * Neat 2-dimensional drawing of a tree\n *\n * @example\n * import { make, drawTree } from 'fp-ts/Tree'\n *\n * const fa = make('a', [\n *   make('b'),\n *   make('c'),\n *   make('d', [make('e'), make('f')])\n * ])\n *\n * assert.strictEqual(drawTree(fa), `a\n *  b\n *  c\n *  d\n *     e\n *     f`)\n *\n *\n * @since 2.0.0\n */\nexport function drawTree(tree: Tree<string>): string {\n  return tree.value + drawForest(tree.forest)\n}",
    "docs": "/**\n * Neat 2-dimensional drawing of a tree\n *\n * @example\n * import { make, drawTree } from 'fp-ts/Tree'\n *\n * const fa = make('a', [\n *   make('b'),\n *   make('c'),\n *   make('d', [make('e'), make('f')])\n * ])\n *\n * assert.strictEqual(drawTree(fa), `a\n *  b\n *  c\n *  d\n *     e\n *     f`)\n *\n *\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "tree",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<string>"
          }
        }
      ],
      "returnType": {
        "__tag": "StringT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 127,
        "to": 129
      }
    }
  },
  {
    "name": "unfoldTree",
    "text": "\n\n/**\n * Build a (possibly infinite) tree from a seed value in breadth-first order.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldTree<A, B>(b: B, f: (b: B) => [A, Array<B>]): Tree<A> {\n  const [a, bs] = f(b)\n  return { value: a, forest: unfoldForest(bs, f) }\n}",
    "docs": "/**\n * Build a (possibly infinite) tree from a seed value in breadth-first order.\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => [A, B[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 137,
        "to": 140
      }
    }
  },
  {
    "name": "unfoldForest",
    "text": "\n\n/**\n * Build a (possibly infinite) forest from a list of seed values in breadth-first order.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldForest<A, B>(bs: Array<B>, f: (b: B) => [A, Array<B>]): Forest<A> {\n  return bs.map((b) => unfoldTree(b, f))\n}",
    "docs": "/**\n * Build a (possibly infinite) forest from a list of seed values in breadth-first order.\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "bs",
          "type": {
            "__tag": "Other",
            "values": "B[]"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B) => [A, B[]]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 148,
        "to": 150
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\n\n/**\n * Monadic tree builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldTreeM<M extends URIS4>(\n  M: Monad4<M>\n): <S, R, E, A, B>(b: B, f: (b: B) => Kind4<M, S, R, E, [A, Array<B>]>) => Kind4<M, S, R, E, Tree<A>>",
    "docs": "/**\n * Monadic tree builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 158,
        "to": 160
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 161,
        "to": 163
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A, B>(b: B, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 164,
        "to": 166
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS2>(\n  M: Monad2<M>\n): <E, A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E, A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 167,
        "to": 169
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(b: B, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 170,
        "to": 172
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(b: B, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 173,
        "to": 175
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M>(M: MonadHKT<M>): <A, B>(b: B, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Tree<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 176,
        "to": 176
      }
    }
  },
  {
    "name": "unfoldTreeM",
    "text": "\nexport function unfoldTreeM<M>(M: MonadHKT<M>): <A, B>(b: B, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Tree<A>> {\n  const unfoldForestMM = unfoldForestM(M)\n  return (b, f) => M.chain(f(b), ([a, bs]) => M.map(unfoldForestMM(bs, f), (ts) => ({ value: a, forest: ts })))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(b: B, f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 177,
        "to": 180
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\n\n/**\n * Monadic forest builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function unfoldForestM<M extends URIS4>(\n  M: Monad4<M>\n): <S, R, E, A, B>(bs: Array<B>, f: (b: B) => Kind4<M, S, R, E, [A, Array<B>]>) => Kind4<M, S, R, E, Forest<A>>",
    "docs": "/**\n * Monadic forest builder, in depth-first order\n *\n * @category constructors\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad4<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<S, R, E, A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind4<M, S, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 188,
        "to": 190
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS3>(\n  M: Monad3<M>\n): <R, E, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 191,
        "to": 193
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS3, E>(\n  M: Monad3C<M, E>\n): <R, A, B>(bs: Array<B>, f: (b: B) => Kind3<M, R, E, [A, Array<B>]>) => Kind3<M, R, E, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind3<M, R, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 194,
        "to": 196
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS2>(\n  M: Monad2<M>\n): <R, E, B>(bs: Array<B>, f: (b: B) => Kind2<M, R, [E, Array<B>]>) => Kind2<M, R, Forest<E>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<R, E, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, [E, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, R, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<E>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 197,
        "to": 199
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS2, E>(\n  M: Monad2C<M, E>\n): <A, B>(bs: Array<B>, f: (b: B) => Kind2<M, E, [A, Array<B>]>) => Kind2<M, E, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind2<M, E, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 200,
        "to": 202
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M extends URIS>(\n  M: Monad1<M>\n): <A, B>(bs: Array<B>, f: (b: B) => Kind<M, [A, Array<B>]>) => Kind<M, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 203,
        "to": 205
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M>(\n  M: MonadHKT<M>\n): <A, B>(bs: Array<B>, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Forest<A>>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 206,
        "to": 208
      }
    }
  },
  {
    "name": "unfoldForestM",
    "text": "\nexport function unfoldForestM<M>(\n  M: MonadHKT<M>\n): <A, B>(bs: Array<B>, f: (b: B) => HKT<M, [A, Array<B>]>) => HKT<M, Forest<A>> {\n  const traverseM = A.traverse(M)\n  return (bs, f) =>\n    pipe(\n      bs,\n      traverseM((b) => unfoldTreeM(M)(b, f))\n    )\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(bs: B[], f: (b: B) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, [A, B[]]>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<M, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Forest<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 209,
        "to": 218
      }
    }
  },
  {
    "name": "elem",
    "text": "\n\n// TODO: curry in v3\n/**\n * @since 2.0.0\n */\nexport function elem<A>(E: Eq<A>): (a: A, fa: Tree<A>) => boolean {\n  const go = (a: A, fa: Tree<A>): boolean => {\n    if (E.equals(a, fa.value)) {\n      return true\n    }\n    return fa.forest.some((tree) => go(a, tree))\n  }\n  return go\n}",
    "docs": "/**\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "E",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Eq\").Eq<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(a: A, fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => boolean"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 224,
        "to": 232
      }
    }
  },
  {
    "name": "fold",
    "text": "\n\n/**\n * Fold a tree into a \"summary\" value in depth-first order.\n *\n * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.\n *\n * This is also known as the catamorphism on trees.\n *\n * @example\n * import { fold, make } from 'fp-ts/Tree'\n * import { concatAll } from 'fp-ts/Monoid'\n * import { MonoidSum } from 'fp-ts/number'\n *\n * const t = make(1, [make(2), make(3)])\n *\n * const sum = concatAll(MonoidSum)\n *\n * // Sum the values in a tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)\n *\n * // Find the maximum value in the tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)\n *\n * // Count the number of leaves in the tree:\n * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)\n *\n * @category destructors\n * @since 2.6.0\n */\nexport function fold<A, B>(f: (a: A, bs: Array<B>) => B): (tree: Tree<A>) => B {\n  const go = (tree: Tree<A>): B => f(tree.value, tree.forest.map(go))\n  return go\n}",
    "docs": "/**\n * Fold a tree into a \"summary\" value in depth-first order.\n *\n * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.\n *\n * This is also known as the catamorphism on trees.\n *\n * @example\n * import { fold, make } from 'fp-ts/Tree'\n * import { concatAll } from 'fp-ts/Monoid'\n * import { MonoidSum } from 'fp-ts/number'\n *\n * const t = make(1, [make(2), make(3)])\n *\n * const sum = concatAll(MonoidSum)\n *\n * // Sum the values in a tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)\n *\n * // Find the maximum value in the tree:\n * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)\n *\n * // Count the number of leaves in the tree:\n * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)\n *\n * @category destructors\n * @since 2.6.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, bs: B[]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(tree: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 262,
        "to": 265
      }
    }
  },
  {
    "name": "ap",
    "text": "const ap: <A>(fa: Tree<A>) => <B>(fab: Tree<(a: A) => B>) => Tree<B> = (fa) => (fab) => _ap(fab, fa)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<B>(fab: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<(a: A) => B>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 307,
        "to": 307
      }
    }
  },
  {
    "name": "chain",
    "text": "const chain = <A, B>(f: (a: A) => Tree<B>) => (ma: Tree<A>): Tree<B> => {\n  const { value, forest } = f(ma.value)\n  const concat = A.getMonoid<Tree<B>>().concat\n  return {\n    value,\n    forest: concat(forest, ma.forest.map(chain(f)))\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(ma: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 315,
        "to": 322
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <A, B>(f: (wa: Tree<A>) => B) => (wa: Tree<A>) => Tree<B> = (f) => (wa) => ({\n  value: f(wa),\n  forest: wa.forest.map(extend(f))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => { value: B; forest: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 328,
        "to": 331
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => (fa: Tree<A>) => Tree<B> = (f) => (fa) => ({\n  value: f(fa.value),\n  forest: fa.forest.map(map(f))\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => { value: B; forest: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>[]; }"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 360,
        "to": 363
      }
    }
  },
  {
    "name": "reduce",
    "text": "const reduce = <A, B>(b: B, f: (b: B, a: A) => B) => (fa: Tree<A>): B => {\n  let r: B = f(b, fa.value)\n  const len = fa.forest.length\n  for (let i = 0; i < len; i++) {\n    r = pipe(fa.forest[i], reduce(r, f))\n  }\n  return r\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(b: B, a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 369,
        "to": 376
      }
    }
  },
  {
    "name": "foldMap",
    "text": "const foldMap: <M>(M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: Tree<A>) => M = (M) => (f) =>\n  reduce(M.empty, (acc, a) => M.concat(acc, f(a)))",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(f: (a: A) => M) => (fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => M"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 382,
        "to": 383
      }
    }
  },
  {
    "name": "reduceRight",
    "text": "const reduceRight = <A, B>(b: B, f: (a: A, b: B) => B) => (fa: Tree<A>): B => {\n  let r: B = b\n  const len = fa.forest.length\n  for (let i = len - 1; i >= 0; i--) {\n    r = pipe(fa.forest[i], reduceRight(r, f))\n  }\n  return f(fa.value, r)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "b",
          "type": {
            "__tag": "Other",
            "values": "B"
          }
        },
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A, b: B) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => B"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 389,
        "to": 396
      }
    }
  },
  {
    "name": "extract",
    "text": "const extract: <A>(wa: Tree<A>) => A = (wa) => wa.value",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "wa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 402,
        "to": 402
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse1<URI> = <F>(\n  F: ApplicativeHKT<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => (ta: Tree<A>) => HKT<F, Tree<B>>) => {\n  const traverseF = A.traverse(F)\n  const out = <A, B>(f: (a: A) => HKT<F, B>) => (ta: Tree<A>): HKT<F, Tree<B>> =>\n    F.ap(\n      F.map(f(ta.value), (value: B) => (forest: Forest<B>) => ({\n        value,\n        forest\n      })),\n      pipe(ta.forest, traverseF(out(f)))\n    )\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => (ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<B>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 407,
        "to": 420
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable1<URI>['sequence'] = <F>(\n  F: ApplicativeHKT<F>\n): (<A>(ta: Tree<HKT<F, A>>) => HKT<F, Tree<A>>) => traverse(F)(identity)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(ta: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 425,
        "to": 427
      }
    }
  },
  {
    "name": "of",
    "text": "const of: Pointed1<URI>['of'] = (a) => make(a)",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Tree\").Tree<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tree.ts",
      "lines": {
        "from": 433,
        "to": 433
      }
    }
  },
  {
    "name": "getApply",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply<S>(S: Semigroup<S>): Apply2C<URI, S> {\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: (fab, fa) => [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))]\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"Tuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 49,
        "to": 56
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative<M>(M: Monoid<M>): Applicative2C<URI, M> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"Tuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 66,
        "to": 75
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getChain<S>(S: Semigroup<S>): Chain2C<URI, S> {\n  const A = getApply(S)\n  return {\n    URI,\n    _E: undefined as any,\n    map: A.map,\n    ap: A.ap,\n    chain: (ma, f) => {\n      const [b, s] = f(fst(ma))\n      return [b, S.concat(snd(ma), s)]\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<S>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"Tuple\", S>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 81,
        "to": 93
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonad<M>(M: Monoid<M>): Monad2C<URI, M> {\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    of: of(M)\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"Tuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 99,
        "to": 109
      }
    }
  },
  {
    "name": "getChainRec",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getChainRec<M>(M: Monoid<M>): ChainRec2C<URI, M> {\n  const chainRec = <A, B>(a: A, f: (a: A) => [Either<A, B>, M]): [B, M] => {\n    let result: [Either<A, B>, M] = f(a)\n    let acc: M = M.empty\n    let s: Either<A, B> = fst(result)\n    while (s._tag === 'Left') {\n      acc = M.concat(acc, snd(result))\n      result = f(s.left)\n      s = fst(result)\n    }\n    return [s.right, M.concat(acc, snd(result))]\n  }\n\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: C.map,\n    ap: C.ap,\n    chain: C.chain,\n    chainRec\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ChainRec\").ChainRec2C<\"Tuple\", M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 115,
        "to": 137
      }
    }
  },
  {
    "name": "swap",
    "text": "const swap = <A, E>(ea: [A, E]): [E, A] => [snd(ea), fst(ea)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ea",
          "type": {
            "__tag": "Other",
            "values": "[A, E]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "[E, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 43,
        "to": 43
      }
    }
  },
  {
    "name": "bimap",
    "text": "const bimap: <E, G, A, B>(mapSnd: (e: E) => G, mapFst: (a: A) => B) => (fa: [A, E]) => [B, G] = (f, g) => (\n  fa\n) => [g(fst(fa)), f(snd(fa))]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        },
        {
          "name": "g",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(fa: [A, E]) => [B, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 178,
        "to": 180
      }
    }
  },
  {
    "name": "mapFst",
    "text": "const mapFst: <A, B>(f: (a: A) => B) => <E>(fa: [A, E]) => [B, E] = (f) => (fa) => [f(fst(fa)), snd(fa)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: [A, E]) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 190,
        "to": 190
      }
    }
  },
  {
    "name": "mapSnd",
    "text": "const mapSnd: <E, G>(f: (e: E) => G) => <A>(fa: [A, E]) => [A, G] = (f) => (fa) => [fst(fa), f(snd(fa))]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(e: E) => G"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: [A, E]) => [A, G]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 200,
        "to": 200
      }
    }
  },
  {
    "name": "compose",
    "text": "const compose: <A, B>(ab: [B, A]) => <C>(bc: [C, B]) => [C, A] = (ab) => (bc) => [fst(bc), snd(ab)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "ab",
          "type": {
            "__tag": "Other",
            "values": "[B, A]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<C>(bc: [C, B]) => [C, A]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 206,
        "to": 206
      }
    }
  },
  {
    "name": "extend",
    "text": "const extend: <E, A, B>(f: (wa: [A, E]) => B) => (wa: [A, E]) => [B, E] = (f) => (wa) => [f(wa), snd(wa)]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(wa: [A, E]) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(wa: [A, E]) => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 212,
        "to": 212
      }
    }
  },
  {
    "name": "traverse",
    "text": "const traverse: PipeableTraverse2<URI> = <F>(\n  F: Applicative<F>\n): (<A, B>(f: (a: A) => HKT<F, B>) => <E>(as: [A, E]) => HKT<F, [B, E]>) => {\n  return (f) => (ta) => F.map(f(fst(ta)), (b) => [b, snd(ta)])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, B>(f: (a: A) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, B>) => <E>(as: [A, E]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [B, E]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 251,
        "to": 255
      }
    }
  },
  {
    "name": "sequence",
    "text": "const sequence: Traversable2<URI>['sequence'] = <F>(F: Applicative<F>) => <A, E>(\n  fas: [HKT<F, A>, E]\n): HKT<F, [A, E]> => {\n  return F.map(fst(fas), (a) => [a, snd(fas)])\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A, E>(fas: [import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, A>, E]) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").HKT<F, [A, E]>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Tuple.ts",
      "lines": {
        "from": 260,
        "to": 264
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\n\n/**\n * Use `EitherT` instead.\n *\n * @since 2.0.0\n * @deprecated\n */\n\nexport function getValidationM<E, M extends URIS2>(S: Semigroup<E>, M: Monad2<M>): ValidationM2<M, E>",
    "docs": "/**\n * Use `EitherT` instead.\n *\n * @since 2.0.0\n * @deprecated\n */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM2<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 86,
        "to": 86
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\n/** @deprecated */\n\nexport function getValidationM<E, M extends URIS>(S: Semigroup<E>, M: Monad1<M>): ValidationM1<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM1<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 89,
        "to": 89
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\n/** @deprecated */\n\nexport function getValidationM<E, M>(S: Semigroup<E>, M: Monad<M>): ValidationM<M, E>",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 92,
        "to": 92
      }
    }
  },
  {
    "name": "getValidationM",
    "text": "\n/** @deprecated */\n\nexport function getValidationM<E, M>(S: Semigroup<E>, M: Monad<M>): ValidationM<M, E> {\n  const A = getApplicativeComposition(M, E.getApplicativeValidation(S))\n\n  return {\n    map: A.map,\n    ap: A.ap,\n    of: A.of,\n    chain: (ma, f) => M.chain(ma, (e) => (E.isLeft(e) ? M.of(E.left(e.left)) : f(e.right))),\n    alt: (me, that) =>\n      M.chain(me, (e1) =>\n        E.isRight(e1) ? M.of(e1) : M.map(that(), (e2) => (E.isLeft(e2) ? E.left(S.concat(e1.left, e2.left)) : e2))\n      )\n  }\n}",
    "docs": "/** @deprecated */",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<E>"
          }
        },
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ValidationT\").ValidationM<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/ValidationT.ts",
      "lines": {
        "from": 95,
        "to": 108
      }
    }
  },
  {
    "name": "getChain",
    "text": "\n\n/**\n * @category instances\n * @since 2.10.0\n */\nexport function getChain<W>(M: Monoid<W>): Chain2C<URI, W> {\n  const A = getApply(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    chain: (fa, f) => () => {\n      const [a, w1] = fa()\n      const [b, w2] = f(a)()\n      return [b, M.concat(w1, w2)]\n    }\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.10.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Chain\").Chain2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 172,
        "to": 185
      }
    }
  },
  {
    "name": "getMonad",
    "text": "\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getMonad<W>(M: Monoid<W>): Monad2C<URI, W> {\n  const A = getApplicative(M)\n  const C = getChain(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    of: A.of,\n    chain: C.chain\n  }\n}",
    "docs": "/**\n * @category instances\n * @since 2.0.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 191,
        "to": 202
      }
    }
  },
  {
    "name": "tell",
    "text": "const tell: <W>(w: W) => Writer<W, void> = (w) => () => [undefined, w]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "w",
          "type": {
            "__tag": "Other",
            "values": "W"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [any, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 36,
        "to": 36
      }
    }
  },
  {
    "name": "listen",
    "text": "const listen: <W, A>(fa: Writer<W, A>) => Writer<W, [A, W]> = (fa) => () => {\n  const [a, w] = fa()\n  return [[a, w], w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [[A, W], W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 44,
        "to": 47
      }
    }
  },
  {
    "name": "pass",
    "text": "const pass: <W, A>(fa: Writer<W, [A, (w: W) => W]>) => Writer<W, A> = (fa) => () => {\n  const [[a, f], w] = fa()\n  return [a, f(w)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, [A, (w: W) => W]>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "() => [A, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 55,
        "to": 58
      }
    }
  },
  {
    "name": "listens",
    "text": "const listens: <W, B>(f: (w: W) => B) => <A>(fa: Writer<W, A>) => Writer<W, [A, B]> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [[a, f(w)], w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(w: W) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>) => () => [[A, B], W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 66,
        "to": 69
      }
    }
  },
  {
    "name": "censor",
    "text": "const censor: <W>(f: (w: W) => W) => <A>(fa: Writer<W, A>) => Writer<W, A> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [a, f(w)]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(w: W) => W"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<A>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>) => () => [A, W]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 77,
        "to": 80
      }
    }
  },
  {
    "name": "map",
    "text": "const map: <A, B>(f: (a: A) => B) => <E>(fa: Writer<E, A>) => Writer<E, B> = (f) => (fa) => () => {\n  const [a, w] = fa()\n  return [f(a), w]\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "f",
          "type": {
            "__tag": "Other",
            "values": "(a: A) => B"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "<E>(fa: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<E, A>) => () => [B, E]"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 100,
        "to": 103
      }
    }
  },
  {
    "name": "getPointed",
    "text": "const getPointed = <W>(M: Monoid<W>): Pointed2C<URI, W> => ({\n  URI,\n  _E: undefined as any,\n  of: (a) => () => [a, M.empty]\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Pointed\").Pointed2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 131,
        "to": 135
      }
    }
  },
  {
    "name": "getApply",
    "text": "const getApply = <W>(S: Semigroup<W>): Apply2C<URI, W> => ({\n  URI,\n  _E: undefined as any,\n  map: _map,\n  ap: (fab, fa) => () => {\n    const [f, w1] = fab()\n    const [a, w2] = fa()\n    return [f(a), S.concat(w1, w2)]\n  }\n})",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "S",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Semigroup\").Semigroup<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 141,
        "to": 150
      }
    }
  },
  {
    "name": "getApplicative",
    "text": "const getApplicative = <W>(M: Monoid<W>): Applicative2C<URI, W> => {\n  const A = getApply(M)\n  const P = getPointed(M)\n  return {\n    URI,\n    _E: undefined as any,\n    map: _map,\n    ap: A.ap,\n    of: P.of\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monoid\").Monoid<W>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Applicative\").Applicative2C<\"Writer\", W>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 156,
        "to": 166
      }
    }
  },
  {
    "name": "evaluate",
    "text": "const evaluate: <W, A>(fa: Writer<W, A>) => A = (fa) => fa()[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 230,
        "to": 230
      }
    }
  },
  {
    "name": "execute",
    "text": "const execute: <W, A>(fa: Writer<W, A>) => W = (fa) => fa()[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "W"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 235,
        "to": 235
      }
    }
  },
  {
    "name": "evalWriter",
    "text": "const evalWriter: <W, A>(fa: Writer<W, A>) => A = (fa) => fa()[0]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "A"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 247,
        "to": 247
      }
    }
  },
  {
    "name": "execWriter",
    "text": "const execWriter: <W, A>(fa: Writer<W, A>) => W = (fa) => fa()[1]",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fa",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Writer\").Writer<W, A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "W"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/Writer.ts",
      "lines": {
        "from": 255,
        "to": 255
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\n\n/**\n * @since 2.4.0\n */\nexport function getWriterM<M extends URIS3>(M: Monad3<M>): WriterM3<M>",
    "docs": "/**\n * @since 2.4.0\n */",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad3<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM3<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 165,
        "to": 165
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS2>(M: Monad2<M>): WriterM2<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM2<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 166,
        "to": 166
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS2, E>(M: Monad2C<M, E>): WriterM2C<M, E>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad2C<M, E>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM2C<M, E>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 167,
        "to": 167
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M extends URIS>(M: Monad1<M>): WriterM1<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad1<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM1<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 168,
        "to": 168
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M>(M: Monad<M>): WriterM<M>",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 169,
        "to": 169
      }
    }
  },
  {
    "name": "getWriterM",
    "text": "\nexport function getWriterM<M>(M: Monad<M>): WriterM<M> {\n  const map = <W, A, B>(fa: WriterT<M, W, A>, f: (a: A) => B): WriterT<M, W, B> => () =>\n    M.map(fa(), ([a, w]) => [f(a), w])\n  return {\n    map,\n    evalWriter: (fa) => M.map(fa(), ([a]) => a),\n    execWriter: (fa) => M.map(fa(), ([_, w]) => w),\n    tell: (w) => () => M.of([undefined, w]),\n    listen: (fa) => () => M.map(fa(), ([a, w]) => [[a, w], w]),\n    pass: (fa) => () => M.map(fa(), ([[a, f], w]) => [a, f(w)]),\n    listens: (fa, f) => () => M.map(fa(), ([a, w]) => [[a, f(w)], w]),\n    censor: (fa, f) => () => M.map(fa(), ([a, w]) => [a, f(w)]),\n    getMonad: (W) => {\n      return {\n        _E: undefined as any,\n        map,\n        of: (a) => () => M.of([a, W.empty]),\n        ap: (mab, ma) => () => M.chain(mab(), ([f, w1]) => M.map(ma(), ([a, w2]) => [f(a), W.concat(w1, w2)])),\n        chain: (ma, f) => () => M.chain(ma(), ([a, w1]) => M.map(f(a)(), ([b, w2]) => [b, W.concat(w1, w2)]))\n      }\n    }\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "M",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Monad\").Monad<M>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/WriterT\").WriterM<M>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "src/WriterT.ts",
      "lines": {
        "from": 170,
        "to": 192
      }
    }
  },
  {
    "name": "deepStrictEqual",
    "text": "const deepStrictEqual = <A>(actual: A, expected: A) => {\n  assert.deepStrictEqual(actual, expected)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/util.ts",
      "lines": {
        "from": 7,
        "to": 9
      }
    }
  },
  {
    "name": "strictEqual",
    "text": "const strictEqual = <A>(actual: A, expected: A) => {\n  assert.strictEqual(actual, expected)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "actual",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        },
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "A"
          }
        }
      ],
      "returnType": {
        "__tag": "Void"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/util.ts",
      "lines": {
        "from": 11,
        "to": 13
      }
    }
  },
  {
    "name": "double",
    "text": "const double = (n: number): number => n * 2",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "n",
          "type": {
            "__tag": "NumberT"
          }
        }
      ],
      "returnType": {
        "__tag": "NumberT"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/util.ts",
      "lines": {
        "from": 15,
        "to": 15
      }
    }
  },
  {
    "name": "assertParSeq",
    "text": "const assertParSeq = (expected: ReadonlyArray<string>): AssertParSeq => async <F>(\n  F: Apply<F>,\n  MT: FromTask<F>,\n  run: (fa: HKT<F, unknown>) => Promise<unknown>\n) => {\n  // tslint:disable-next-line: readonly-array\n  const log: Array<string> = []\n  const a = MT.fromTask(T.delay(100)(T.fromIO(() => log.push('a'))))\n  const b = MT.fromTask(T.fromIO(() => log.push('b')))\n  const ab = sequenceT(F)(a, b)\n  await run(ab)\n  deepStrictEqual(log, expected)\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "expected",
          "type": {
            "__tag": "Other",
            "values": "readonly string[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/test/util\").AssertParSeq"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "test/util.ts",
      "lines": {
        "from": 42,
        "to": 54
      }
    }
  },
  {
    "name": "reverse2",
    "text": "const reverse2 = <A>(as: _.ReadonlyNonEmptyArray<A>): _.ReadonlyNonEmptyArray<A> => as.slice().reverse() as any",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "as",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/ReadonlyNonEmptyArray\").ReadonlyNonEmptyArray<A>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/ReadonlyNonEmptyArray.ts/reverse.ts",
      "lines": {
        "from": 11,
        "to": 11
      }
    }
  },
  {
    "name": "flow2",
    "text": "\n\nexport function flow2(...fns: ReadonlyArray<Function>): Function {\n  const len = fns.length\n  return function (this: any, ...x: ReadonlyArray<any>) {\n    let y = fns[0].apply(this, x)\n    for (let i = 1; i < len; i++) {\n      y = fns[i].call(this, y)\n    }\n    return y\n  }\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "fns",
          "type": {
            "__tag": "Other",
            "values": "readonly Function[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "Function"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/flow.ts",
      "lines": {
        "from": 6,
        "to": 15
      }
    }
  },
  {
    "name": "pipe2",
    "text": "\n\nexport function pipe2(a: unknown, ...fns: ReadonlyArray<Function>): unknown {\n  let out: unknown = a\n  for (let i = 0; i < fns.length; i++) {\n    out = fns[i](out)\n  }\n  return out\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "a",
          "type": {
            "__tag": "Unknown"
          }
        },
        {
          "name": "fns",
          "type": {
            "__tag": "Other",
            "values": "readonly Function[]"
          }
        }
      ],
      "returnType": {
        "__tag": "Unknown"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "perf/function/pipe.ts",
      "lines": {
        "from": 6,
        "to": 12
      }
    }
  },
  {
    "name": "apS",
    "text": "const apS = <F extends URIS>(F: _.Apply1<F>) => (\n  s: Kind<F, string>,\n  n: Kind<F, number>\n): Kind<F, { s: string; n: number }> => {\n  const apS = _.apS(F)\n  const bindTo = Fu.bindTo(F)\n  return pipe(s, bindTo('s'), apS('n', n))\n}",
    "docs": "",
    "signature": {
      "parameters": [
        {
          "name": "F",
          "type": {
            "__tag": "Other",
            "values": "import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/Apply\").Apply1<F>"
          }
        }
      ],
      "returnType": {
        "__tag": "Other",
        "values": "(s: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, string>, n: import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, number>) => import(\"/home/bb8/dev/tsearch/projects/fp-ts/src/HKT\").Kind<F, { s: string; n: number; }>"
      }
    },
    "module": "fp-ts",
    "location": {
      "path": "dtslint/ts3.5/Apply.ts",
      "lines": {
        "from": 12,
        "to": 19
      }
    }
  }
]
